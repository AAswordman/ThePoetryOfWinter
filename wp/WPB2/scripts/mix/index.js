/*! For license information please see index.js.LICENSE.txt */
import * as __WEBPACK_EXTERNAL_MODULE__minecraft_server_fb7572af__ from "@minecraft/server";
import * as __WEBPACK_EXTERNAL_MODULE__minecraft_server_ui_f6791859__ from "@minecraft/server-ui";
var __webpack_modules__ = {
        475: (t, e, n) => {
            n.d(e, {
                Z: () => i
            });
            class i {
                constructor(t) {
                    this.val = null != t ? t : [
                        [0, 0, 0, 0],
                        [0, 0, 0, 0],
                        [0, 0, 0, 0],
                        [0, 0, 0, 0]
                    ]
                }
                clone() {
                    return new i(this.val)
                }
                mul(t) {
                    const e = new i;
                    for (let n = 0; n < 4; n++)
                        for (let i = 0; i < 4; i++) {
                            let s = 0;
                            this.val[n].forEach(((e, n) => s += e * t.val[n][i])), e.val[n][i] = s
                        }
                    return e
                }
            }
        },
        721: (t, e, n) => {
            n.d(e, {
                Z: () => s
            });
            var i = n(475);
            class s {
                constructor(t, e, n) {
                    "number" == typeof t && "number" == typeof e && "number" == typeof n ? (this.x = t, this.y = e, this.z = n) : void 0 === t && void 0 === e && void 0 === n ? (this.x = 0, this.y = 0, this.z = 0) : (this.x = t.x, this.y = t.y, this.z = t.z)
                }
                set(t, e, n) {
                    return "number" == typeof t ? "number" == typeof e && "number" == typeof n && (this.x = t, this.y = e, this.z = n) : this.set(t.x, t.y, t.z), this
                }
                add(t, e, n) {
                    return "number" == typeof t ? "number" == typeof e && "number" == typeof n && (this.x += t, this.y += e, this.z += n) : this.add(t.x, t.y, t.z), this
                }
                sub(t, e, n) {
                    return "number" == typeof t ? "number" == typeof e && "number" == typeof n && (this.x -= t, this.y -= e, this.z -= n) : this.sub(t.x, t.y, t.z), this
                }
                scl(t, e, n) {
                    return "number" == typeof t ? "number" == typeof e && "number" == typeof n ? (this.x *= t, this.y *= e, this.z *= n) : void 0 === e && void 0 === n && (this.x *= t, this.y *= t, this.z *= t) : this.scl(t.x, t.y, t.z), this
                }
                div(t, e, n) {
                    return "number" == typeof t ? "number" == typeof e && "number" == typeof n ? (this.x /= t, this.y /= e, this.z /= n) : void 0 === e && void 0 === n && (this.x /= t, this.y /= t, this.z /= t) : this.div(t.x, t.y, t.z), this
                }
                len() {
                    return Math.sqrt(Math.pow(this.x, 2) + Math.pow(this.y, 2) + Math.pow(this.z, 2))
                }
                len2() {
                    return Math.pow(this.x, 2) + Math.pow(this.y, 2) + Math.pow(this.z, 2)
                }
                equals(t) {
                    return this.x === t.x && this.y === t.y && this.z === t.z
                }
                distance(t) {
                    return this.clone().sub(t).len()
                }
                toString() {
                    return `(${this.x}, ${this.y}, ${this.z})`
                } [Symbol.toStringTag]() {
                    return this.toString()
                }
                floor() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
                }
                round() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
                }
                ceil() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
                }
                abs() {
                    return this.x = Math.abs(this.x), this.y = Math.abs(this.y), this.z = Math.abs(this.z), this
                }
                mul(t) {
                    if (t instanceof i.Z) {
                        const e = t.val;
                        return this.set(this.x * e[0][0] + this.y * e[0][1] + this.z * e[0][2] + e[0][3], this.x * e[1][0] + this.y * e[1][1] + this.z * e[1][2] + e[1][3], this.x * e[2][0] + this.y * e[2][1] + this.z * e[2][2] + e[2][3])
                    }
                    return t.x * this.x + t.y * this.y + t.z * this.z
                }
                normalize() {
                    return console.log("nor0: " + this), this.div(this.len()), console.log("nor1: " + this), this
                }
                clone() {
                    return new s(this.x, this.y, this.z)
                }
                toArray() {
                    return [this.x, this.y, this.z]
                }
            }
            s.down = new s(0, -1, 0), s.forward = new s(0, 0, 1), s.back = new s(0, 0, -1), s.left = new s(-1, 0, 0), s.one = new s(1, 1, 1), s.right = new s(1, 0, 0), s.up = new s(0, 1, 0), s.zero = new s(0, 0, 0)
        },
        724: (t, e, n) => {
            n.d(e, {
                Z: () => u
            });
            var i = n(205),
                s = n(721),
                r = n(801),
                a = n(409),
                o = n(960);
            class u {
                constructor(t) {
                    this.command = new o.Z(this), this._dimension = t
                }
                spawnParticle(t, e) {
                    this._dimension.spawnParticle(t, a.Z.getLocation(e), new i.MolangVariableMap)
                }
                createExplosion(t, e, n) {
                    this._dimension.createExplosion(a.Z.getLocation(t), e, n)
                }
                get dimension() {
                    return this._dimension
                }
                getPlayers(t) {
                    return Array.from(this._dimension.getPlayers(t))
                }
                getEntities(t) {
                    let e = this._dimension.getEntities(t),
                        n = [];
                    for (let t of e) t.dimension === this._dimension && n.push(t);
                    return n
                }
                getBlock(t) {
                    return this._dimension.getBlock(t instanceof s.Z ? a.Z.getBlockLocation(t) : t)
                }
                setBlock(t, e, n = 0) {
                    if ("string" == typeof e) this.command.run(`setBlock ${t.x} ${t.y} ${t.z} ${e} ${n}`);
                    else {
                        let n = this.getBlock(t);
                        null == n || n.setType(e)
                    }
                }
                setBlockAsync(t, e) {
                    this.runCommandAsync(`setBlock ${t.x} ${t.y} ${t.z} ${e}`)
                }
                digBlock(t) {
                    try {
                        return this.command.run(`setBlock ${t.x} ${t.y} ${t.z} air 0 destroy`), !0
                    } catch (t) {
                        return !1
                    }
                }
                spawnItem(t, e) {
                    try {
                        return this._dimension.spawnItem(t, a.Z.getBlockLocation(e))
                    } catch (t) {
                        return void r.Z.console.warn(t)
                    }
                }
                spawnEntity(t, e) {
                    try {
                        return this._dimension.spawnEntity(t, a.Z.getBlockLocation(e))
                    } catch (t) {
                        return void r.Z.console.warn(t)
                    }
                }
                runCommandAsync(t) {
                    return this._dimension.runCommandAsync(t)
                }
                static getInstance(t) {
                    let e = t;
                    return this.propertyNameCache in e ? e[this.propertyNameCache] : e[this.propertyNameCache] = new u(e)
                }
            }
            u.propertyNameCache = "exCache"
        },
        361: (t, e, n) => {
            n.d(e, {
                W: () => r,
                Z: () => i,
                to: () => s
            });
            class i {
                static throwError(t) {
                    this.errorStack.push(t)
                }
                static init(t) {
                    t.getEvents().events.tick.subscribe((t => {
                        if (this.errorStack.length > 0) throw this.errorStack.shift()
                    }))
                }
            }

            function s(t) {
                return t.then((t => [t, void 0])).catch((t => (i.throwError(t), [void 0, t])))
            }

            function r(t) {
                try {
                    return t()
                } catch (t) {
                    return
                }
            }
            i.errorStack = []
        },
        215: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            __webpack_require__.d(__webpack_exports__, {
                Z: () => ExGameClient
            });
            var _ExGameConfig_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(801),
                _events_ExClientEvents_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(654),
                _minecraft_server__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(205),
                _entity_ExPlayer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(782),
                _ExDimension_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(724),
                _ui_ExActionAlert_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(217),
                _reflect_metadata_Reflect_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(855),
                _reflect_metadata_Reflect_js__WEBPACK_IMPORTED_MODULE_6___default = __webpack_require__.n(_reflect_metadata_Reflect_js__WEBPACK_IMPORTED_MODULE_6__),
                _events_eventDecoratorFactory_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(478),
                _utils_notUtillTask_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(632),
                __awaiter = function(t, e, n, i) {
                    return new(n || (n = Promise))((function(s, r) {
                        function a(t) {
                            try {
                                u(i.next(t))
                            } catch (t) {
                                r(t)
                            }
                        }

                        function o(t) {
                            try {
                                u(i.throw(t))
                            } catch (t) {
                                r(t)
                            }
                        }

                        function u(t) {
                            t.done ? s(t.value) : function(t) {
                                return t instanceof n ? t : new n((function(e) {
                                    e(t)
                                }))
                            }(t.value).then(a, o)
                        }
                        u((i = i.apply(t, e || [])).next())
                    }))
                };
            class ExGameClient {
                constructor(server, id, player) {
                    this.debuggerChatTest = e => {
                        e.message.startsWith("*/") && _ExGameConfig_js__WEBPACK_IMPORTED_MODULE_0__.Z.console.info(eval(e.message.substring(2, e.message.length)))
                    }, this._server = server, this.clientId = id, this.player = player, this.exPlayer = _entity_ExPlayer_js__WEBPACK_IMPORTED_MODULE_3__.Z.getInstance(player), this.playerName = player.name, this._events = new _events_ExClientEvents_js__WEBPACK_IMPORTED_MODULE_1__.Z(this), _ExGameConfig_js__WEBPACK_IMPORTED_MODULE_0__.Z.config.debug ? this.asDebugger() : this.notDebugger(), (0, _utils_notUtillTask_js__WEBPACK_IMPORTED_MODULE_8__.Z)(this, (() => __awaiter(this, void 0, void 0, (function*() {
                        try {
                            return yield this.exPlayer.command.run("testfor @s"), !0
                        } catch (t) {
                            return !1
                        }
                    }))), (() => this.onLoaded())), this.onJoin(), (0, _events_eventDecoratorFactory_js__WEBPACK_IMPORTED_MODULE_7__.B)(this.getEvents(), this)
                }
                debug_removeAllTag() {
                    for (let t of this.exPlayer.getTags()) this.exPlayer.removeTag(t)
                }
                debug_alert() {
                    (new _ui_ExActionAlert_js__WEBPACK_IMPORTED_MODULE_5__.Z).title("aaa").body("bbbb").button("alert", (() => {})).button("alert", (() => {})).show(this.player)
                }
                getDimension(t) {
                    return void 0 !== t ? _minecraft_server__WEBPACK_IMPORTED_MODULE_2__.world.getDimension(t) : this.exPlayer.getDimension()
                }
                getExDimension(t) {
                    return _ExDimension_js__WEBPACK_IMPORTED_MODULE_4__.Z.getInstance(this.getDimension(...arguments))
                }
                getPlayers() {
                    return _minecraft_server__WEBPACK_IMPORTED_MODULE_2__.world.getPlayers()
                }
                getServer() {
                    return this._server
                }
                setInterworkingPool(t) {
                    this._pool = t, this._poolCache = {};
                    for (const t in this._pool) this._poolCache[t] = this._pool[t], Object.defineProperty(this._pool, t, {
                        set: e => {
                            this._poolCache[t] = e
                        },
                        get: () => {
                            const e = this._poolCache[t];
                            return "function" == typeof e ? function() {
                                const n = {
                                    type: "pool",
                                    name: t,
                                    args: [...arguments]
                                };
                                return new Promise(((t, i) => {
                                    t(e(...n.args))
                                }))
                            } : e
                        },
                        enumerable: !0
                    })
                }
                getInterworkingPool() {
                    return this._pool
                }
                onJoin() {}
                onLoaded() {}
                onLeave() {
                    this._events.cancelAll()
                }
                getEvents() {
                    return this._events
                }
                asDebugger() {
                    this.player.addTag("debugger"), this._events.exEvents.chat.subscribe(this.debuggerChatTest)
                }
                notDebugger() {
                    this.player.removeTag("debugger")
                }
                setTimeout(t, e) {
                    let n = 0,
                        i = s => {
                            n += 1e3 * s.deltaTime, n > e && (this.getEvents().exEvents.tick.unsubscribe(i), t())
                        };
                    this.getEvents().exEvents.tick.subscribe(i)
                }
            }
        },
        801: (t, e, n) => {
            n.d(e, {
                Z: () => s
            });
            var i = n(205);
            class s {
                static runCommandAsync(t) {
                    return e = this, n = void 0, r = function*() {
                        try {
                            return i.world.getDimension(i.MinecraftDimensionTypes.overworld).runCommandAsync(t)
                        } catch (t) {
                            console.warn("Console error:", t)
                        }
                    }, new((s = void 0) || (s = Promise))((function(t, i) {
                        function a(t) {
                            try {
                                u(r.next(t))
                            } catch (t) {
                                i(t)
                            }
                        }

                        function o(t) {
                            try {
                                u(r.throw(t))
                            } catch (t) {
                                i(t)
                            }
                        }

                        function u(e) {
                            e.done ? t(e.value) : function(t) {
                                return t instanceof s ? t : new s((function(e) {
                                    e(t)
                                }))
                            }(e.value).then(a, o)
                        }
                        u((r = r.apply(e, n || [])).next())
                    }));
                    var e, n, s, r
                }
            }
        },
        703: (t, e, n) => {
            n.d(e, {
                Z: () => h
            });
            var i = n(205),
                s = n(418),
                r = n(721),
                a = n(522),
                o = n(960),
                u = n(724);
            class h {
                constructor(t) {
                    if (this.command = new o.Z(this), this._entity = t, h.propertyNameCache in t) throw new Error("Already have a instance in entity.please use ExEntity.getInstance to get it.");
                    Reflect.set(t, h.propertyNameCache, this)
                }
                damage(t) {
                    this.runCommandAsync(`damage @s ${t}`)
                }
                causeDamageTo(t, e) {
                    t instanceof h && (t = t.entity), o.Z.run(this, `damage {0} ${e} entity_attack entity @s`, t)
                }
                getPreRemoveHealth() {
                    return this._damage
                }
                removeHealth(t, e) {
                    void 0 === this._damage ? (this._damage = e, t.setTimeout((() => {
                        var t;
                        let e = this.getHealthComponent();
                        e.current > .5 && e.setCurrent(Math.max(.5, e.current - (null !== (t = this._damage) && void 0 !== t ? t : 0))), this._damage = void 0
                    }), 0)) : this._damage += e
                }
                addHealth(t, e) {
                    this.removeHealth(t, -e)
                }
                get nameTag() {
                    return this._entity.nameTag
                }
                set nameTag(t) {
                    this._entity.nameTag = t
                }
                get entity() {
                    return this._entity
                }
                set entity(t) {
                    this._entity = t
                }
                static getInstance(t) {
                    let e = t;
                    return this.propertyNameCache in e ? Reflect.get(e, this.propertyNameCache) : new h(e)
                }
                getDimension() {
                    return this._entity.dimension
                }
                getExDimension() {
                    return u.Z.getInstance(this.getDimension())
                }
                addTag(t) {
                    return this._entity.addTag(t), t
                }
                getTags() {
                    return this._entity.getTags()
                }
                hasTag(t) {
                    return this._entity.hasTag(t)
                }
                removeTag(t) {
                    return this._entity.removeTag(t), t
                }
                runCommandAsync(t) {
                    return this._entity.runCommandAsync(t)
                }
                detectArmor(t, e, n, i) {
                    return s = this, r = void 0, o = function*() {
                        try {
                            return yield this.command.run("execute if entity @s[hasitem={location=slot.armor.head,item=" + t + "}] if entity @s[hasitem={location=slot.armor.chest,item=" + e + "}] if entity @s[hasitem={location=slot.armor.legs,item=" + n + "}] if entity @s[hasitem={location=slot.armor.feet,item=" + i + "}] run testfor @s"), !0
                        } catch (t) {
                            return !1
                        }
                    }, new((a = void 0) || (a = Promise))((function(t, e) {
                        function n(t) {
                            try {
                                u(o.next(t))
                            } catch (t) {
                                e(t)
                            }
                        }

                        function i(t) {
                            try {
                                u(o.throw(t))
                            } catch (t) {
                                e(t)
                            }
                        }

                        function u(e) {
                            e.done ? t(e.value) : function(t) {
                                return t instanceof a ? t : new a((function(e) {
                                    e(t)
                                }))
                            }(e.value).then(n, i)
                        }
                        u((o = o.apply(s, r || [])).next())
                    }));
                    var s, r, a, o
                }
                getScoresManager() {
                    return new s.Z(this._entity)
                }
                triggerEvent(t) {
                    this._entity.triggerEvent(t)
                }
                getPosition() {
                    return new r.Z(this.entity.location)
                }
                getRotation() {
                    return this.entity.rotation
                }
                setPosition(t, e = this.entity.dimension) {
                    this.entity.teleport(t, e, this.entity.rotation.x, this.entity.rotation.y)
                }
                setDimension(t) {
                    this.setPosition(this.getPosition(), t)
                }
                getViewDirection() {
                    return new r.Z(this.entity.viewDirection)
                }
                hasComponent(t) {
                    return this._entity.hasComponent(t)
                }
                getComponent(t) {
                    return this._entity.getComponent(t)
                }
                hasHealthComponent() {
                    return this.hasComponent(i.EntityHealthComponent.componentId)
                }
                getHealthComponent() {
                    return this.getComponent(i.EntityHealthComponent.componentId)
                }
                getHealth() {
                    return this.getHealthComponent().current
                }
                getMaxHealth() {
                    return this.getHealthComponent().value
                }
                hasInventoryComponent() {
                    return this.hasComponent(i.EntityInventoryComponent.componentId)
                }
                getInventoryComponent() {
                    return this.getComponent(i.EntityInventoryComponent.componentId)
                }
                getBag() {
                    return new a.Z(this)
                }
                hasVariantComponent() {
                    return this.hasComponent(i.EntityVariantComponent.componentId)
                }
                getVariantComponent() {
                    return this.getComponent(i.EntityVariantComponent.componentId)
                }
                getVariant() {
                    var t, e;
                    return null !== (e = null === (t = this.getVariantComponent()) || void 0 === t ? void 0 : t.value) && void 0 !== e ? e : 0
                }
                hasMarkVariantComponent() {
                    return this.hasComponent(i.EntityMarkVariantComponent.componentId)
                }
                getMarkVariantComponent() {
                    return this.getComponent(i.EntityMarkVariantComponent.componentId)
                }
                getMarkVariant() {
                    var t, e;
                    return null !== (e = null === (t = this.getMarkVariantComponent()) || void 0 === t ? void 0 : t.value) && void 0 !== e ? e : 0
                }
                hasIsBabyComponent() {
                    return this.hasComponent(i.EntityIsBabyComponent.componentId)
                }
                hasIsChargedComponent() {
                    return this.hasComponent(i.EntityIsChargedComponent.componentId)
                }
            }
            h.propertyNameCache = "exCache"
        },
        522: (t, e, n) => {
            n.d(e, {
                Z: () => i
            });
            class i {
                constructor(t) {
                    this._entity = t, this.bagComponent = t.getInventoryComponent()
                }
                getItem(t) {
                    if ("number" == typeof t) return this.bagComponent.container.getItem(t);
                    let e = this.searchItem(t);
                    return -1 !== e ? this.bagComponent.container.getItem(e) : void 0
                }
                searchItem(t) {
                    let e = this.getAllItems();
                    for (let n = 0; n < e.length; n++)
                        if (void 0 !== e[n] && e[n].typeId === t) return n;
                    return -1
                }
                getAllItems() {
                    let t = [];
                    for (let e = 0; e < this.size(); e++) t.push(this.bagComponent.container.getItem(e));
                    return t
                }
                countAllItems() {
                    var t;
                    let e = new Map;
                    for (let n = 0; n < this.size(); n++) {
                        let i = this.getItem(n);
                        i && e.set(i.typeId, i.amount + (null !== (t = e.get(i.typeId)) && void 0 !== t ? t : 0))
                    }
                    return e
                }
                clearItem(t, e) {
                    for (let n = 0; n < this.size(); n++) {
                        let i = this.getItem(n);
                        if ((null == i ? void 0 : i.typeId) === t) {
                            let t = e - i.amount;
                            if (!(t > 0)) {
                                i.amount -= e, this.setItem(n, i);
                                break
                            }
                            this.setItem(n, void 0), e = t
                        }
                    }
                }
                size() {
                    return this.bagComponent.inventorySize
                }
                type() {
                    return this.bagComponent.containerType
                }
                isPrivate() {
                    return this.bagComponent.private
                }
                isRestrictToOwner() {
                    return this.bagComponent.restrictToOwner
                }
                setItem(t, e) {
                    return this.bagComponent.container.setItem(t, e)
                }
                hasItem(t) {
                    return -1 !== this.searchItem(t)
                }
            }
        },
        344: (t, e, n) => {
            n.d(e, {
                Z: () => a
            });
            var i = n(205),
                s = n(418),
                r = n(960);
            class a {
                constructor(t) {
                    this.command = new r.Z(this), this.nameTag = t
                }
                runCommandAsync(t) {
                    return i.world.getDimension(i.MinecraftDimensionTypes.overworld).runCommandAsync(t)
                }
                getScoresManager() {
                    return new s.Z(this)
                }
            }
        },
        782: (t, e, n) => {
            n.d(e, {
                Z: () => u
            });
            var i = n(205),
                s = n(703),
                r = n(409),
                a = n(522);
            class o extends a.Z {
                constructor(t) {
                    super(t), this._player = t, this.bagComponent = t.getInventoryComponent()
                }
                getItemOnHand() {
                    return this.getItem(this._player.selectedSlot)
                }
                setItemOnHand(t) {
                    return this.setItem(this._player.selectedSlot, t)
                }
            }
            class u extends s.Z {
                constructor(t) {
                    super(t), this.bag = new o(this), this.scoresManager = super.getScoresManager()
                }
                get entity() {
                    return super.entity
                }
                set entity(t) {
                    super.entity = t
                }
                setGameMode(t) {
                    switch (t) {
                        case i.GameMode.survival:
                            this.runCommandAsync("gamemode 0");
                            break;
                        case i.GameMode.creative:
                            this.runCommandAsync("gamemode 1");
                            break;
                        case i.GameMode.adventure:
                            this.runCommandAsync("gamemode 2");
                            break;
                        case i.GameMode.spectator:
                            this.runCommandAsync("gamemode 3")
                    }
                }
                getGameMode() {
                    var t, e, n, s;
                    let a = i.GameMode.creative;
                    return a = (null === (t = Array.from(this.getDimension().getPlayers({
                        location: r.Z.getLocation(this.entity.location),
                        closest: 1,
                        maxDistance: 1,
                        gameMode: i.GameMode.adventure
                    }))) || void 0 === t ? void 0 : t[0]) === this.entity ? i.GameMode.adventure : a, a = (null === (e = Array.from(this.getDimension().getPlayers({
                        location: r.Z.getLocation(this.entity.location),
                        closest: 1,
                        maxDistance: 1,
                        gameMode: i.GameMode.creative
                    }))) || void 0 === e ? void 0 : e[0]) === this.entity ? i.GameMode.creative : a, a = (null === (n = Array.from(this.getDimension().getPlayers({
                        location: r.Z.getLocation(this.entity.location),
                        closest: 1,
                        maxDistance: 1,
                        gameMode: i.GameMode.spectator
                    }))) || void 0 === n ? void 0 : n[0]) === this.entity ? i.GameMode.spectator : a, a = (null === (s = Array.from(this.getDimension().getPlayers({
                        location: r.Z.getLocation(this.entity.location),
                        closest: 1,
                        maxDistance: 1,
                        gameMode: i.GameMode.survival
                    }))) || void 0 === s ? void 0 : s[0]) === this.entity ? i.GameMode.survival : a, a
                }
                title(t, e) {
                    this.entity.onScreenDisplay.setTitle(t), e && this.entity.onScreenDisplay.updateSubtitle(e)
                }
                titleActionBar(t) {
                    this.entity.onScreenDisplay.setActionBar(t)
                }
                get selectedSlot() {
                    return this.entity.selectedSlot
                }
                set selectedSlot(t) {
                    this.entity.selectedSlot = t
                }
                getBag() {
                    return this.bag
                }
                static getInstance(t) {
                    let e = t;
                    return this.propertyNameCache in e ? e[this.propertyNameCache] : e[this.propertyNameCache] = new u(e)
                }
                getScoresManager() {
                    return this.scoresManager
                }
            }
        },
        418: (t, e, n) => {
            n.d(e, {
                C: () => o,
                Z: () => a
            });
            var i = n(205),
                s = n(344),
                r = n(801);
            class a {
                constructor(t) {
                    this.entity = t
                }
                getScore(t) {
                    var e, n, r, a, o, u;
                    let h = "string" == typeof t ? t : t.name;
                    if (this.entity instanceof s.Z) {
                        const t = this.entity;
                        return null !== (n = null === (e = i.world.scoreboard.getObjective(h).getScores().find((e => e.participant.displayName === t.nameTag))) || void 0 === e ? void 0 : e.score) && void 0 !== n ? n : 0
                    }
                    try {
                        return null !== (a = null === (r = i.world.scoreboard.getObjective(h)) || void 0 === r ? void 0 : r.getScore(this.entity.scoreboard)) && void 0 !== a ? a : 0
                    } catch (t) {
                        const e = this.entity;
                        return null !== (u = null === (o = i.world.scoreboard.getObjective(h).getScores().find((t => t.participant === e.scoreboard))) || void 0 === o ? void 0 : o.score) && void 0 !== u ? u : 0
                    }
                }
                setScoreAsync(t, e) {
                    let n = "string" == typeof t ? t : t.name;
                    this.entity.runCommandAsync(`scoreboard players set ${this.entity instanceof s.Z?'"'+this.entity.nameTag+'"':"@s"} ${n} ${e}`)
                }
                addScoreAsync(t, e) {
                    let n = "string" == typeof t ? t : t.name;
                    this.entity.runCommandAsync(`scoreboard players add ${this.entity instanceof s.Z?'"'+this.entity.nameTag+'"':"@s"} ${n} ${e}`)
                }
                removeScoreAsync(t, e) {
                    let n = "string" == typeof t ? t : t.name;
                    this.entity.runCommandAsync(`scoreboard players remove ${this.entity instanceof s.Z?'"'+this.entity.nameTag+'"':"@s"} ${n} ${e}`)
                }
                deleteScoreAsync(t) {
                    let e = "string" == typeof t ? t : t.name;
                    this.entity.runCommandAsync(`scoreboard players reset ${this.entity instanceof s.Z?'"'+this.entity.nameTag+'"':"@s"} ${e}`)
                }
            }
            class o {
                constructor(t) {
                    this.name = t
                }
                create(t) {
                    try {
                        i.world.scoreboard.addObjective(this.name, t)
                    } catch (t) {}
                    return this
                }
                delete() {
                    r.Z.runCommandAsync(`scoreboard objectives remove ${this.name}`)
                }
                setDisplay(t = "sidebar", e = !0) {
                    return "sidebar" == t ? r.Z.runCommandAsync(`scoreboard objectives setdisplay ${t} ${this.name} ${e?"ascending":"descending"}`) : r.Z.runCommandAsync(`scoreboard objectives setdisplay ${t} ${this.name}`), this
                }
            }
        },
        960: (t, e, n) => {
            n.d(e, {
                Z: () => u
            });
            var i = n(703),
                s = n(38),
                r = n(242),
                a = n(484);
            class o {
                constructor() {
                    this.queue = []
                }
                push(t) {
                    this.queue.push(t)
                }
                shift() {
                    return this.queue.shift()
                }
                get length() {
                    return this.queue.length
                }
            }
            class u {
                constructor(t) {
                    this.runner = t
                }
                run(t, ...e) {
                    if ("string" == typeof t) return new Promise(((n, i) => {
                        u.queue.push([this.runner, t, e, n, i])
                    })); {
                        let n = [];
                        for (let n of t) this.run(n, ...e);
                        return n
                    }
                }
                static init(t) {
                    this.queue = new o, this.delay = new a.Z(t.getEvents(), (() => {
                        let t = 0;
                        for (; u.queue.length > 0 && t < 100;) {
                            const e = u.queue.shift();
                            t++, void 0 !== e && u.run(e[0], e[1], ...e[2]).then((t => {
                                e[3](t)
                            })).catch((t => {
                                e[4](t)
                            }))
                        }
                    })).delay(1), this.delay.start()
                }
                static run(t, e, ...n) {
                    return a = this, o = void 0, h = function*() {
                        const a = [];
                        let o = yield t.runCommandAsync(0 === n.length ? e : (0, s.Z)(e, n.map((t => {
                            let e = r.Z.randomUUID();
                            return t instanceof i.Z && (t = t.entity), t.addTag(e), a.push([t, e]), `@e[tag="${e}"]`
                        }))));
                        for (let t of a) t[0].removeTag(t[1]);
                        return o
                    }, new((u = void 0) || (u = Promise))((function(t, e) {
                        function n(t) {
                            try {
                                s(h.next(t))
                            } catch (t) {
                                e(t)
                            }
                        }

                        function i(t) {
                            try {
                                s(h.throw(t))
                            } catch (t) {
                                e(t)
                            }
                        }

                        function s(e) {
                            e.done ? t(e.value) : function(t) {
                                return t instanceof u ? t : new u((function(e) {
                                    e(t)
                                }))
                            }(e.value).then(n, i)
                        }
                        s((h = h.apply(a, o || [])).next())
                    }));
                    var a, o, u, h
                }
            }
        },
        710: (t, e, n) => {
            n.d(e, {
                Z: () => i
            });
            class i {
                constructor() {
                    this.monitorMap = {}, this.registerToServerByEntity = (t, e) => {
                        this.server.getEvents().register(t, (t => {
                            var n;
                            const i = null === (n = this.listeners[e].filter) || void 0 === n ? void 0 : n.name;
                            if (i) {
                                let n = t[i],
                                    s = this.monitorMap[e].get(n);
                                s && s.forEach((e => {
                                    e(t)
                                }))
                            }
                        }))
                    }, this.registerToServerByServerEvent = (t, e) => {
                        this.server.getEvents().register(t, (t => {
                            for (let [n, i] of this.monitorMap[e]) i.forEach((e => {
                                e(t)
                            }))
                        }))
                    }
                }
                setEventLiseners(t) {
                    this.listeners = t
                }
                init(t) {
                    this.server = t;
                    for (let t in this.listeners) this.monitorMap[t] = new Map;
                    for (let t in this.monitorMap) {
                        let e = this.listeners[t],
                            n = t;
                        e.name && (n = e.name), e.pattern(n, t)
                    }
                }
                subscribe(t, e, n) {
                    var i;
                    let s = this.monitorMap[e];
                    s.has(t) || s.set(t, []), null === (i = s.get(t)) || void 0 === i || i.push(n)
                }
                unsubscribe(t, e, n) {
                    let i = this.monitorMap[e].get(t);
                    if (i) {
                        let t = i.indexOf(n); - 1 !== t && i.splice(t, 1)
                    }
                }
                unsubscribeAll(t) {
                    for (let e in this.monitorMap) this.monitorMap[e].delete(t)
                }
            }
        },
        654: (t, e, n) => {
            n.d(e, {
                Z: () => h
            });
            var i, s = n(205),
                r = n(782),
                a = n(513),
                o = n(484),
                u = n(710);
            class h {
                constructor(t) {
                    this.exEvents = {
                        itemUse: new l(this, "itemUse"),
                        chat: new l(this, "chat"),
                        beforeChat: new l(this, "beforeChat"),
                        tick: new l(this, "tick"),
                        entityHit: new l(this, "entityHit"),
                        itemUseOn: new l(this, "itemUseOn"),
                        beforeItemUseOn: new l(this, "beforeItemUseOn"),
                        onceItemUseOn: new l(this, "onceItemUseOn"),
                        playerHitEntity: new l(this, "playerHitEntity"),
                        playerHurt: new l(this, "playerHurt"),
                        itemOnHandChange: new l(this, "itemOnHandChange"),
                        onLongTick: new l(this, "onLongTick"),
                        blockBreak: new l(this, "blockBreak")
                    }, this._client = t
                }
                _subscribe(t, e) {
                    h.eventHandlers.subscribe(this._client.player, t, e)
                }
                _unsubscribe(t, e) {
                    h.eventHandlers.unsubscribe(this._client.player, t, e)
                }
                cancelAll() {
                    h.eventHandlers.unsubscribeAll(this._client.player)
                }
                static init(t) {
                    this.eventHandlers.setEventLiseners(this.exEventSetting), this.eventHandlers.init(t)
                }
                register(t, e) {
                    let n = e;
                    if (t in this.exEvents) return this.exEvents[t].subscribe(n);
                    console.warn("No event registered for name " + t)
                }
                cancel(t, e) {
                    if (t in this.exEvents) return this.exEvents[t].unsubscribe(e)
                }
            }
            i = h, h.eventHandlers = new u.Z, h.exEventSetting = {
                itemUse: {
                    pattern: h.eventHandlers.registerToServerByEntity,
                    filter: {
                        name: "source"
                    }
                },
                chat: {
                    pattern: h.eventHandlers.registerToServerByEntity,
                    filter: {
                        name: "sender"
                    }
                },
                beforeChat: {
                    pattern: h.eventHandlers.registerToServerByEntity,
                    filter: {
                        name: "sender"
                    }
                },
                tick: {
                    pattern: h.eventHandlers.registerToServerByServerEvent
                },
                entityHit: {
                    pattern: h.eventHandlers.registerToServerByEntity,
                    filter: {
                        name: "entity"
                    }
                },
                itemUseOn: {
                    pattern: h.eventHandlers.registerToServerByEntity,
                    filter: {
                        name: "source"
                    }
                },
                beforeItemUseOn: {
                    pattern: h.eventHandlers.registerToServerByEntity,
                    filter: {
                        name: "source"
                    }
                },
                onceItemUseOn: {
                    pattern: (t, e) => {
                        i.onceItemUseOnMap = new Map, h.eventHandlers.server.getEvents().register(t, (t => {
                            var n;
                            if (!(t.source instanceof s.Player)) return;
                            let r = h.eventHandlers.monitorMap[e];
                            if (!i.onceItemUseOnMap.has(t.source)) {
                                const e = t.source;
                                i.onceItemUseOnMap.set(t.source, [new o.Z(h.eventHandlers.server.getEvents(), (() => {
                                    let t = i.onceItemUseOnMap.get(e);
                                    void 0 !== t && (t[1] = !0)
                                })).delay(3), !0])
                            }
                            let a = i.onceItemUseOnMap.get(t.source);
                            void 0 !== a && (a[1] && (a[1] = !1, null === (n = r.get(t.source)) || void 0 === n || n.forEach((e => e(t)))), a[0].stop(), a[0].startOnce())
                        }))
                    },
                    filter: {
                        name: "source"
                    },
                    name: "beforeItemUseOn"
                },
                playerHitEntity: {
                    pattern: h.eventHandlers.registerToServerByEntity,
                    filter: {
                        name: "damageSource.damagingEntity"
                    },
                    name: "entityHurt"
                },
                playerHurt: {
                    pattern: h.eventHandlers.registerToServerByEntity,
                    filter: {
                        name: "hurtEntity"
                    },
                    name: "entityHurt"
                },
                itemOnHandChange: {
                    pattern: (t, e) => {
                        i.onHandItemMap = new Map, h.eventHandlers.server.getEvents().register(t, (t => {
                            for (let t of h.eventHandlers.monitorMap[e]) {
                                let e = i.onHandItemMap.get(t[0]),
                                    n = null == e ? void 0 : e[0],
                                    s = r.Z.getInstance(t[0]).getBag().getItemOnHand();
                                (null == n ? void 0 : n.typeId) === (null == s ? void 0 : s.typeId) && t[0].selectedSlot === (null == e ? void 0 : e[1]) || (t[1].forEach((e => {
                                    e(new a.a(n, r.Z.getInstance(t[0]).getBag().getItemOnHand(), t[0]))
                                })), i.onHandItemMap.set(t[0], [s, t[0].selectedSlot]))
                            }
                        }))
                    },
                    name: "onLongTick"
                },
                onLongTick: {
                    pattern: h.eventHandlers.registerToServerByServerEvent
                },
                blockBreak: {
                    pattern: h.eventHandlers.registerToServerByEntity,
                    filter: {
                        name: "player"
                    }
                }
            }, h.onHandItemMap = new Map, h.onceItemUseOnMap = new Map;
            class l {
                constructor(t, e) {
                    this.subscribe = n => {
                        t._subscribe(e, n)
                    }, this.unsubscribe = n => {
                        t._unsubscribe(e, n)
                    }
                }
            }
        },
        478: (t, e, n) => {
            n.d(e, {
                B: () => s,
                K: () => r
            });
            var i = n(516);

            function s(t, e) {
                for (let n of i.Z.keys(e)) {
                    const i = Reflect.getMetadata("eventName", e, n);
                    if (i) {
                        const s = Reflect.getMetadata("eventCondition", e, n);
                        s ? t.register(i, (t => {
                            s(e, t) && e[n].call(e, t)
                        })) : t.register(i, e[n].bind(e))
                    }
                }
            }

            function r(t, e) {
                return function(n, i, s) {
                    Reflect.defineMetadata("eventName", t, n, i), Reflect.defineMetadata("eventCondition", e, n, i)
                }
            }
        },
        513: (t, e, n) => {
            n.d(e, {
                a: () => i
            });
            class i {
                constructor(t, e, n) {
                    this.beforeItem = t, this.afterItem = e, this.source = n
                }
            }
        },
        409: (t, e, n) => {
            n.d(e, {
                Z: () => s
            });
            var i = n(205);
            class s {
                static getVector(t) {
                    return this._tempVector ? (this._tempVector.x = t.x, this._tempVector.y = t.y, this._tempVector.z = t.z, this._tempVector) : this._tempVector = new i.Vector(t.x, t.y, t.z)
                }
                static getLocation(t) {
                    return this._tempLocation ? (this._tempLocation.x = t.x, this._tempLocation.y = t.y, this._tempLocation.z = t.z, this._tempLocation) : this._tempLocation = new i.Location(t.x, t.y, t.z)
                }
                static getBlockLocation(t) {
                    return this._tempBlockLocation ? (this._tempBlockLocation.x = t.x, this._tempBlockLocation.y = t.y, this._tempBlockLocation.z = t.z, this._tempBlockLocation) : this._tempBlockLocation = new i.BlockLocation(t.x, t.y, t.z)
                }
            }
        },
        217: (t, e, n) => {
            n.d(e, {
                Z: () => r
            });
            var i = n(985),
                s = n(361);
            class r {
                constructor() {
                    this._alert = new i.ActionFormData, this.buttonEvent = []
                }
                body(t) {
                    return this._alert.body(t), this
                }
                button(t, e, n) {
                    return this._alert.button(t, n), this.buttonEvent.push(e), this
                }
                show(t) {
                    return this._alert.show(t).then((t => {
                        t.canceled || void 0 === t.selection || this.buttonEvent[t.selection]()
                    })).catch((t => s.Z.throwError(t))), this
                }
                title(t) {
                    return this._alert.title(t), this
                }
            }
        },
        516: (t, e, n) => {
            n.d(e, {
                Z: () => s
            });
            var i = n(647);
            class s {
                static getId(t) {
                    return this.idMap.has(t) || this.idMap.set(t, Math.floor(Math.random() * i.Z.MAX_VALUE)), this.idMap.get(t)
                }
                static hasChineseCharacter(t) {
                    return this.chineseCharMatcher.test(t)
                }
                static keys(t) {
                    const e = Reflect.ownKeys(t);
                    let n = t.__proto__;
                    for (; n;) {
                        for (let t of Reflect.ownKeys(n)) e.push(t);
                        n = n.__proto__
                    }
                    return e
                }
                static parseObj(t) {
                    let e = s.keys(t),
                        n = "{\n";
                    for (const i of e) {
                        const e = t[i];
                        null === e && (n += `${String(i)}: null\n`), n += "object" != typeof e ? `${String(i)}: ${e}\n` : `${String(i)}: {...}\n`
                    }
                    return n + "}"
                }
            }
            s.idMap = new Map, s.chineseCharMatcher = /([\u4E00-\u9FA5])+/
        },
        647: (t, e, n) => {
            n.d(e, {
                Z: () => i
            });
            class i {
                constructor(t) {
                    this.seed = (t || Date.now()) % 999999999
                }
                next() {
                    return this.seed = (9301 * this.seed + 49297) % 233280, this.seed / 233280
                }
                nextDouble() {
                    return this.next()
                }
                nextLong() {
                    return Math.floor(this.nextDouble() * i.MAX_VALUE)
                }
                nextInt(t = i.MAX_VALUE) {
                    return Math.floor(this.nextDouble() * t)
                }
                nextBoolean() {
                    return this.nextDouble() >= .5
                }
                static choice(t) {
                    if (t instanceof Array) {
                        if (0 === t.length) throw new Error("array mustnot be empty");
                        return t[Math.floor(Math.random() * t.length)]
                    } {
                        let e = [];
                        for (let n in t) e.push(n);
                        return t[i.choice(e)]
                    }
                }
            }
            i.MAX_VALUE = ~(1 << 31), i.MIN_VALUE = 1 << 31
        },
        484: (t, e, n) => {
            n.d(e, {
                Z: () => i
            });
            class i {
                constructor(t, e) {
                    this.time = 20, this.timeOut = t, this.looper = e
                }
                getDelay() {
                    return this.time
                }
                delay(t) {
                    return this.time = t, this
                }
                isStarted() {
                    return void 0 !== this.func
                }
                startOnce() {
                    let t = 0;
                    this.isStarted() || (this.func = e => {
                        t += 1, t >= this.time && (this.stop(), this.looper())
                    }, this.timeOut.register("tick", this.func))
                }
                start() {
                    let t = 0;
                    this.isStarted() || (this.func = e => {
                        t += 1, t >= this.time && (this.looper(), t = 0)
                    }, this.timeOut.register("tick", this.func))
                }
                stop() {
                    this.func && (this.timeOut.cancel("tick", this.func), this.func = void 0)
                }
            }
        },
        242: (t, e, n) => {
            n.d(e, {
                Z: () => i
            });
            class i {
                static randomUUID() {
                    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (function(t) {
                        var e = 16 * Math.random() | 0;
                        return ("x" == t ? e : 3 & e | 8).toString(16)
                    }))
                }
            }
        },
        342: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            function encodeUnicode(t) {
                let e = [];
                for (var n = 0; n < t.length; n++) e[n] = ("00" + t.charCodeAt(n).toString(16)).slice(-4);
                return "\\u" + e.join("\\u")
            }

            function decodeUnicode(str) {
                return eval('{"' + str + '"}')
            }
            __webpack_require__.d(__webpack_exports__, {
                L: () => decodeUnicode
            })
        },
        38: (t, e, n) => {
            function i(t, ...e) {
                var n = t;
                for (let t in e) n = n.replace("{" + t + "}", e[t] + "");
                return n
            }
            n.d(e, {
                Z: () => i
            })
        },
        437: () => {
            Array.prototype.clear = function() {
                this.splice(0, this.length)
            }
        },
        632: (t, e, n) => {
            n.d(e, {
                Z: () => s
            });
            var i = n(361);

            function s(t, e, n, s = 1e3, r = 60) {
                let a = () => {
                    return o = this, u = void 0, l = function*() {
                        try {
                            let i = e();
                            i instanceof Promise && (i = yield i), i ? n() : r > 0 && (r--, t.setTimeout(a, s))
                        } catch (t) {
                            i.Z.throwError(t)
                        }
                    }, new((h = void 0) || (h = Promise))((function(t, e) {
                        function n(t) {
                            try {
                                s(l.next(t))
                            } catch (t) {
                                e(t)
                            }
                        }

                        function i(t) {
                            try {
                                s(l.throw(t))
                            } catch (t) {
                                e(t)
                            }
                        }

                        function s(e) {
                            e.done ? t(e.value) : function(t) {
                                return t instanceof h ? t : new h((function(e) {
                                    e(t)
                                }))
                            }(e.value).then(n, i)
                        }
                        s((l = l.apply(o, u || [])).next())
                    }));
                    var o, u, h, l
                };
                t.setTimeout(a, 100)
            }
        },
        855: (t, e, n) => {
            var i;
            ! function(t) {
                ! function(e) {
                    var i = "object" == typeof n.g ? n.g : "object" == typeof self ? self : "object" == typeof this ? this : Function("return this;")(),
                        s = r(t);

                    function r(t, e) {
                        return function(n, i) {
                            "function" != typeof t[n] && Object.defineProperty(t, n, {
                                configurable: !0,
                                writable: !0,
                                value: i
                            }), e && e(n, i)
                        }
                    }
                    void 0 === i.Reflect ? i.Reflect = t : s = r(i.Reflect, s),
                        function(t) {
                            var e = Object.prototype.hasOwnProperty,
                                n = "function" == typeof Symbol,
                                i = n && void 0 !== Symbol.toPrimitive ? Symbol.toPrimitive : "@@toPrimitive",
                                s = n && void 0 !== Symbol.iterator ? Symbol.iterator : "@@iterator",
                                r = "function" == typeof Object.create,
                                a = {
                                    __proto__: []
                                }
                            instanceof Array, o = !r && !a, u = {
                                create: r ? function() {
                                    return N(Object.create(null))
                                } : a ? function() {
                                    return N({
                                        __proto__: null
                                    })
                                } : function() {
                                    return N({})
                                },
                                has: o ? function(t, n) {
                                    return e.call(t, n)
                                } : function(t, e) {
                                    return e in t
                                },
                                get: o ? function(t, n) {
                                    return e.call(t, n) ? t[n] : void 0
                                } : function(t, e) {
                                    return t[e]
                                }
                            }, h = Object.getPrototypeOf(Function), l = "object" == typeof process && process.env && "true" === process.env.REFLECT_METADATA_USE_MAP_POLYFILL, c = l || "function" != typeof Map || "function" != typeof Map.prototype.entries ? function() {
                                var t = {},
                                    e = [],
                                    n = function() {
                                        function t(t, e, n) {
                                            this._index = 0, this._keys = t, this._values = e, this._selector = n
                                        }
                                        return t.prototype["@@iterator"] = function() {
                                            return this
                                        }, t.prototype[s] = function() {
                                            return this
                                        }, t.prototype.next = function() {
                                            var t = this._index;
                                            if (t >= 0 && t < this._keys.length) {
                                                var n = this._selector(this._keys[t], this._values[t]);
                                                return t + 1 >= this._keys.length ? (this._index = -1, this._keys = e, this._values = e) : this._index++, {
                                                    value: n,
                                                    done: !1
                                                }
                                            }
                                            return {
                                                value: void 0,
                                                done: !0
                                            }
                                        }, t.prototype.throw = function(t) {
                                            throw this._index >= 0 && (this._index = -1, this._keys = e, this._values = e), t
                                        }, t.prototype.return = function(t) {
                                            return this._index >= 0 && (this._index = -1, this._keys = e, this._values = e), {
                                                value: t,
                                                done: !0
                                            }
                                        }, t
                                    }();
                                return function() {
                                    function e() {
                                        this._keys = [], this._values = [], this._cacheKey = t, this._cacheIndex = -2
                                    }
                                    return Object.defineProperty(e.prototype, "size", {
                                        get: function() {
                                            return this._keys.length
                                        },
                                        enumerable: !0,
                                        configurable: !0
                                    }), e.prototype.has = function(t) {
                                        return this._find(t, !1) >= 0
                                    }, e.prototype.get = function(t) {
                                        var e = this._find(t, !1);
                                        return e >= 0 ? this._values[e] : void 0
                                    }, e.prototype.set = function(t, e) {
                                        var n = this._find(t, !0);
                                        return this._values[n] = e, this
                                    }, e.prototype.delete = function(e) {
                                        var n = this._find(e, !1);
                                        if (n >= 0) {
                                            for (var i = this._keys.length, s = n + 1; s < i; s++) this._keys[s - 1] = this._keys[s], this._values[s - 1] = this._values[s];
                                            return this._keys.length--, this._values.length--, e === this._cacheKey && (this._cacheKey = t, this._cacheIndex = -2), !0
                                        }
                                        return !1
                                    }, e.prototype.clear = function() {
                                        this._keys.length = 0, this._values.length = 0, this._cacheKey = t, this._cacheIndex = -2
                                    }, e.prototype.keys = function() {
                                        return new n(this._keys, this._values, i)
                                    }, e.prototype.values = function() {
                                        return new n(this._keys, this._values, r)
                                    }, e.prototype.entries = function() {
                                        return new n(this._keys, this._values, a)
                                    }, e.prototype["@@iterator"] = function() {
                                        return this.entries()
                                    }, e.prototype[s] = function() {
                                        return this.entries()
                                    }, e.prototype._find = function(t, e) {
                                        return this._cacheKey !== t && (this._cacheIndex = this._keys.indexOf(this._cacheKey = t)), this._cacheIndex < 0 && e && (this._cacheIndex = this._keys.length, this._keys.push(t), this._values.push(void 0)), this._cacheIndex
                                    }, e
                                }();

                                function i(t, e) {
                                    return t
                                }

                                function r(t, e) {
                                    return e
                                }

                                function a(t, e) {
                                    return [t, e]
                                }
                            }() : Map, p = l || "function" != typeof Set || "function" != typeof Set.prototype.entries ? function() {
                                function t() {
                                    this._map = new c
                                }
                                return Object.defineProperty(t.prototype, "size", {
                                    get: function() {
                                        return this._map.size
                                    },
                                    enumerable: !0,
                                    configurable: !0
                                }), t.prototype.has = function(t) {
                                    return this._map.has(t)
                                }, t.prototype.add = function(t) {
                                    return this._map.set(t, t), this
                                }, t.prototype.delete = function(t) {
                                    return this._map.delete(t)
                                }, t.prototype.clear = function() {
                                    this._map.clear()
                                }, t.prototype.keys = function() {
                                    return this._map.keys()
                                }, t.prototype.values = function() {
                                    return this._map.values()
                                }, t.prototype.entries = function() {
                                    return this._map.entries()
                                }, t.prototype["@@iterator"] = function() {
                                    return this.keys()
                                }, t.prototype[s] = function() {
                                    return this.keys()
                                }, t
                            }() : Set, d = new(l || "function" != typeof WeakMap ? function() {
                                var t = u.create(),
                                    n = i();
                                return function() {
                                    function t() {
                                        this._key = i()
                                    }
                                    return t.prototype.has = function(t) {
                                        var e = s(t, !1);
                                        return void 0 !== e && u.has(e, this._key)
                                    }, t.prototype.get = function(t) {
                                        var e = s(t, !1);
                                        return void 0 !== e ? u.get(e, this._key) : void 0
                                    }, t.prototype.set = function(t, e) {
                                        return s(t, !0)[this._key] = e, this
                                    }, t.prototype.delete = function(t) {
                                        var e = s(t, !1);
                                        return void 0 !== e && delete e[this._key]
                                    }, t.prototype.clear = function() {
                                        this._key = i()
                                    }, t
                                }();

                                function i() {
                                    var e;
                                    do {
                                        e = "@@WeakMap@@" + a()
                                    } while (u.has(t, e));
                                    return t[e] = !0, e
                                }

                                function s(t, i) {
                                    if (!e.call(t, n)) {
                                        if (!i) return;
                                        Object.defineProperty(t, n, {
                                            value: u.create()
                                        })
                                    }
                                    return t[n]
                                }

                                function r(t, e) {
                                    for (var n = 0; n < e; ++n) t[n] = 255 * Math.random() | 0;
                                    return t
                                }

                                function a() {
                                    var t, e = (t = 16, "function" == typeof Uint8Array ? "undefined" != typeof crypto ? crypto.getRandomValues(new Uint8Array(t)) : "undefined" != typeof msCrypto ? msCrypto.getRandomValues(new Uint8Array(t)) : r(new Uint8Array(t), t) : r(new Array(t), t));
                                    e[6] = 79 & e[6] | 64, e[8] = 191 & e[8] | 128;
                                    for (var n = "", i = 0; i < 16; ++i) {
                                        var s = e[i];
                                        4 !== i && 6 !== i && 8 !== i || (n += "-"), s < 16 && (n += "0"), n += s.toString(16).toLowerCase()
                                    }
                                    return n
                                }
                            }() : WeakMap);

                            function m(t, e, n) {
                                var i = d.get(t);
                                if (v(i)) {
                                    if (!n) return;
                                    i = new c, d.set(t, i)
                                }
                                var s = i.get(e);
                                if (v(s)) {
                                    if (!n) return;
                                    s = new c, i.set(e, s)
                                }
                                return s
                            }

                            function g(t, e, n) {
                                if (f(t, e, n)) return !0;
                                var i = R(e);
                                return !E(i) && g(t, i, n)
                            }

                            function f(t, e, n) {
                                var i = m(e, n, !1);
                                return !v(i) && !!i.has(t)
                            }

                            function y(t, e, n) {
                                if (f(t, e, n)) return x(t, e, n);
                                var i = R(e);
                                return E(i) ? void 0 : y(t, i, n)
                            }

                            function x(t, e, n) {
                                var i = m(e, n, !1);
                                if (!v(i)) return i.get(t)
                            }

                            function _(t, e, n, i) {
                                m(n, i, !0).set(t, e)
                            }

                            function b(t, e) {
                                var n = w(t, e),
                                    i = R(t);
                                if (null === i) return n;
                                var s = b(i, e);
                                if (s.length <= 0) return n;
                                if (n.length <= 0) return s;
                                for (var r = new p, a = [], o = 0, u = n; o < u.length; o++) {
                                    var h = u[o];
                                    r.has(h) || (r.add(h), a.push(h))
                                }
                                for (var l = 0, c = s; l < c.length; l++) h = c[l], r.has(h) || (r.add(h), a.push(h));
                                return a
                            }

                            function w(t, e) {
                                var n = [],
                                    i = m(t, e, !1);
                                if (v(i)) return n;
                                for (var r = function(t) {
                                        var e = C(t, s);
                                        if (!D(e)) throw new TypeError;
                                        var n = e.call(t);
                                        if (!A(n)) throw new TypeError;
                                        return n
                                    }(i.keys()), a = 0;;) {
                                    var o = M(r);
                                    if (!o) return n.length = a, n;
                                    var u = o.value;
                                    try {
                                        n[a] = u
                                    } catch (t) {
                                        try {
                                            O(r)
                                        } finally {
                                            throw t
                                        }
                                    }
                                    a++
                                }
                            }

                            function T(t) {
                                if (null === t) return 1;
                                switch (typeof t) {
                                    case "undefined":
                                        return 0;
                                    case "boolean":
                                        return 2;
                                    case "string":
                                        return 3;
                                    case "symbol":
                                        return 4;
                                    case "number":
                                        return 5;
                                    case "object":
                                        return null === t ? 1 : 6;
                                    default:
                                        return 6
                                }
                            }

                            function v(t) {
                                return void 0 === t
                            }

                            function E(t) {
                                return null === t
                            }

                            function A(t) {
                                return "object" == typeof t ? null !== t : "function" == typeof t
                            }

                            function I(t, e) {
                                switch (T(t)) {
                                    case 0:
                                    case 1:
                                    case 2:
                                    case 3:
                                    case 4:
                                    case 5:
                                        return t
                                }
                                var n = 3 === e ? "string" : 5 === e ? "number" : "default",
                                    s = C(t, i);
                                if (void 0 !== s) {
                                    var r = s.call(t, n);
                                    if (A(r)) throw new TypeError;
                                    return r
                                }
                                return function(t, e) {
                                    if ("string" === e) {
                                        var n = t.toString;
                                        if (D(n) && !A(s = n.call(t))) return s;
                                        if (D(i = t.valueOf) && !A(s = i.call(t))) return s
                                    } else {
                                        var i;
                                        if (D(i = t.valueOf) && !A(s = i.call(t))) return s;
                                        var s, r = t.toString;
                                        if (D(r) && !A(s = r.call(t))) return s
                                    }
                                    throw new TypeError
                                }(t, "default" === n ? "number" : n)
                            }

                            function S(t) {
                                var e = I(t, 3);
                                return "symbol" == typeof e ? e : function(t) {
                                    return "" + t
                                }(e)
                            }

                            function k(t) {
                                return Array.isArray ? Array.isArray(t) : t instanceof Object ? t instanceof Array : "[object Array]" === Object.prototype.toString.call(t)
                            }

                            function D(t) {
                                return "function" == typeof t
                            }

                            function L(t) {
                                return "function" == typeof t
                            }

                            function C(t, e) {
                                var n = t[e];
                                if (null != n) {
                                    if (!D(n)) throw new TypeError;
                                    return n
                                }
                            }

                            function M(t) {
                                var e = t.next();
                                return !e.done && e
                            }

                            function O(t) {
                                var e = t.return;
                                e && e.call(t)
                            }

                            function R(t) {
                                var e = Object.getPrototypeOf(t);
                                if ("function" != typeof t || t === h) return e;
                                if (e !== h) return e;
                                var n = t.prototype,
                                    i = n && Object.getPrototypeOf(n);
                                if (null == i || i === Object.prototype) return e;
                                var s = i.constructor;
                                return "function" != typeof s || s === t ? e : s
                            }

                            function N(t) {
                                return t.__ = void 0, delete t.__, t
                            }
                            t("decorate", (function(t, e, n, i) {
                                if (v(n)) {
                                    if (!k(t)) throw new TypeError;
                                    if (!L(e)) throw new TypeError;
                                    return function(t, e) {
                                        for (var n = t.length - 1; n >= 0; --n) {
                                            var i = (0, t[n])(e);
                                            if (!v(i) && !E(i)) {
                                                if (!L(i)) throw new TypeError;
                                                e = i
                                            }
                                        }
                                        return e
                                    }(t, e)
                                }
                                if (!k(t)) throw new TypeError;
                                if (!A(e)) throw new TypeError;
                                if (!A(i) && !v(i) && !E(i)) throw new TypeError;
                                return E(i) && (i = void 0),
                                    function(t, e, n, i) {
                                        for (var s = t.length - 1; s >= 0; --s) {
                                            var r = (0, t[s])(e, n, i);
                                            if (!v(r) && !E(r)) {
                                                if (!A(r)) throw new TypeError;
                                                i = r
                                            }
                                        }
                                        return i
                                    }(t, e, n = S(n), i)
                            })), t("metadata", (function(t, e) {
                                return function(n, i) {
                                    if (!A(n)) throw new TypeError;
                                    if (!v(i) && ! function(t) {
                                            switch (T(t)) {
                                                case 3:
                                                case 4:
                                                    return !0;
                                                default:
                                                    return !1
                                            }
                                        }(i)) throw new TypeError;
                                    _(t, e, n, i)
                                }
                            })), t("defineMetadata", (function(t, e, n, i) {
                                if (!A(n)) throw new TypeError;
                                return v(i) || (i = S(i)), _(t, e, n, i)
                            })), t("hasMetadata", (function(t, e, n) {
                                if (!A(e)) throw new TypeError;
                                return v(n) || (n = S(n)), g(t, e, n)
                            })), t("hasOwnMetadata", (function(t, e, n) {
                                if (!A(e)) throw new TypeError;
                                return v(n) || (n = S(n)), f(t, e, n)
                            })), t("getMetadata", (function(t, e, n) {
                                if (!A(e)) throw new TypeError;
                                return v(n) || (n = S(n)), y(t, e, n)
                            })), t("getOwnMetadata", (function(t, e, n) {
                                if (!A(e)) throw new TypeError;
                                return v(n) || (n = S(n)), x(t, e, n)
                            })), t("getMetadataKeys", (function(t, e) {
                                if (!A(t)) throw new TypeError;
                                return v(e) || (e = S(e)), b(t, e)
                            })), t("getOwnMetadataKeys", (function(t, e) {
                                if (!A(t)) throw new TypeError;
                                return v(e) || (e = S(e)), w(t, e)
                            })), t("deleteMetadata", (function(t, e, n) {
                                if (!A(e)) throw new TypeError;
                                v(n) || (n = S(n));
                                var i = m(e, n, !1);
                                if (v(i)) return !1;
                                if (!i.delete(t)) return !1;
                                if (i.size > 0) return !0;
                                var s = d.get(e);
                                return s.delete(n), s.size > 0 || d.delete(e), !0
                            }))
                        }(s)
                }()
            }(i || (i = {}))
        },
        462: function(t, e, n) {
            ! function(t, e) {
                function i(t) {
                    return Math.max(0, t)
                }

                function s(t, e) {
                    return t <= 0 ? 0 : e
                }
                var r = Object.freeze({
                    __proto__: null,
                    activate: i,
                    measure: s
                });

                function a(t) {
                    return 1 / (1 + Math.exp(-t))
                }

                function o(t, e) {
                    return t * (1 - t) * e
                }
                var u = Object.freeze({
                    __proto__: null,
                    activate: a,
                    measure: o
                });

                function h(t) {
                    return Math.tanh(t)
                }

                function l(t, e) {
                    return (1 - t * t) * e
                }
                var c = Object.freeze({
                    __proto__: null,
                    activate: h,
                    measure: l
                });

                function p(t) {
                    return t > 0 ? t : .01 * t
                }

                function d(t, e) {
                    return t > 0 ? e : .01 * e
                }
                var m = Object.freeze({
                        __proto__: null,
                        activate: p,
                        measure: d
                    }),
                    g = Object.freeze({
                        __proto__: null,
                        relu: r,
                        sigmoid: u,
                        tanh: c,
                        leakyRelu: m
                    });
                class f {
                    constructor(t) {
                        this.json = {
                            avgs: {
                                error: 0,
                                iterations: 0,
                                testTime: 0,
                                trainTime: 0
                            },
                            stats: {
                                total: 0,
                                testSize: 0,
                                trainSize: 0
                            },
                            sets: []
                        }, this.initClassifier = t
                    }
                    testPartition(t, e, n) {
                        const i = this.initClassifier(),
                            s = Date.now(),
                            r = i.train(e, t),
                            a = Date.now(),
                            o = i.test(n),
                            u = Date.now();
                        return {
                            ...o,
                            trainTime: a - s,
                            testTime: u - a,
                            iterations: r.iterations,
                            error: r.error,
                            total: o.total,
                            network: i.toJSON()
                        }
                    }
                    shuffleArray(t) {
                        for (let e = t.length - 1; e > 0; e--) {
                            const n = Math.floor(Math.random() * (e + 1)),
                                i = t[e];
                            t[e] = t[n], t[n] = i
                        }
                        return t
                    }
                    train(t, e = {}, n = 4) {
                        if (t.length < n) throw new Error(`Training set size is too small for ${t.length} k folds of ${n}`);
                        this.shuffleArray(t);
                        const i = t.length / n,
                            s = {
                                trainTime: 0,
                                testTime: 0,
                                iterations: 0,
                                error: 0
                            },
                            r = {
                                total: 0,
                                testSize: 0,
                                trainSize: 0
                            },
                            a = {
                                total: 0,
                                testSize: 0,
                                trainSize: 0,
                                truePos: 0,
                                trueNeg: 0,
                                falsePos: 0,
                                falseNeg: 0,
                                precision: 0,
                                recall: 0,
                                accuracy: 0
                            },
                            o = [];
                        let u = null;
                        for (let h = 0; h < n; h++) {
                            const n = t.slice(0),
                                l = n.splice(h * i, i),
                                c = n,
                                p = this.testPartition(e, c, l);
                            null === u && (u = p.hasOwnProperty("falseNeg") && p.hasOwnProperty("falsePos") && p.hasOwnProperty("trueNeg") && p.hasOwnProperty("truePos"), u && Object.assign(r, a)), s.iterations += p.iterations, s.testTime += p.testTime, s.trainTime += p.trainTime, s.error += p.error, r.total += p.total, f.isBinaryStats(r) && f.isBinaryPartitionResults(p) && (r.accuracy += p.accuracy, r.falseNeg += p.falseNeg, r.falsePos += p.falsePos, r.precision += p.precision, r.recall += p.recall, r.trueNeg += p.trueNeg, r.truePos += p.truePos), o.push(p)
                        }
                        return s.error /= n, s.iterations /= n, s.testTime /= n, s.trainTime /= n, f.isBinaryStats(r) && (r.precision = r.truePos / (r.truePos + r.falsePos), r.recall = r.truePos / (r.truePos + r.falseNeg), r.accuracy = (r.trueNeg + r.truePos) / r.total), r.testSize = i, r.trainSize = t.length - i, this.json = {
                            avgs: s,
                            stats: r,
                            sets: o
                        }, this.json
                    }
                    toNeuralNetwork() {
                        return this.fromJSON(this.json)
                    }
                    toJSON() {
                        return this.json
                    }
                    fromJSON(t) {
                        const e = t.sets.reduce(((t, e) => t.error < e.error ? t : e));
                        return this.initClassifier().fromJSON(e.network)
                    }
                }
                f.isBinaryStats = t => void 0 !== t.accuracy, f.isBinaryResults = t => void 0 !== t.stats.accuracy, f.isBinaryPartitionResults = t => void 0 !== t.accuracy;
                let y = null;

                function x(t) {
                    y = t
                }

                function _(t, n) {
                    let i = y;
                    return null === i && (i = new e.GPU({
                        mode: "gpu"
                    }), x(i)), i.createKernel(t, n).setPipeline(!0)
                }

                function b(t, n, i) {
                    let s = y;
                    return null === s && (s = new e.GPU({
                        mode: "gpu"
                    }), x(s)), s.createKernelMap(t, n, i).setPipeline(!0)
                }

                function w(t) {
                    t instanceof e.Texture && t.delete()
                }

                function T(t) {
                    if (t instanceof e.Texture) return t.clone();
                    if (t instanceof Float32Array) return t.slice(0);
                    if (Array.isArray(t)) {
                        if ("number" == typeof t[0]) return t.slice(0);
                        if ("number" == typeof t[0][0]) {
                            const e = new Array(t.length);
                            for (let n = 0; n < t.length; n++) e[n] = t[n].slice(0);
                            return e
                        }
                        if ("number" == typeof t[0][0][0]) {
                            const e = new Array(t.length);
                            for (let e = 0; e < t.length; e++) {
                                const n = t[e],
                                    i = new Array(n.length);
                                for (let t = 0; t < n.length; t++) i[t] = n[t].slice(0)
                            }
                            return e
                        }
                    }
                    throw new Error("unhandled value")
                }

                function v(t) {
                    let e = 0;
                    for (let n = 0; n < this.constants.height; n++)
                        for (let i = 0; i < this.constants.width; i++) e += t[n][i] ** 2;
                    return e / this.constants.length
                }
                class E {
                    constructor({
                        width: t,
                        height: e
                    }) {
                        this.calculate = _(v, {
                            output: [1],
                            constants: {
                                width: t,
                                height: e,
                                length: t * e
                            },
                            immutable: !0
                        }), this.addAbsolute = _((function(t, e) {
                            return t[0] + Math.abs(e[0][0])
                        }), {
                            output: [1],
                            immutable: !0
                        }), this.add = _((function(t, e) {
                            return t[0] + e[0]
                        }), {
                            output: [1],
                            immutable: !0
                        }), this.divide = _((function(t, e) {
                            const n = e[0];
                            return n > 0 ? n / t : 0
                        }), {
                            output: [1],
                            immutable: !0
                        })
                    }
                }
                const A = {
                    width: 1,
                    height: 1,
                    depth: null,
                    weights: null,
                    deltas: null,
                    praxis: null,
                    praxisOpts: null,
                    cleanupDeltas: !0
                };
                class I {
                    constructor(t) {
                        this.praxis = null, this.predictKernel = null, this.compareKernel = null, this.settings = t ? {
                            ...A,
                            ...t
                        } : {
                            ...A
                        }, this.setupPraxis()
                    }
                    get width() {
                        var t;
                        return null !== (t = this.settings.width) && void 0 !== t ? t : 0
                    }
                    get height() {
                        var t;
                        return null !== (t = this.settings.height) && void 0 !== t ? t : 0
                    }
                    get depth() {
                        var t;
                        return null !== (t = this.settings.depth) && void 0 !== t ? t : 0
                    }
                    get weights() {
                        return this.settings.weights
                    }
                    set weights(t) {
                        this.settings.weights = t, this.settings.cleanupDeltas && this.deltas && function(t) {
                            if (t instanceof e.Texture) t.clear();
                            else {
                                if (Array.isArray(t))
                                    if ("number" == typeof t[0]) t.fill(0);
                                    else {
                                        if ("number" == typeof t[0][0]) {
                                            for (let e = 0; e < t.length; e++) t[e].fill(0);
                                            return
                                        }
                                        if ("number" == typeof t[0][0][0]) {
                                            for (let e = 0; e < t.length; e++) {
                                                const n = t[e];
                                                for (let t = 0; t < n.length; t++) n[t].fill(0)
                                            }
                                            return
                                        }
                                    } if (!(t instanceof Float32Array)) throw new Error("unhandled value");
                                t.fill(0)
                            }
                        }(this.deltas)
                    }
                    get deltas() {
                        return this.settings.deltas
                    }
                    set deltas(t) {
                        this.settings.deltas = t
                    }
                    get id() {
                        var t;
                        return null !== (t = this.settings.id) && void 0 !== t ? t : ""
                    }
                    set id(t) {
                        this.settings.id = t
                    }
                    setupPraxis() {
                        const {
                            initPraxis: t,
                            praxis: e,
                            praxisOpts: n
                        } = this.settings;
                        this.praxis || (t ? this.praxis = n ? t(this, n) : t(this) : e && (this.praxis = e))
                    }
                    validate() {
                        if (Number.isNaN(this.height)) throw new Error(`${this.constructor.name} layer height is not a number`);
                        if (Number.isNaN(this.width)) throw new Error(`${this.constructor.name} layer width is not a number`);
                        if (this.height < 1) throw new Error(`${this.constructor.name} layer height is less than 1`);
                        if (this.width < 1) throw new Error(`${this.constructor.name} layer width is less than 1`)
                    }
                    setupKernels(t) {}
                    reuseKernels(t) {
                        if (t.width !== this.width) throw new Error(`${this.constructor.name} kernel width mismatch ${t.width} is not ${this.width}`);
                        if (t.height !== this.height) throw new Error(`${this.constructor.name} kernel width mismatch ${t.height} is not ${this.height}`);
                        if (t.hasOwnProperty("predictKernel") && null !== t.predictKernel) {
                            if (!t.predictKernel.immutable) throw new Error(`${t.constructor.name}.predictKernel is not reusable, set kernel.immutable = true`);
                            this.predictKernel = t.predictKernel
                        }
                        if (t.hasOwnProperty("compareKernel") && null !== t.compareKernel) {
                            if (!t.compareKernel.immutable) throw new Error(`${t.constructor.name}.compareKernel is not reusable, set kernel.immutable = true`);
                            this.compareKernel = t.compareKernel
                        }
                        this.praxis = t.praxis
                    }
                    predict(t) {}
                    compare(t) {}
                    learn(t) {}
                    toArray() {
                        return Array.isArray(this.weights) ? this.weights : this.weights.toArray()
                    }
                    toJSON() {
                        return I.toJSON(this)
                    }
                    static toJSON(t) {
                        const {
                            weights: n
                        } = t;
                        return {
                            width: t.width,
                            height: t.height,
                            depth: t.depth,
                            weights: S(n && n instanceof e.Texture ? n.toArray() : n),
                            type: t.constructor.name,
                            praxisOpts: t.praxis ? t.praxis.toJSON() : null
                        }
                    }
                }

                function S(t) {
                    if (null === t) return null;
                    if (Array.isArray(t)) {
                        if ("number" == typeof t[0]) return t;
                        if (Array.isArray(t[0]) && "number" == typeof t[0][0]) return t;
                        if (Array.isArray(t[0][0]) && "number" == typeof t[0][0][0]) return t;
                        if (t[0] instanceof Float32Array) return t.map((t => Array.from(t)));
                        if (t[0][0] instanceof Float32Array) return t.map((t => t.map((t => Array.from(t)))))
                    } else if (t) return Array.from(t);
                    throw new Error("unexpected value")
                }

                function k(t) {
                    return new Float32Array(t)
                }

                function D(t, e) {
                    const n = new Array(e);
                    for (let i = 0; i < e; i++) n[i] = k(t);
                    return n
                }

                function L(t, e, n) {
                    const i = new Array(n);
                    for (let s = 0; s < n; s++) i[s] = D(t, e);
                    return i
                }
                class C extends I {
                    constructor(t, e) {
                        super(e), this.inputLayer = t;
                        const {
                            width: n,
                            height: i,
                            depth: s
                        } = this;
                        this.predictKernel = null, this.compareKernel = null, this.validate(), s > 0 ? (this.weights = L(n, i, s), this.deltas = L(n, i, s)) : i > 0 && (this.weights = D(n, i), this.deltas = D(n, i)), this.setupPraxis()
                    }
                    get width() {
                        return this.inputLayer.width
                    }
                    get height() {
                        return this.inputLayer.height
                    }
                    get depth() {
                        return this.inputLayer.depth
                    }
                }
                class M extends I {
                    constructor(t, e) {
                        super(), this.settings = t, this.inputLayer = e
                    }
                    get width() {
                        return this.inputLayer.width
                    }
                    get height() {
                        return this.inputLayer.height
                    }
                    get depth() {
                        return this.inputLayer.depth
                    }
                    get filterCount() {
                        return this.settings.filterCount
                    }
                    get filterWidth() {
                        return this.settings.filterWidth
                    }
                    get filterHeight() {
                        return this.settings.filterHeight
                    }
                    get filters() {
                        return this.settings.filters
                    }
                    set filters(t) {
                        this.settings.filters = t
                    }
                    get filterDeltas() {
                        return this.settings.filterDeltas
                    }
                    set filterDeltas(t) {
                        this.settings.filterDeltas = t
                    }
                }
                class O {
                    constructor() {
                        this.predictKernel = null, this.compareKernel = null, this.praxis = null
                    }
                    get width() {
                        return this.settings.width
                    }
                    get height() {
                        return this.settings.height
                    }
                    get depth() {
                        return this.settings.depth
                    }
                    get weights() {
                        return this.settings.weights
                    }
                    set weights(t) {
                        this.settings.weights = t
                    }
                    get deltas() {
                        return this.settings.deltas
                    }
                    set deltas(t) {
                        this.settings.deltas = t
                    }
                    toJSON() {
                        return I.toJSON(this)
                    }
                }
                class R extends I {
                    constructor(t, e) {
                        super({
                            ...e,
                            width: t.width,
                            height: t.height,
                            depth: t.depth
                        }), this.inputLayer = t
                    }
                    validate() {
                        var t;
                        if (super.validate(), this.width !== this.inputLayer.width) throw new Error(`width of ${this.width} does not match inputLayer.width of ${this.inputLayer.width}`);
                        if (this.height !== this.inputLayer.height) throw new Error(`height of ${this.height} does not match inputLayer.height of ${this.inputLayer.height}`);
                        if (this.depth !== (null !== (t = this.inputLayer.depth) && void 0 !== t ? t : 0)) throw new Error(`depth of ${this.depth} does not match inputLayer.depth of ${this.inputLayer.depth}`)
                    }
                }
                class N extends I {
                    constructor(t, e, n) {
                        super(n), this.inputLayer1 = t, this.inputLayer2 = e, this.validate(), this.weights = D(this.width, this.height), this.deltas = D(this.width, this.height), this.setupPraxis()
                    }
                }

                function P(t, e) {
                    return t[this.thread.y][this.thread.x] - e[this.thread.x]
                }

                function $(t, e) {
                    return t[this.thread.y][this.thread.x] - e[this.thread.y][this.thread.x]
                }
                class U extends I {
                    constructor(t, e) {
                        if (super(t), this.inputLayer = e, this.validate(), this.depth) throw new Error("Target layer not implemented for depth");
                        this.height ? (this.weights = D(this.width, this.height), this.deltas = D(this.width, this.height), this.errors = D(this.width, this.height)) : (this.weights = k(this.width), this.deltas = k(this.width), this.errors = k(this.width))
                    }
                    setupKernels() {
                        1 === this.width ? this.compareKernel = _(P, {
                            output: [this.width, this.height],
                            immutable: !0
                        }) : this.compareKernel = _($, {
                            output: [this.width, this.height],
                            immutable: !0
                        })
                    }
                    predict() {
                        w(this.weights), this.weights = T(this.inputLayer.weights)
                    }
                    compare(t) {
                        w(this.deltas), w(this.errors), w(this.inputLayer.deltas), this.deltas = this.compareKernel(this.weights, t), this.inputLayer.deltas = T(this.deltas), this.errors = T(this.deltas)
                    }
                    setupPraxis() {}
                }

                function F(t, e) {
                    return new U(t, e)
                }
                class B {}
                class z extends I {}
                class V extends I {
                    learn(t) {
                        const {
                            weights: e
                        } = this;
                        if (!this.praxis) throw new Error("this.praxis not defined");
                        this.weights = this.praxis.run(this, t), w(e)
                    }
                }
                const K = {
                    toTable(t) {
                        const e = t.reduce(((t, e) => Object.assign(t, e)), {});
                        return K.toHash(e)
                    },
                    toTable2D(t) {
                        const e = {};
                        let n = 0;
                        for (let i = 0; i < t.length; i++) {
                            const s = t[i];
                            for (let t = 0; t < s.length; t++) {
                                const i = s[t];
                                for (const t in i) i.hasOwnProperty(t) && !e.hasOwnProperty(t) && (e[t] = n++)
                            }
                        }
                        return e
                    },
                    toInputTable2D(t) {
                        const e = {};
                        let n = 0;
                        for (let i = 0; i < t.length; i++) {
                            const s = t[i].input;
                            for (let t = 0; t < s.length; t++) {
                                const i = s[t];
                                for (const t in i) i.hasOwnProperty(t) && (e.hasOwnProperty(t) || (e[t] = n++))
                            }
                        }
                        return e
                    },
                    toOutputTable2D(t) {
                        const e = {};
                        let n = 0;
                        for (let i = 0; i < t.length; i++) {
                            const s = t[i].output;
                            for (let t = 0; t < s.length; t++) {
                                const i = s[t];
                                for (const t in i) i.hasOwnProperty(t) && (e.hasOwnProperty(t) || (e[t] = n++))
                            }
                        }
                        return e
                    },
                    toHash(t) {
                        const e = {};
                        let n = 0;
                        const i = Object.keys(t);
                        for (let t = 0; t < i.length; t++) e[i[t]] = n++;
                        return e
                    },
                    toArray(t, e, n) {
                        const i = new Float32Array(n);
                        for (const n in t) t.hasOwnProperty(n) && (i[t[n]] = e.hasOwnProperty(n) ? e[n] : 0);
                        return i
                    },
                    toArrayShort(t, e) {
                        const n = [];
                        for (const i in t)
                            if (t.hasOwnProperty(i)) {
                                if (!e.hasOwnProperty(i)) break;
                                n[t[i]] = e[i]
                            } return Float32Array.from(n)
                    },
                    toArrays(t, e, n) {
                        const i = [];
                        for (let s = 0; s < e.length; s++) i.push(this.toArray(t, e[s], n));
                        return i
                    },
                    toObject(t, e) {
                        const n = {};
                        for (const i in t) t.hasOwnProperty(i) && (n[i] = e[t[i]]);
                        return n
                    },
                    toObjectPartial(t, e, n = 0, i = 0) {
                        const s = {};
                        let r = 0;
                        for (const a in t) t.hasOwnProperty(a) && (n > 0 && r++ < n || i > 0 && r++ >= i || (s[a] = e[t[a] - n]));
                        return s
                    },
                    dataShape(t) {
                        const e = [];
                        let n, i;
                        for (t.hasOwnProperty("input") ? (e.push("datum"), n = t.input) : Array.isArray(t) ? t[0] && t[0].input ? (e.push("array", "datum"), n = t[0].input) : Array.isArray(t[0]) ? (e.push("array"), n = t[0]) : n = t : n = t; n;)
                            if (i = Object.keys(n)[0], Array.isArray(n) || "object" == typeof n.buffer) {
                                e.push("array");
                                const t = n[parseInt(i)];
                                if ("number" == typeof t) {
                                    e.push("number");
                                    break
                                }
                                n = t
                            } else {
                                if ("object" != typeof n || "object" == typeof n.buffer) throw new Error("unhandled signature"); {
                                    e.push("object");
                                    const t = n[i];
                                    if ("number" == typeof t) {
                                        e.push("number");
                                        break
                                    }
                                    n = t
                                }
                            } return e
                    },
                    addKeys(t, e) {
                        if (Array.isArray(t)) return e;
                        let n = Object.keys(e).length;
                        for (const i in t) t.hasOwnProperty(i) && (e.hasOwnProperty(i) || (e[i] = n++));
                        return e
                    }
                };
                class G {
                    constructor(t, e = {}) {
                        this.layerTemplate = t, this.settings = {
                            ...e
                        }, this.kernel = null
                    }
                    get width() {
                        return this.layerTemplate.width
                    }
                    get height() {
                        return this.layerTemplate.height
                    }
                    get depth() {
                        return this.layerTemplate.depth
                    }
                    setupKernels() {}
                    reuseKernels(t) {
                        if (t.width !== this.width) throw new Error(`${this.constructor.name} kernel width mismatch ${t.width} is not ${this.width}`);
                        if (t.height !== this.height) throw new Error(`${this.constructor.name} kernel width mismatch ${t.height} is not ${this.height}`);
                        t.hasOwnProperty("kernel") && (this.kernel = t.kernel)
                    }
                    toJSON() {
                        return {
                            ...this.settings
                        }
                    }
                }

                function j(t, e) {
                    return t[this.thread.y][this.thread.x] + this.constants.learningRate * e[this.thread.y][this.thread.x]
                }
                const W = {
                    learningRate: .3
                };
                class H extends G {
                    constructor(t, e) {
                        super(t), this.settings = {
                            ...W,
                            ...e
                        }, this.kernel = null
                    }
                    run(t) {
                        return this.kernel(t.weights, t.deltas)
                    }
                    setupKernels() {
                        this.kernel = _(j, {
                            output: [this.width, this.height],
                            constants: {
                                learningRate: this.settings.learningRate
                            }
                        })
                    }
                }

                function X(t, e) {
                    return new H(t, e)
                }

                function Z(t) {
                    return t
                }

                function q(t, e, n, i) {
                    const s = t[this.thread.y][this.thread.x],
                        r = i[this.thread.y][0],
                        a = e[this.thread.y][this.thread.x],
                        o = n[this.thread.x][0];
                    return a + (this.constants.learningRate * r * o + this.constants.momentum * s)
                }
                const Y = {
                    learningRate: .3,
                    momentum: .1,
                    weightsLayer: null,
                    incomingLayer: null,
                    deltaLayer: null
                };
                class J extends G {
                    constructor(t, e) {
                        super(t), this.kernelMap = null, this.settings = {
                            ...Y,
                            ...e
                        }, this.changes = D(t.width, t.height)
                    }
                    get learningRate() {
                        return this.settings.learningRate
                    }
                    get momentum() {
                        return this.settings.momentum
                    }
                    get weightsLayer() {
                        return this.settings.weightsLayer
                    }
                    set weightsLayer(t) {
                        this.settings.weightsLayer = t
                    }
                    get deltaLayer() {
                        return this.settings.deltaLayer
                    }
                    set deltaLayer(t) {
                        this.settings.deltaLayer = t
                    }
                    get incomingLayer() {
                        return this.settings.incomingLayer
                    }
                    set incomingLayer(t) {
                        this.settings.incomingLayer = t
                    }
                    run() {
                        const t = this.kernelMap(this.changes, this.weightsLayer.weights, this.incomingLayer.weights, this.deltaLayer.deltas);
                        return this.changes = t.changes, t.result
                    }
                    setupKernels() {
                        this.kernelMap = b({
                            changes: Z
                        }, q, {
                            output: [this.width, this.height],
                            constants: {
                                learningRate: this.learningRate,
                                momentum: this.momentum
                            }
                        })
                    }
                }

                function Q(t, e) {
                    return new J(t, e)
                }

                function tt(t, e, n) {
                    return n * e + (1 - e) * t * t
                }

                function et(t, e, n) {
                    return t > e ? e : t < n ? n : t
                }

                function nt(t, e, n) {
                    const i = e[this.thread.y][this.thread.x],
                        s = et(i, this.constants.clipValue, -this.constants.clipValue),
                        r = t[this.thread.y][this.thread.x],
                        a = n[this.thread.y][this.thread.x],
                        o = tt(i, this.constants.decayRate, a);
                    return r + -this.constants.learningRate * s / Math.sqrt(o + this.constants.smoothEps) - this.constants.regularizationStrength * r
                }
                const it = {
                    decayRate: .999,
                    regularizationStrength: 1e-6,
                    learningRate: .01,
                    smoothEps: 1e-8,
                    clipValue: 5
                };
                class st extends G {
                    constructor(t, e = {}) {
                        super(t), this.kernelMap = null, this.settings = {
                            ...it,
                            ...e
                        }, this.momenta = D(t.width, t.height)
                    }
                    get clipValue() {
                        return this.settings.clipValue
                    }
                    get decayRate() {
                        return this.settings.decayRate
                    }
                    get learningRate() {
                        return this.settings.learningRate
                    }
                    get regularizationStrength() {
                        return this.settings.regularizationStrength
                    }
                    get smoothEps() {
                        return this.settings.smoothEps
                    }
                    run(t) {
                        const {
                            momenta: e,
                            result: n
                        } = this.kernelMap(t.weights, t.deltas, this.momenta);
                        return w(this.momenta), this.momenta = e, n
                    }
                    setupKernels() {
                        this.kernelMap = b({
                            momenta: tt
                        }, nt, {
                            output: [this.width, this.height],
                            constants: {
                                clipValue: this.clipValue,
                                decayRate: this.decayRate,
                                learningRate: this.learningRate,
                                regularizationStrength: this.regularizationStrength,
                                smoothEps: this.smoothEps
                            },
                            functions: [et],
                            immutable: !0
                        })
                    }
                }

                function rt(t, e) {
                    return new st(t, e)
                }
                const at = st,
                    ot = rt;
                var ut = Object.freeze({
                    __proto__: null,
                    ArthurDeviationBiases: H,
                    arthurDeviationBiases: X,
                    ArthurDeviationWeights: J,
                    arthurDeviationWeights: Q,
                    MomentumRootMeanSquaredPropagation: st,
                    momentumRootMeanSquaredPropagation: rt,
                    MRmsProp: at,
                    mRmsProp: ot
                });

                function ht(t, e) {
                    t.hasOwnProperty("inputLayer") ? ht(t.inputLayer, e) : (t.hasOwnProperty("inputLayer1") && ht(t.inputLayer1, e), t.hasOwnProperty("inputLayer2") && ht(t.inputLayer2, e)), e(t)
                }

                function lt(t) {
                    const e = t.slice(0);
                    for (let t = 0; t < e.length; t++) {
                        let n = 0;
                        ht(e[t], (i => {
                            e.includes(i) || (e.splice(t + n, 0, i), n++)
                        }))
                    }
                    return e
                }

                function ct(t, e) {
                    if (t.width !== e.width) throw new Error(`Layer width mismatch of ${t.width} and ${e.width}`);
                    if (t.height !== e.height) throw new Error(`Layer height mismatch of ${t.height} and ${e.height}`)
                }

                function pt(t, e) {
                    return t[this.thread.y][this.thread.x] + e[this.thread.y][this.thread.x]
                }
                class dt extends N {
                    get width() {
                        return this.inputLayer1.width
                    }
                    get height() {
                        return this.inputLayer1.height
                    }
                    get depth() {
                        return this.inputLayer1.depth
                    }
                    validate() {
                        super.validate(), ct(this.inputLayer1, this.inputLayer2)
                    }
                    setupKernels() {
                        this.predictKernel = _(pt, {
                            output: [this.width, this.height],
                            immutable: !0
                        })
                    }
                    predict() {
                        w(this.weights), this.weights = this.predictKernel(this.inputLayer1.weights, this.inputLayer2.weights)
                    }
                    compare() {
                        w(this.inputLayer1.deltas), w(this.inputLayer2.deltas), this.inputLayer1.deltas = T(this.deltas), this.inputLayer2.deltas = T(this.deltas)
                    }
                }

                function mt(t, e, n) {
                    return new dt(t, e, n)
                }

                function gt() {
                    return .4 * Math.random() - .2
                }

                function ft(t, e) {
                    return Math.random() * (e - t) + t
                }

                function yt() {
                    if (yt.returnV) return yt.returnV = !1, yt.vVal;
                    const t = 2 * Math.random() - 1,
                        e = 2 * Math.random() - 1,
                        n = t * t + e * e;
                    if (0 === n || n > 1) return yt();
                    const i = Math.sqrt(-2 * Math.log(n) / n);
                    return yt.vVal = e * i, yt.returnV = !0, t * i
                }
                yt.returnV = !1, yt.vVal = 0;
                var xt = Object.freeze({
                    __proto__: null,
                    randomFloat: ft,
                    gaussRandom: yt,
                    randomInteger: function(t, e) {
                        return Math.floor(Math.random() * (e - t) + t)
                    },
                    randomN: function(t, e) {
                        return t + yt() * e
                    }
                });

                function _t(t, e = null) {
                    const n = new Float32Array(t);
                    if (null === e)
                        for (let e = 0; e < t; e++) n[e] = gt();
                    else
                        for (let i = 0; i < t; i++) n[i] = ft(-e, e);
                    return n
                }

                function bt(t, e, n) {
                    const i = new Array(e);
                    for (let s = 0; s < e; s++) i[s] = _t(t, n);
                    return i
                }

                function wt(t, e, n, i) {
                    const s = new Array(n);
                    for (let r = 0; r < n; r++) s[r] = bt(t, e, i);
                    return s
                }
                const Tt = {
                    ...A,
                    std: null
                };
                class vt extends V {
                    constructor(t) {
                        super(), this.settings = {
                            ...Tt,
                            ...t
                        }, this.setupPraxis(), this.validate(), this.weights || (this.weights = bt(this.width, this.height, t.std)), this.deltas || (this.deltas = D(this.width, this.height))
                    }
                    predict() {}
                    compare() {}
                }

                function Et(t) {
                    return new vt(t)
                }

                function At(t, e) {
                    let n = 0;
                    for (let i = 0; i < this.constants.size; i++) n += t[this.thread.y][i] * e[i][this.thread.x];
                    return n
                }

                function It(t, e, n) {
                    let i = e[this.thread.y][this.thread.x];
                    for (let e = 0; e < this.constants.size; e++) i += t[this.thread.y][e] * n[this.thread.x][e];
                    return i
                }

                function St(t, e, n) {
                    let i = e[this.thread.y][this.thread.x];
                    for (let e = 0; e < this.constants.size; e++) i += t[e][this.thread.x] * n[e][this.thread.y];
                    return i
                }
                class kt extends N {
                    constructor() {
                        super(...arguments), this.compareKernel1 = null, this.compareKernel2 = null
                    }
                    get width() {
                        return this.inputLayer2.width
                    }
                    set width(t) {
                        throw new Error("Cannot set width on Multiply")
                    }
                    get height() {
                        return this.inputLayer1.height
                    }
                    set height(t) {
                        throw new Error("Cannot set height on Multiply")
                    }
                    get depth() {
                        return this.inputLayer1.depth
                    }
                    set depth(t) {
                        throw new Error("Cannot set depth on Multiply")
                    }
                    validate() {
                        if (super.validate(), this.inputLayer1.width !== this.inputLayer2.height) throw new Error(`Layer width mismatch of ${this.inputLayer1.width} and ${this.inputLayer2.height}`)
                    }
                    setupKernels() {
                        this.predictKernel = _(At, {
                            output: [this.width, this.height],
                            constants: {
                                size: this.inputLayer2.height
                            },
                            immutable: !0
                        }), this.compareKernel1 = _(It, {
                            output: [this.inputLayer1.width, this.inputLayer1.height],
                            constants: {
                                size: this.inputLayer2.width
                            },
                            immutable: !0
                        }), this.compareKernel2 = _(St, {
                            output: [this.inputLayer2.width, this.inputLayer2.height],
                            constants: {
                                size: this.inputLayer1.height
                            },
                            immutable: !0
                        })
                    }
                    reuseKernels(t) {
                        super.reuseKernels(t), this.compareKernel1 = t.compareKernel1, this.compareKernel2 = t.compareKernel2
                    }
                    predict() {
                        if (w(this.weights), !this.predictKernel) throw new Error("this.predictKernel is not set");
                        this.weights = this.predictKernel(this.inputLayer1.weights, this.inputLayer2.weights)
                    }
                    compare() {
                        if (!this.compareKernel1) throw new Error("this.compareKernel1 not set");
                        if (!this.compareKernel2) throw new Error("this.compareKernel2 not set");
                        const t = this.inputLayer1.deltas,
                            e = this.inputLayer2.deltas,
                            n = this.compareKernel1(this.deltas, this.inputLayer1.deltas, this.inputLayer2.weights),
                            i = this.compareKernel2(this.deltas, this.inputLayer2.deltas, this.inputLayer1.weights);
                        this.inputLayer2.deltas = i, this.inputLayer1.deltas = n, w(t), w(e)
                    }
                    setupPraxis() {}
                    toJSON() {
                        return {
                            ...super.toJSON(),
                            width: this.width,
                            height: this.height
                        }
                    }
                }

                function Dt(t, e, n) {
                    return new kt(t, e, n)
                }

                function Lt(t) {
                    return 1 / (1 + Math.exp(-t[this.thread.y][this.thread.x]))
                }

                function Ct(t) {
                    return 1 / (1 + Math.exp(-t[this.thread.z][this.thread.y][this.thread.x]))
                }

                function Mt(t, e) {
                    const n = t[this.thread.y][this.thread.x];
                    return n * (1 - n) * e[this.thread.y][this.thread.x]
                }

                function Ot(t, e) {
                    const n = t[this.thread.z][this.thread.y][this.thread.x];
                    return n * (1 - n) * e[this.thread.z][this.thread.y][this.thread.x]
                }
                class Rt extends C {
                    setupKernels() {
                        this.depth > 0 ? (this.predictKernel = _(Ct, {
                            output: [this.width, this.height, this.depth],
                            functions: [a],
                            immutable: !0
                        }), this.compareKernel = _(Ot, {
                            output: [this.width, this.height, this.depth],
                            functions: [o],
                            immutable: !0
                        })) : (this.predictKernel = _(Lt, {
                            output: [this.width, this.height],
                            functions: [a],
                            immutable: !0
                        }), this.compareKernel = _(Mt, {
                            output: [this.width, this.height],
                            functions: [o],
                            immutable: !0
                        }))
                    }
                    predict() {
                        w(this.weights), this.weights = this.predictKernel(this.inputLayer.weights)
                    }
                    compare() {
                        w(this.inputLayer.deltas), this.inputLayer.deltas = this.compareKernel(this.weights, this.deltas)
                    }
                    learn(t) {}
                }

                function Nt(t, e) {
                    return new Rt(t, e)
                }

                function Pt(t, e) {
                    if ("number" == typeof t.stride) return {
                        strideX: t.stride,
                        strideY: t.stride
                    }; {
                        let n = e.stride,
                            i = e.stride;
                        return "number" == typeof t.strideX && (n = t.strideX), "number" == typeof t.strideY && (i = t.strideY), {
                            strideX: n,
                            strideY: i
                        }
                    }
                }

                function $t(t, e) {
                    if ("number" == typeof t.padding) return {
                        paddingX: t.padding,
                        paddingY: t.padding
                    }; {
                        let n = e.padding,
                            i = e.padding;
                        return "number" == typeof t.paddingX && (n = t.paddingX), "number" == typeof t.paddingY && (i = t.paddingY), {
                            paddingX: n,
                            paddingY: i
                        }
                    }
                }

                function Ut(t, e) {
                    return new Float32Array(t).fill(e)
                }

                function Ft(t, e, n) {
                    const i = this.constants.paddingX - this.thread.x * this.constants.strideX,
                        s = this.thread.x * this.constants.strideX - this.constants.paddingX,
                        r = Math.min(this.constants.filterWidth, i + this.constants.inputWidth),
                        a = this.constants.paddingY - this.thread.y * this.constants.strideY,
                        o = this.thread.y * this.constants.strideY - this.constants.paddingY,
                        u = Math.min(this.constants.filterHeight, a + this.constants.inputHeight);
                    let h = 0;
                    for (let n = 0; n < this.constants.inputDepth; n++)
                        for (let l = Math.max(0, a), c = Math.max(0, o); l < u; l++, c++)
                            for (let a = Math.max(0, i), o = Math.max(0, s); a < r; a++, o++) h += e[n][l][a] * t[n][c][o];
                    return h + n[this.thread.z]
                }

                function Bt(t, e, n) {
                    const i = Math.max(0, Math.ceil((this.constants.paddingX - this.thread.x) / this.constants.strideX)),
                        s = i * this.constants.strideX + this.thread.x - this.constants.paddingX,
                        r = Math.min(this.constants.deltaWidth, Math.floor((this.constants.inputWidth - 1 - this.thread.x + this.constants.paddingX) / this.constants.strideX) + 1),
                        a = Math.max(0, Math.ceil((this.constants.paddingY - this.thread.y) / this.constants.strideY)),
                        o = a * this.constants.strideY + this.thread.y - this.constants.paddingY,
                        u = Math.min(this.constants.deltaHeight, Math.floor((this.constants.inputHeight - 1 - this.thread.y + this.constants.paddingY) / this.constants.strideY) + 1);
                    let h = t[this.thread.z][this.thread.y][this.thread.x];
                    for (let t = a, l = o; t < u; t++, l += this.constants.strideY)
                        for (let a = i, o = s; a < r; a++, o += this.constants.strideX) h += e[this.thread.z][l][o] * n[this.constants.deltaZ][t][a];
                    return h
                }

                function zt(t, e, n) {
                    const i = this.thread.x + this.constants.paddingX,
                        s = i < this.constants.filterWidth ? 0 : Math.floor((i - this.constants.filterWidth + this.constants.strideX) / this.constants.strideX),
                        r = i - s * this.constants.strideX,
                        a = Math.min(s + Math.floor(r / this.constants.strideX) + 1, this.constants.deltaWidth),
                        o = this.thread.y + this.constants.paddingY,
                        u = o < this.constants.filterHeight ? 0 : Math.floor((o - this.constants.filterHeight + this.constants.strideY) / this.constants.strideY),
                        h = o - u * this.constants.strideY,
                        l = Math.min(u + Math.floor(h / this.constants.strideY) + 1, this.constants.deltaHeight);
                    let c = t[this.thread.z][this.thread.y][this.thread.x],
                        p = u;
                    for (let t = h; p < l; t -= this.constants.strideY, p++) {
                        let i = s;
                        for (let s = r; i < a; s -= this.constants.strideX, i++) c += e[this.thread.z][t][s] * n[this.constants.deltaZ][p][i]
                    }
                    return c
                }

                function Vt(t, e) {
                    let n = 0;
                    for (let t = 0; t < this.constants.deltaHeight; t++)
                        for (let i = 0; i < this.constants.deltaWidth; i++) n += e[this.thread.z][t][i];
                    return t[this.thread.z][this.thread.y][this.thread.x] + n
                }
                const Kt = {
                    stride: 0,
                    padding: 0,
                    bias: .1,
                    filterCount: 1,
                    filterWidth: 0,
                    filterHeight: 0
                };
                class Gt extends M {
                    constructor(t, e) {
                        var n, i, s;
                        super(t, e), this.compareFilterDeltasKernel = null, this.compareInputDeltasKernel = null, this.compareBiasesKernel = null, this.settings = {
                            ...Kt,
                            ...t,
                            ...$t(t, Kt),
                            ...Pt(t, Kt)
                        }, this.weights = null !== (n = t.weights) && void 0 !== n ? n : wt(this.width, this.height, this.depth), this.deltas = L(this.width, this.height, this.depth), this.biases = Ut(this.depth, this.bias), this.biasDeltas = null !== (i = t.biasDeltas) && void 0 !== i ? i : _t(this.depth), this.filters = null !== (s = t.filters) && void 0 !== s ? s : wt(this.filterWidth, this.filterHeight, this.filterCount), this.filterDeltas = L(this.filterWidth, this.filterHeight, this.filterCount), this.validate()
                    }
                    get strideX() {
                        return this.settings.strideX
                    }
                    get strideY() {
                        return this.settings.strideY
                    }
                    get paddingX() {
                        return this.settings.paddingX
                    }
                    get paddingY() {
                        return this.settings.paddingX
                    }
                    get width() {
                        return Math.floor((this.inputLayer.width + 2 * this.paddingX - this.filterWidth) / this.strideX + 1)
                    }
                    get height() {
                        return Math.floor((this.inputLayer.height + 2 * this.paddingY - this.filterHeight) / this.strideY + 1)
                    }
                    get bias() {
                        return this.settings.bias
                    }
                    get depth() {
                        return this.filterCount
                    }
                    get biases() {
                        return this.settings.biases
                    }
                    set biases(t) {
                        this.settings.biases = t
                    }
                    get biasDeltas() {
                        return this.settings.biasDeltas
                    }
                    set biasDeltas(t) {
                        this.settings.biasDeltas = t
                    }
                    get filters() {
                        return this.settings.filters
                    }
                    set filters(t) {
                        this.settings.filters = t
                    }
                    get filterDeltas() {
                        return this.settings.filterDeltas
                    }
                    set filterDeltas(t) {
                        this.settings.filterDeltas = t
                    }
                    setupKernels() {
                        this.predictKernel = _(Ft, {
                            constants: {
                                inputWidth: this.inputLayer.width,
                                inputHeight: this.inputLayer.height,
                                inputDepth: this.inputLayer.depth,
                                strideX: this.strideX,
                                strideY: this.strideY,
                                paddingX: this.paddingX,
                                paddingY: this.paddingY,
                                filterWidth: this.filterWidth,
                                filterHeight: this.filterHeight
                            },
                            output: [this.width, this.height, this.depth],
                            immutable: !0
                        }), this.compareFilterDeltasKernel = _(Bt, {
                            constants: {
                                deltasWidth: this.width,
                                deltasHeight: this.height,
                                deltasDepth: this.depth,
                                inputWidth: this.inputLayer.width,
                                inputHeight: this.inputLayer.height,
                                inputDepth: this.inputLayer.depth,
                                strideX: this.strideX,
                                strideY: this.strideY,
                                paddingX: this.paddingX,
                                paddingY: this.paddingY,
                                filterWidth: this.filterWidth,
                                filterHeight: this.filterHeight
                            },
                            output: [this.width, this.height, this.depth],
                            immutable: !0
                        }), this.compareInputDeltasKernel = _(zt, {
                            constants: {
                                filterCount: this.filterCount
                            },
                            output: [this.inputLayer.width, this.inputLayer.height, this.inputLayer.depth],
                            immutable: !0
                        }), this.compareBiasesKernel = _(Vt, {
                            output: [1, 1, this.depth],
                            constants: {
                                deltaWidth: this.width,
                                deltaHeight: this.height
                            },
                            immutable: !0
                        })
                    }
                    predict() {
                        this.weights = this.predictKernel(this.inputLayer.weights, this.filters, this.biases)
                    }
                    compare() {
                        const {
                            filterDeltas: t,
                            biasDeltas: e
                        } = this;
                        this.filterDeltas = this.compareFilterDeltasKernel(t, this.inputLayer.weights, this.deltas), w(t), this.biasDeltas = this.compareBiasesKernel(e, this.deltas), w(e), w(this.deltas), this.deltas = this.compareInputDeltasKernel(this.filters, this.inputLayer.deltas), w(this.inputLayer.deltas), this.inputLayer.deltas = T(this.deltas)
                    }
                    learn(t) {
                        const {
                            weights: e
                        } = this;
                        this.weights = this.praxis.run(this, t), w(e)
                    }
                }

                function jt(t) {
                    return t
                }

                function Wt(t) {
                    return Math.random() < this.constants.probability ? 0 : t[this.thread.y][this.thread.x]
                }

                function Ht(t) {
                    return t[this.thread.y][this.thread.x] * this.constants.probability
                }

                function Xt(t, e) {
                    return 0 === t[this.thread.y][this.thread.x] ? 0 : e[this.thread.y][this.thread.x]
                }
                const Zt = {
                    ...A,
                    probability: .5
                };
                class qt extends M {
                    constructor(t, e) {
                        super(e, t), this.predictKernelMap = null, this.settings = {
                            ...Zt,
                            ...e
                        }, this.dropouts = null, this.validate()
                    }
                    setupKernels(t) {
                        const e = [this.width, this.height];
                        t ? (this.predictKernelMap = b({
                            dropouts: jt
                        }, Wt, {
                            output: e,
                            immutable: !0
                        }), this.compareKernel = _(Xt, {
                            output: e,
                            immutable: !0
                        })) : this.predictKernelMap = b({}, Ht, {
                            output: e,
                            immutable: !0
                        })
                    }
                    predict() {
                        w(this.weights), this.dropouts && w(this.dropouts);
                        const {
                            result: t,
                            dropouts: e
                        } = this.predictKernelMap(this.inputLayer.weights);
                        this.weights = t, this.dropouts = e
                    }
                    compare() {
                        w(this.deltas), this.deltas = this.compareKernel(this.dropouts, this.inputLayer.deltas)
                    }
                }

                function Yt(t, e, n) {
                    let i = 0,
                        s = 0;
                    for (let n = 0; n < this.constants.inputHeight; n++)
                        for (let r = 0; r < this.constants.inputWidth; r++) i += t[n][r] * e[this.thread.x][s], s++;
                    return i + n[this.thread.x]
                }

                function Jt(t, e, n) {
                    let i = 0,
                        s = 0;
                    for (let n = 0; n < this.constants.inputDepth; n++)
                        for (let r = 0; r < this.constants.inputHeight; r++)
                            for (let a = 0; a < this.constants.inputWidth; a++) i += t[n][r][a] * e[this.thread.x][s], s++;
                    return i + n[this.thread.x]
                }

                function Qt(t, e, n) {
                    let i = 0;
                    const s = this.thread.x + this.thread.y * this.output.x;
                    for (let t = 0; t < this.constants.filterCount; t++) i += n[t][s] * e[0][t];
                    return i + t[this.thread.y][this.thread.x]
                }

                function te(t, e, n) {
                    let i = 0;
                    const s = this.thread.x + this.thread.y * this.output.x;
                    for (let t = 0; t < this.constants.filterCount; t++) i += n[t][s] * e[0][t];
                    return i + t[this.thread.z][this.thread.y][this.thread.x]
                }

                function ee(t, e) {
                    return t[this.thread.x] + e[this.thread.y][this.thread.x]
                }

                function ne(t, e, n) {
                    return t[this.thread.y][this.thread.x] + e[this.thread.y][this.thread.x] * n[this.constants.deltaY][this.constants.deltaX]
                }

                function ie(t, e, n) {
                    const i = Math.floor(this.thread.x / (this.constants.inputWidth * this.constants.inputHeight)),
                        s = Math.floor((this.thread.x - i * this.constants.inputWidth * this.constants.inputHeight) / this.constants.inputWidth),
                        r = this.thread.x - this.constants.inputWidth * (s + this.constants.inputHeight * i);
                    return t[this.thread.y][this.thread.x] + e[i][s][r] * n[0][this.thread.y]
                }
                class se extends M {
                    constructor(t, e) {
                        super(t, e), this.compareFilterDeltasKernel = null, this.compareInputDeltasKernel = null, this.compareBiasesKernel = null, this.settings = {
                            ...t
                        }, this.validate();
                        const n = e.width * e.height * e.depth;
                        this.biases = Ut(this.height, this.bias), this.biasDeltas = k(this.height), this.filters = bt(n, this.height), this.filterDeltas = D(n, this.height), this.depth > 0 ? (this.weights = wt(this.width, this.height, this.depth), this.deltas = L(this.width, this.height, this.depth)) : this.height > 0 && (this.weights = bt(this.width, this.height), this.deltas = D(this.width, this.height))
                    }
                    get bias() {
                        return this.settings.bias
                    }
                    get biases() {
                        return this.settings.biases
                    }
                    set biases(t) {
                        this.settings.biases = t
                    }
                    get biasDeltas() {
                        return this.settings.biases
                    }
                    set biasDeltas(t) {
                        this.settings.biasDeltas = t
                    }
                    validate() {
                        if (super.validate(), this.depth > 0) throw new Error("depth not supported")
                    }
                    setupKernels() {
                        const {
                            inputLayer: t
                        } = this, e = t.width * t.height * t.depth;
                        t.depth > 0 ? (this.predictKernel = _(Jt, {
                            output: [this.width, this.height],
                            constants: {
                                inputHeight: t.height,
                                inputWidth: t.width,
                                inputDepth: t.depth
                            }
                        }), this.compareFilterDeltasKernel = _(ie, {
                            output: [e, this.height],
                            constants: {
                                inputWidth: t.width,
                                inputHeight: t.height
                            },
                            immutable: !0
                        }), this.compareInputDeltasKernel = _(te, {
                            output: [t.width, t.height, t.depth],
                            constants: {
                                filterCount: this.height
                            },
                            immutable: !0
                        })) : (this.predictKernel = _(Yt, {
                            output: [this.width, this.height],
                            constants: {
                                inputHeight: t.height,
                                inputWidth: t.width
                            }
                        }), this.compareFilterDeltasKernel = _(ne, {
                            output: [e, this.height],
                            constants: {
                                inputWidth: t.width
                            }
                        }), this.compareInputDeltasKernel = _(Qt, {
                            output: [t.width, t.height],
                            constants: {
                                filterCount: this.height
                            }
                        })), this.compareBiasesKernel = _(ee, {
                            output: [this.width, this.height]
                        })
                    }
                    predict() {
                        this.weights = this.predictKernel(this.inputLayer.weights, this.filters, this.biases)
                    }
                    compare() {
                        const t = this.inputLayer.deltas;
                        this.inputLayer.deltas = this.compareInputDeltasKernel(t, this.deltas, this.filters), w(t);
                        const {
                            biasDeltas: e,
                            filterDeltas: n
                        } = this;
                        this.biasDeltas = this.compareBiasesKernel(this.biases, this.deltas), this.filterDeltas = this.compareFilterDeltasKernel(n, this.inputLayer.weights, this.deltas), w(e), w(n)
                    }
                }

                function re(t) {
                    return -t[this.thread.y][this.thread.x]
                }
                class ae extends R {
                    constructor(t, e) {
                        super(t, e), this.validate()
                    }
                    setupKernels() {
                        this.predictKernel = _(re, {
                            output: [this.width, this.height]
                        })
                    }
                    predict() {
                        this.weights = this.predictKernel(this.inputLayer.weights)
                    }
                }

                function oe(t, e) {
                    return new ae(t, e)
                }

                function ue(t, e) {
                    return t[this.thread.y][this.thread.x] * e[this.thread.y][this.thread.x]
                }

                function he(t, e) {
                    return t[this.thread.y][this.thread.x] * e[this.thread.y][this.thread.x]
                }
                class le extends N {
                    get width() {
                        return this.inputLayer1.width
                    }
                    get height() {
                        return this.inputLayer1.height
                    }
                    get depth() {
                        return this.inputLayer1.depth
                    }
                    validate() {
                        super.validate(), ct(this.inputLayer1, this.inputLayer2)
                    }
                    setupKernels() {
                        this.predictKernel = _(ue, {
                            output: [this.width, this.height],
                            immutable: !0
                        }), this.compareKernel = _(he, {
                            output: [this.width, this.height],
                            immutable: !0
                        })
                    }
                    predict() {
                        w(this.weights), this.weights = this.predictKernel(this.inputLayer1.weights, this.inputLayer2.weights)
                    }
                    compare() {
                        w(this.inputLayer1.deltas), w(this.inputLayer2.deltas), this.inputLayer1.deltas = this.compareKernel(this.inputLayer2.weights, this.deltas), this.inputLayer2.deltas = this.compareKernel(this.inputLayer1.weights, this.deltas)
                    }
                }

                function ce(t, e, n) {
                    return new le(t, e, n)
                }

                function pe(t) {
                    return new Float32Array(t).fill(1)
                }

                function de(t, e) {
                    const n = new Array(e);
                    for (let i = 0; i < e; i++) n[i] = pe(t);
                    return n
                }
                class me extends V {
                    constructor(t) {
                        super(t), this.validate(), this.weights = de(this.width, this.height), this.deltas = D(this.width, this.height)
                    }
                }

                function ge(t) {
                    return new me(t)
                }

                function fe(t) {
                    return h(t[this.thread.y][this.thread.x])
                }

                function ye(t) {
                    return h(t[this.thread.z][this.thread.y][this.thread.x])
                }

                function xe(t, e) {
                    return l(t[this.thread.y][this.thread.x], e[this.thread.y][this.thread.x])
                }

                function _e(t, e) {
                    return l(t[this.thread.z][this.thread.y][this.thread.x], e[this.thread.z][this.thread.y][this.thread.x])
                }
                class be extends C {
                    setupKernels() {
                        this.depth > 0 ? (this.predictKernel = _(ye, {
                            output: [this.width, this.height, this.depth],
                            functions: [h],
                            immutable: !0
                        }), this.compareKernel = _(_e, {
                            output: [this.width, this.height, this.depth],
                            functions: [l],
                            immutable: !0
                        })) : (this.predictKernel = _(fe, {
                            output: [this.width, this.height],
                            functions: [h],
                            immutable: !0
                        }), this.compareKernel = _(xe, {
                            output: [this.width, this.height],
                            functions: [l],
                            immutable: !0
                        }))
                    }
                    predict() {
                        w(this.weights), this.weights = this.predictKernel(this.inputLayer.weights)
                    }
                    compare() {
                        w(this.inputLayer.deltas), this.inputLayer.deltas = this.compareKernel(this.weights, this.deltas)
                    }
                }

                function we(t, e) {
                    return new be(t, e)
                }
                class Te extends V {
                    constructor(t) {
                        super(t), this.validate(), this.weights = D(this.width, this.height), this.deltas = D(this.width, this.height)
                    }
                    predict() {}
                    compare() {}
                }

                function ve(t) {
                    return new Te(t)
                }
                const Ee = {
                    weights: null
                };
                class Ae extends z {
                    constructor(t) {
                        super({
                            ...Ee,
                            ...t
                        }), this.reshapeInput = null, this.validate(), this.reshapeInput = null, this.deltas = D(this.width, this.height)
                    }
                    setupKernels() {
                        1 === this.width && (this.predict = this.predict1D, this.reshapeInput = _((function(t) {
                            return t[this.thread.y]
                        }), {
                            output: [1, this.height],
                            immutable: !0
                        }))
                    }
                    reuseKernels(t) {
                        this.reshapeInput = t.reshapeInput
                    }
                    predict(t) {
                        if ((Array.isArray(t) || t instanceof Float32Array) && "number" == typeof t[0] && t.length === this.height * this.width) w(this.weights), this.weights = function(t, n) {
                            return new e.Input(t, n)
                        }(t, [this.width, this.height]);
                        else {
                            if (!Array.isArray(t) || t.length !== this.height || !(Array.isArray(t[0]) || t[0] instanceof Float32Array) || t[0].length !== this.width) throw new Error("Inputs are not of sized correctly");
                            this.weights = T(t)
                        }
                    }
                    predict1D(t) {
                        this.weights && w(this.weights), this.reshapeInput ? this.weights = this.reshapeInput(t) : this.weights = t
                    }
                    compare() {}
                    learn() {}
                }

                function Ie(t) {
                    return p(t[this.thread.y][this.thread.x])
                }

                function Se(t) {
                    return p(t[this.thread.z][this.thread.y][this.thread.x])
                }

                function ke(t, e) {
                    return d(t[this.thread.y][this.thread.x], e[this.thread.y][this.thread.x])
                }

                function De(t, e) {
                    return d(t[this.thread.z][this.thread.y][this.thread.x], e[this.thread.z][this.thread.y][this.thread.x])
                }
                class Le extends C {
                    setupKernels() {
                        const {
                            width: t,
                            height: e,
                            depth: n
                        } = this.inputLayer;
                        this.depth > 0 ? (this.predictKernel = _(Se, {
                            output: [t, e, n],
                            functions: [p],
                            immutable: !0
                        }), this.compareKernel = _(De, {
                            output: [t, e, n],
                            functions: [d],
                            immutable: !0
                        })) : (this.predictKernel = _(Ie, {
                            output: [t, e],
                            functions: [p],
                            immutable: !0
                        }), this.compareKernel = _(ke, {
                            output: [t, e],
                            functions: [d],
                            immutable: !0
                        }))
                    }
                    predict() {
                        w(this.weights), this.weights = this.predictKernel(this.inputLayer.weights)
                    }
                    compare() {
                        const {
                            deltas: t
                        } = this;
                        this.deltas = this.compareKernel(this.weights, t), w(t)
                    }
                }

                function Ce(t) {
                    return t
                }

                function Me(t) {
                    return t
                }

                function Oe(t) {
                    const e = this.constants.paddingX - this.thread.x * this.constants.strideX,
                        n = this.thread.x * this.constants.strideX - this.constants.paddingX,
                        i = Math.min(this.constants.filterWidth, e + this.constants.inputWidth),
                        s = this.constants.paddingY - this.thread.y * this.constants.strideY,
                        r = this.thread.y * this.constants.strideY - this.constants.paddingY,
                        a = Math.min(this.constants.filterHeight, s + this.constants.inputHeight);
                    let o = -99999;
                    for (let u = Math.max(0, s), h = Math.max(0, r); u < a; u++, h++)
                        for (let s = Math.max(0, e), r = Math.max(0, n); s < i; s++, r++)
                            if (h >= 0 && h < this.constants.inputHeight && r >= 0 && r < this.constants.inputWidth) {
                                const e = t[this.thread.z][h][r];
                                e > o && (o = e)
                            } return o
                }

                function Re(t, e, n) {
                    const i = Math.floor(this.thread.x / this.output.x * this.constants.outputWidth),
                        s = Math.floor(this.thread.y / this.output.y * this.constants.outputHeight);
                    let r = 0;
                    for (let a = 0; a < this.constants.inputHeight; a++)
                        for (let o = 0; o < this.constants.inputWidth; o++) {
                            const u = n[a][o],
                                h = e[a][o];
                            u === i && h === s && (r += t[a][o])
                        }
                    return r
                }
                const Ne = {
                    padding: 0,
                    stride: 0,
                    filterWidth: 0,
                    filterHeight: 0,
                    filterCount: 0
                };
                class Pe extends M {
                    constructor(t, e) {
                        super(t, e), this.predictKernelMap = null, this.settings = {
                            ...t,
                            ...Pt(t, Ne),
                            ...$t(t, Ne)
                        }, this.weights = wt(this.width, this.height, this.depth), this.deltas = L(this.width, this.height, this.depth), this.filters = wt(this.filterWidth, this.filterHeight, this.filterCount), this.filterDeltas = L(this.filterWidth, this.filterHeight, this.filterCount), this.validate()
                    }
                    get strideX() {
                        return this.settings.strideX
                    }
                    get strideY() {
                        return this.settings.strideY
                    }
                    get paddingX() {
                        return this.settings.paddingX
                    }
                    get paddingY() {
                        return this.settings.paddingY
                    }
                    get width() {
                        return Math.floor((this.inputLayer.width + 2 * this.paddingX - this.filterWidth) / this.strideX + 1)
                    }
                    get height() {
                        return Math.floor((this.inputLayer.height + 2 * this.paddingY - this.filterHeight) / this.strideY + 1)
                    }
                    get depth() {
                        return this.settings.filterCount
                    }
                    get filterCount() {
                        return this.settings.filterCount
                    }
                    get switchX() {
                        return this.settings.switchX
                    }
                    set switchX(t) {
                        this.settings.switchX = t
                    }
                    get switchY() {
                        return this.settings.switchY
                    }
                    set switchY(t) {
                        this.settings.switchY = t
                    }
                    setupKernels() {
                        this.predictKernelMap = b({
                            switchX: Me,
                            switchY: Ce
                        }, Oe, {
                            output: [this.width, this.height, this.depth],
                            constants: {
                                inputWidth: this.inputLayer.width,
                                inputHeight: this.inputLayer.height,
                                paddingX: this.paddingX,
                                paddingY: this.paddingY,
                                filterHeight: this.filterHeight,
                                filterWidth: this.filterWidth
                            }
                        }), this.compareKernel = _(Re, {
                            output: [this.inputLayer.width, this.inputLayer.height, this.inputLayer.depth],
                            constants: {
                                inputWidth: this.inputLayer.width,
                                inputHeight: this.inputLayer.height,
                                outputWidth: this.width,
                                outputHeight: this.height
                            }
                        })
                    }
                    predict() {
                        const {
                            result: t,
                            switchX: e,
                            switchY: n
                        } = this.predictKernelMap(this.inputLayer.weights);
                        this.switchX = e, this.switchY = n, this.weights = t
                    }
                    compare() {
                        const t = this.inputLayer.deltas;
                        this.inputLayer.deltas = this.compareKernel(this.deltas, this.switchX, this.switchY), w(t)
                    }
                }
                class $e extends O {
                    constructor(t) {
                        super(), this.praxis = null, this.predictKernel = null, this.compareKernel = null, this.settings = {}, this.recurrentInput = t, this.validate()
                    }
                    get width() {
                        return this.recurrentInput.width
                    }
                    get height() {
                        return this.recurrentInput.height
                    }
                    get depth() {
                        return this.recurrentInput.depth
                    }
                    get deltas() {
                        return this.recurrentInput.deltas
                    }
                    set deltas(t) {
                        const e = this.recurrentInput.deltas;
                        this.recurrentInput.deltas = t, w(e)
                    }
                    get weights() {
                        return this.recurrentInput.weights
                    }
                    set weights(t) {
                        const e = this.recurrentInput.weights;
                        this.recurrentInput.weights = t, w(e)
                    }
                    validate() {
                        if (I.prototype.validate.call(this), this.width !== this.recurrentInput.width) throw new Error(`${this.constructor.name} layer width ${this.width} and ${this.recurrentInput.constructor.name} width (${this.recurrentInput.width}) are not same`);
                        if (this.height !== this.recurrentInput.height) throw new Error(`${this.constructor.name} layer height ${this.height} and ${this.recurrentInput.constructor.name} width (${this.recurrentInput.height}) are not same`)
                    }
                    setDimensions(t, e) {
                        this.recurrentInput.width = t, this.recurrentInput.height = e
                    }
                    predict() {}
                    compare() {}
                    learn() {}
                    setupKernels() {}
                    reuseKernels() {}
                }
                class Ue extends O {
                    constructor(t) {
                        super(), this.praxis = null, this.settings = {}, this.predictKernel = null, this.compareKernel = null, t && (this.settings = {
                            ...t
                        })
                    }
                    setDimensions(t, e) {
                        this.praxis = null, this.settings = {
                            ...this.settings,
                            width: t,
                            height: e,
                            weights: D(t, e),
                            deltas: D(t, e)
                        }
                    }
                    setupKernels() {}
                    reuseKernels() {}
                    predict() {}
                    compare() {}
                    learn(t) {
                        const {
                            weights: e
                        } = this;
                        this.weights = this.praxis.run(this, t), w(e)
                    }
                }

                function Fe() {
                    return new Ue
                }

                function Be(t) {
                    return i(t[this.thread.y][this.thread.x])
                }

                function ze(t, e) {
                    return s(t[this.thread.y][this.thread.x], e[this.thread.y][this.thread.x])
                }

                function Ve(t) {
                    return i(t[this.thread.z][this.thread.y][this.thread.x])
                }

                function Ke(t, e) {
                    return s(t[this.thread.z][this.thread.y][this.thread.x], e[this.thread.z][this.thread.y][this.thread.x])
                }
                class Ge extends C {
                    setupKernels() {
                        const {
                            width: t,
                            height: e,
                            depth: n
                        } = this.inputLayer;
                        n > 0 ? (this.predictKernel = _(Ve, {
                            output: [t, e, n],
                            functions: [i],
                            immutable: !0
                        }), this.compareKernel = _(Ke, {
                            output: [t, e, n],
                            functions: [s],
                            immutable: !0
                        })) : (this.predictKernel = _(Be, {
                            output: [t, e],
                            functions: [i],
                            immutable: !0
                        }), this.compareKernel = _(ze, {
                            output: [t, e],
                            functions: [s],
                            immutable: !0
                        }))
                    }
                    predict() {
                        w(this.weights), this.weights = this.predictKernel(this.inputLayer.weights)
                    }
                    compare() {
                        w(this.inputLayer.deltas), this.inputLayer.deltas = this.compareKernel(this.weights, this.deltas)
                    }
                }

                function je(t, e) {
                    return new Ge(t, e)
                }
                class We extends I {
                    constructor(t, e) {
                        super(t), this.inputLayer = e, this.validate()
                    }
                    predict() {
                        w(this.weights), this.weights = T(this.inputLayer.weights)
                    }
                    learn() {}
                }

                function He(t) {
                    let e = -1 / 0;
                    for (let n = 0; n < this.constants.inputHeight; n++)
                        for (let i = 0; i < this.constants.inputWidth; i++) {
                            const s = t[n][i];
                            s > e && (e = s)
                        }
                    return e
                }

                function Xe(t) {
                    let e = -1 / 0;
                    for (let n = 0; n < this.constants.inputDepth; n++)
                        for (let i = 0; i < this.constants.inputHeight; i++)
                            for (let s = 0; s < this.constants.inputWidth; s++) {
                                const r = t[n][i][s];
                                r > e && (e = r)
                            }
                    return e
                }

                function Ze(t) {
                    let e = 0;
                    for (let n = 0; n < this.constants.inputHeight; n++)
                        for (let i = 0; i < this.constants.inputWidth; i++) e += t[n][i];
                    return e
                }

                function qe(t) {
                    let e = 0;
                    for (let n = 0; n < this.constants.inputDepth; n++)
                        for (let i = 0; i < this.constants.inputHeight; i++)
                            for (let s = 0; s < this.constants.inputWidth; s++) e += t[n][i][s];
                    return e
                }

                function Ye(t, e) {
                    return Math.exp(t[this.thread.x] - e[0])
                }

                function Je(t, e) {
                    return Math.exp(t[this.thread.z][this.thread.y][this.thread.x] - e[0])
                }

                function Qe(t, e) {
                    return t[this.thread.y][this.thread.x] / e[0]
                }

                function tn(t, e) {
                    return t[this.thread.z][this.thread.y][this.thread.x] / e[0]
                }

                function en(t, e) {
                    let n = 0;
                    return this.thread.x + this.thread.y * this.output.x === t && (n = 1), -(n - e[this.thread.y][this.thread.x])
                }

                function nn(t, e) {
                    let n = 0;
                    return this.thread.x + this.thread.y * this.output.x + this.thread.z * this.output.x * this.output.y === t && (n = 1), -(n - e[this.thread.z][this.thread.y][this.thread.x])
                }
                class sn extends R {
                    constructor(t, e) {
                        super(t, e), this.errors = null, this.getExponentialsKernel = null, this.getMaxValueKernel = null, this.getSumKernel = null, this.validate(), this.depth > 0 ? (this.weights = wt(this.width, this.height, this.depth), this.deltas = L(this.width, this.height, this.depth)) : this.height > 0 ? (this.weights = bt(this.width, this.height), this.deltas = D(this.width, this.height)) : (this.weights = _t(this.width), this.deltas = k(this.width))
                    }
                    setupKernels() {
                        const {
                            width: t,
                            height: e,
                            depth: n
                        } = this;
                        n > 0 ? (this.getExponentialsKernel = _(Je, {
                            output: [t, e, n]
                        }), this.getMaxValueKernel = _(Xe, {
                            output: [1, 1, 1],
                            constants: {
                                inputWidth: t,
                                inputHeight: e,
                                inputDepth: n
                            }
                        }), this.getSumKernel = _(qe, {
                            output: [1, 1, 1],
                            constants: {
                                inputWidth: t,
                                inputHeight: e,
                                inputDepth: n
                            }
                        }), this.predictKernel = _(tn, {
                            output: [t, e, n]
                        }), this.compareKernel = _(nn, {
                            output: [t, e, n],
                            immutable: !0
                        })) : (this.getExponentialsKernel = _(Ye, {
                            output: [t, e]
                        }), this.getMaxValueKernel = _(He, {
                            output: [1, 1],
                            constants: {
                                inputWidth: t,
                                inputHeight: e
                            }
                        }), this.getSumKernel = _(Ze, {
                            output: [1, 1],
                            constants: {
                                inputWidth: t,
                                inputHeight: e
                            }
                        }), this.predictKernel = _(Qe, {
                            output: [t, e]
                        }), this.compareKernel = _(en, {
                            output: [t, e],
                            immutable: !0
                        }))
                    }
                    predict() {
                        const t = this.getMaxValueKernel(this.inputLayer.weights),
                            e = this.getExponentialsKernel(this.inputLayer.weights, t),
                            n = this.getSumKernel(e);
                        this.weights = this.predictKernel(e, n)
                    }
                    compare(t) {
                        const {
                            deltas: e,
                            errors: n
                        } = this;
                        this.errors = this.compareKernel(t[0], e), this.deltas = T(this.errors), w(e), w(n);
                        const i = this.inputLayer.deltas;
                        this.inputLayer.deltas = T(this.deltas), w(i)
                    }
                }
                class rn extends I {
                    constructor(t, e) {
                        super(e), this.inputLayer = t
                    }
                    predict() {
                        w(this.weights), this.weights = T(this.inputLayer.weights), this.validate()
                    }
                    learn() {}
                }

                function an(t) {
                    return t[this.thread.x][this.thread.y]
                }
                const on = an;
                class un extends R {
                    get width() {
                        return this.inputLayer.height
                    }
                    get height() {
                        return this.inputLayer.width
                    }
                    constructor(t) {
                        super(t), this.validate()
                    }
                    setupKernels() {
                        this.predictKernel = _(an, {
                            output: [this.height, this.width]
                        }), this.compareKernel = _(on, {
                            output: [this.width, this.height]
                        })
                    }
                    predict() {
                        this.weights = this.predictKernel(this.inputLayer.weights)
                    }
                    compare() {
                        this.inputLayer.deltas = this.compareKernel(this.deltas)
                    }
                }
                const hn = {
                    Activation: C,
                    Internal: O,
                    InternalModel: B,
                    EntryPoint: z,
                    Filter: M,
                    Model: V,
                    Modifier: R,
                    Operator: N,
                    Target: U
                };
                var ln = Object.freeze({
                    __proto__: null,
                    layerTypes: hn,
                    Add: dt,
                    add: mt,
                    arthurFeedForward: function(t, e) {
                        const {
                            height: n
                        } = t, i = Et({
                            id: "weights",
                            height: n,
                            width: e.height,
                            initPraxis: function(t, e) {
                                const n = Q(t, e);
                                return n.setupKernels(), n
                            }
                        }), s = Et({
                            id: "biases",
                            height: n,
                            initPraxis: function(t, e) {
                                const n = X(t, e);
                                return n.setupKernels(), n
                            }
                        }), r = Nt(mt(Dt(i, e), s)), a = i.praxis;
                        return a.weightsLayer = i, a.incomingLayer = e, a.deltaLayer = r, r
                    },
                    BaseLayer: I,
                    baseLayerDefaultSettings: A,
                    Convolution: Gt,
                    convolution: function(t, e) {
                        return new Gt(t, e)
                    },
                    Dropout: qt,
                    dropout: function(t, e) {
                        return new qt(t, e)
                    },
                    feedForward: function(t, e) {
                        const {
                            height: n,
                            praxisOpts: i = null
                        } = t, s = Et({
                            id: "weights",
                            height: n,
                            width: e.height,
                            praxisOpts: i
                        }), r = Et({
                            id: "biases",
                            height: n,
                            praxisOpts: i
                        });
                        return Nt(mt(Dt(s, e, {
                            praxisOpts: i
                        }), r, {
                            praxisOpts: i
                        }), {
                            praxisOpts: i
                        })
                    },
                    FullyConnected: se,
                    fullyConnected: function(t, e) {
                        return new se(t, e)
                    },
                    gru: function(t, e, n) {
                        const {
                            height: i
                        } = t, s = Et({
                            height: i,
                            width: n.height
                        }), r = Et({
                            width: i,
                            height: i
                        }), a = ve({
                            height: i
                        }), o = Nt(mt(mt(Dt(s, n), Dt(r, e)), a)), u = Et({
                            height: i,
                            width: n.height
                        }), h = Et({
                            width: i,
                            height: i
                        }), l = ve({
                            height: i
                        }), c = Nt(mt(mt(Dt(u, n), Dt(h, e)), l)), p = Et({
                            height: i,
                            width: n.height
                        }), d = Et({
                            width: i,
                            height: i
                        }), m = ve({
                            height: i
                        }), g = we(mt(mt(Dt(p, n), Dt(d, ce(c, e))), m));
                        return mt(ce(mt(ge({
                            width: o.width,
                            height: o.height
                        }), oe(o)), g), ce(e, o))
                    },
                    Input: Ae,
                    input: function(t) {
                        return new Ae(t)
                    },
                    LeakyRelu: Le,
                    leakyRelu: function(t, e) {
                        return new Le(t, e)
                    },
                    lstmCell: function(t, e, n) {
                        const {
                            height: i
                        } = t;
                        if ("number" != typeof i) throw new Error("no settings.height given");
                        n.setDimensions && n.setDimensions(1, i);
                        const s = Et({
                                width: e.height,
                                height: i,
                                std: .08,
                                id: "inputGateWeights"
                            }),
                            r = Et({
                                width: i,
                                height: i,
                                std: .08,
                                id: "inputGatePeepholes"
                            }),
                            a = ve({
                                width: 1,
                                height: i,
                                id: "inputGateBias"
                            }),
                            o = Nt(mt(mt(Dt(s, e), Dt(r, n)), a), {
                                id: "inputGate"
                            }),
                            u = Et({
                                width: e.height,
                                height: i,
                                std: .08,
                                id: "forgetGateWeights"
                            }),
                            h = Et({
                                width: i,
                                height: i,
                                std: .08,
                                id: "forgetGatePeepholes"
                            }),
                            l = ve({
                                width: 1,
                                height: i,
                                id: "forgetGateBias"
                            }),
                            c = Nt(mt(mt(Dt(u, e), Dt(h, n)), l), {
                                id: "forgetGate"
                            }),
                            p = Et({
                                width: e.height,
                                height: i,
                                std: .08,
                                id: "outputGateWeights"
                            }),
                            d = Et({
                                width: i,
                                height: i,
                                std: .08,
                                id: "outputGatePeepholes"
                            }),
                            m = ve({
                                width: 1,
                                height: i,
                                id: "outputGateBias"
                            }),
                            g = Nt(mt(mt(Dt(p, e), Dt(d, n)), m), {
                                id: "outputGate"
                            }),
                            f = Et({
                                width: e.height,
                                height: i,
                                std: .08,
                                id: "memoryWeights"
                            }),
                            y = Et({
                                width: i,
                                height: i,
                                std: .08,
                                id: "memoryPeepholes"
                            }),
                            x = ve({
                                width: 1,
                                height: i,
                                id: "memoryBias"
                            }),
                            _ = we(mt(mt(Dt(f, e), Dt(y, n)), x), {
                                id: "memory"
                            }),
                            b = ce(c, n, {
                                id: "retainCell"
                            }),
                            w = ce(o, _, {
                                id: "writeCell"
                            });
                        return ce(g, we(mt(b, w, {
                            id: "cell"
                        })), {
                            id: "activations"
                        })
                    },
                    Multiply: kt,
                    multiply: Dt,
                    MultiplyElement: le,
                    multiplyElement: ce,
                    Negative: ae,
                    negative: oe,
                    Ones: me,
                    ones: ge,
                    output: function(t, e) {
                        const {
                            height: n
                        } = t, i = Et({
                            height: n,
                            width: e.height,
                            id: "outputGate",
                            std: .08
                        }), s = Et({
                            height: n,
                            id: "output",
                            std: .08
                        }), r = Dt(i, e, {
                            id: "outputGateConnected"
                        });
                        return F({
                            id: "target",
                            ...t
                        }, mt(r, s))
                    },
                    Pool: Pe,
                    pool: function(t, e) {
                        return new Pe(t, e)
                    },
                    Random: vt,
                    random: Et,
                    RecurrentInput: $e,
                    RecurrentZeros: Ue,
                    rnnCell: function(t, e, n) {
                        const {
                            height: i
                        } = t;
                        if ("number" != typeof i) throw new Error("height not set");
                        n.setDimensions && n.setDimensions(1, i);
                        const s = Et({
                                id: "weight",
                                height: i,
                                width: e.height,
                                std: .08
                            }),
                            r = Et({
                                id: "transition",
                                height: i,
                                width: i,
                                std: .08
                            }),
                            a = ve({
                                id: "bias",
                                height: i
                            });
                        return je(mt(mt(Dt(s, e), Dt(r, n)), a))
                    },
                    Regression: We,
                    regression: function(t, e) {
                        return new We(t, e)
                    },
                    Relu: Ge,
                    relu: je,
                    Sigmoid: Rt,
                    sigmoid: Nt,
                    SoftMax: sn,
                    softMax: function(t, e) {
                        return new sn(t, e)
                    },
                    SVM: rn,
                    svm: function(t, e) {
                        return new rn(t, e)
                    },
                    Tanh: be,
                    tanh: we,
                    Target: U,
                    target: F,
                    Transpose: un,
                    transpose: function(t) {
                        return new un(t)
                    },
                    Zeros: Te,
                    zeros: ve
                });
                const cn = Object.keys(ln);

                function pn(t, e, n) {
                    if (!cn.find((e => e === t.type))) return null;
                    const i = ln[t.type];
                    if (i.prototype instanceof hn.Filter) {
                        if (!e) throw new Error("inputLayer missing");
                        return new i(t, e)
                    }
                    if (i.prototype instanceof hn.Activation || i.prototype instanceof hn.Modifier) {
                        if (!e) throw new Error("inputLayer missing");
                        return new i(e, t)
                    }
                    if (i.prototype instanceof hn.Internal) return new i(t);
                    if (i.prototype instanceof hn.Operator) {
                        if (!e) throw new Error("inputLayer1 missing");
                        if (!n) throw new Error("inputLayer2 missing");
                        return new i(e, n, t)
                    }
                    if (i.prototype instanceof hn.InternalModel || i.prototype instanceof hn.EntryPoint || i.prototype instanceof hn.Model) return new i(t);
                    if (i === U) {
                        if (!e) throw new Error("inputLayer missing");
                        return new i(t, e)
                    }
                    return null
                }
                class dn {
                    constructor(t, e) {
                        this.prop = null, this.table = {}, this.length = 0;
                        const n = this.table;
                        if (e) {
                            this.prop = e;
                            for (let i = 0; i < t.length; i++) {
                                const s = t[i][e];
                                for (const t in s) s.hasOwnProperty(t) && (n.hasOwnProperty(t) || (n[t] = this.length++))
                            }
                        } else if (Array.isArray(t) && Array.isArray(t[0]))
                            for (let e = 0; e < t.length; e++) {
                                const i = t[e];
                                for (let t = 0; t < i.length; t++) {
                                    const e = i[t];
                                    for (const t in e) e.hasOwnProperty(t) && (n.hasOwnProperty(t) || (n[t] = this.length++))
                                }
                            } else
                                for (let e = 0; e < t.length; e++) {
                                    const i = t[e];
                                    for (const t in i) i.hasOwnProperty(t) && (n.hasOwnProperty(t) || (n[t] = this.length++))
                                }
                    }
                }
                var mn = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : void 0 !== n.g ? n.g : "undefined" != typeof self ? self : {};
                var gn, fn, yn, xn = (gn = function(t, e) {
                    var n = mn && mn.__assign || function() {
                        return n = Object.assign || function(t) {
                            for (var e, n = 1, i = arguments.length; n < i; n++)
                                for (var s in e = arguments[n]) Object.prototype.hasOwnProperty.call(e, s) && (t[s] = e[s]);
                            return t
                        }, n.apply(this, arguments)
                    };
                    Object.defineProperty(e, "__esModule", {
                        value: !0
                    }), e.thaw = e.Block = e.Thaw = void 0;
                    var i = function() {
                        function t(e, i) {
                            var s = this;
                            void 0 === i && (i = {});
                            var r = n(n({}, t.defaultSettings), i),
                                a = r.each,
                                o = r.done;
                            this.i = 0, this.isStopped = !1, this.items = e, this.options = i, this.tick = function() {
                                if (!s.isStopped && (s.timeout = setTimeout(s.tick, 0), !t.thawing)) {
                                    var e = s.items[s.i];
                                    if (s.i >= s.items.length) return null !== o && (t.thawing = !0, o(), t.thawing = !1), s.isStopped = !0, void clearTimeout(s.timeout);
                                    null !== a ? (t.thawing = !0, a(e, s.i), t.thawing = !1) : void 0 !== e && e(), s.i++
                                }
                            }, t.thaws.push(this), i.delay || this.tick()
                        }
                        return Object.defineProperty(t, "isThawing", {
                            get: function() {
                                return t.thawing
                            },
                            enumerable: !1,
                            configurable: !0
                        }), t.stopAll = function() {
                            for (var e = 0; e < t.thaws.length; e++) t.thaws[e].stop()
                        }, t.prototype.makeReady = function() {
                            return !!this.isStopped && (this.isStopped = !1, !0)
                        }, t.prototype.add = function(t) {
                            return this.items.push(t), this.makeReady() && this.tick(), this
                        }, t.prototype.insert = function(t) {
                            return this.items.splice(this.i, 0, t), this.makeReady() && this.tick(), this
                        }, t.prototype.addArray = function(t) {
                            return this.items = this.items.concat(t), this.makeReady() && this.tick(), this
                        }, t.prototype.insertArray = function(t) {
                            var e = this.items.splice(0, this.i),
                                n = this.items;
                            return this.items = e.concat(t, n), this.makeReady() && this.tick(), this
                        }, t.prototype.stop = function() {
                            return this.isStopped = !0, clearTimeout(this.timeout), this.options.done && this.options.done(), this
                        }, t.thawing = !1, t.thaws = [], t.defaultSettings = {
                            each: null,
                            done: null
                        }, t
                    }();

                    function s(t, e) {
                        return new i(t, e)
                    }
                    e.Thaw = i, e.thaw = s;
                    var r = function() {
                        function t(t, e) {
                            void 0 === e && (e = 200), this.index = 0, this.thaws = [], this.count = e, this.options = t
                        }
                        return t.prototype.add = function(t) {
                            return this.next().add(t), this
                        }, t.prototype.addArray = function(t) {
                            return this.next().addArray(t), this
                        }, t.prototype.insert = function(t) {
                            return this.next().insert(t), this
                        }, t.prototype.insertArray = function(t) {
                            return this.next().insertArray(t), this
                        }, t.prototype.stop = function() {
                            for (var t = 0; t < this.thaws.length; t++) this.thaws[t].stop();
                            return this
                        }, t.prototype.next = function() {
                            var t, e = this.thaws;
                            return e.length < this.count ? (t = new i([], this.options), e.push(t)) : t = e[this.index] || null, this.index++, this.index >= this.count && (this.index = 0), t
                        }, t
                    }();
                    e.Block = r, "undefined" != typeof window && (window.Thaw = i, window.thaw = s, window.Thaw.Block = r)
                }, gn(yn = {
                    path: fn,
                    exports: {},
                    require: function(t, e) {
                        return function() {
                            throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs")
                        }(null == e && yn.path)
                    }
                }, yn.exports), yn.exports);
                const _n = {
                        learningRate: .3,
                        binaryThresh: .5,
                        initPraxis: (t, e) => {
                            var n;
                            return rt(t, null !== (n = t.settings.praxisOpts) && void 0 !== n ? n : e)
                        }
                    },
                    bn = {
                        iterations: 2e4,
                        errorThresh: .005,
                        log: !1,
                        logPeriod: 10,
                        learningRate: .3,
                        callbackPeriod: 10,
                        errorCheckInterval: 100,
                        timeout: 1 / 0
                    };
                class wn {
                    constructor(t = {}) {
                        this.trainOpts = {}, this.layers = null, this._inputLayer = null, this._hiddenLayers = null, this._outputLayer = null, this._model = null, this.meanSquaredError = null, this.inputLookup = null, this.inputLookupLength = null, this.outputLookup = null, this.outputLookupLength = null, this.options = {
                            ..._n,
                            ...t
                        }, this._updateTrainingOptions({
                            ...bn,
                            ...t
                        })
                    }
                    static _validateTrainingOptions(t) {
                        const {
                            iterations: e,
                            errorThresh: n,
                            log: i,
                            logPeriod: s,
                            learningRate: r,
                            callback: a,
                            callbackPeriod: o,
                            timeout: u
                        } = t, h = {
                            iterations: () => "number" == typeof e && e > 0,
                            errorThresh: () => "number" == typeof n && n > 0 && n < 1,
                            log: () => "function" == typeof i || "boolean" == typeof i,
                            logPeriod: () => "number" == typeof s && s > 0,
                            learningRate: () => "number" == typeof r && r > 0 && r < 1,
                            callback: () => "function" == typeof a || null === a,
                            callbackPeriod: () => "number" == typeof o && o > 0,
                            timeout: () => "number" == typeof u && u > 0
                        };
                        Object.keys(bn).forEach((e => {
                            if (h.hasOwnProperty(e) && !h[e]()) {
                                const n = t[e];
                                throw new Error(`[${e}, ${(null!=n?n:"undefined").toString()}] is out of normal training range, your network will probably not train.`)
                            }
                        }))
                    }
                    _setLogMethod(t) {
                        this.trainOpts.log = "function" == typeof t ? t : !!t && console.log
                    }
                    _updateTrainingOptions(t) {
                        var e;
                        this.trainOpts = {
                            ...bn,
                            ...this.trainOpts,
                            ...t
                        }, wn._validateTrainingOptions(this.trainOpts), this._setLogMethod(null !== (e = t.log) && void 0 !== e ? e : this.trainOpts.log);
                        const {
                            callback: n,
                            callbackPeriod: i,
                            errorCheckInterval: s
                        } = this.trainOpts;
                        n && i !== s && console.warn(`options.callbackPeriod with value of ${(null!=i?i:"undefined").toString()} does not match options.errorCheckInterval with value of ${(null!=s?s:"undefined").toString()}, if logging error, it will repeat.  These values may need to match`)
                    }
                    _connectOptionsLayers() {
                        const {
                            inputLayerIndex: t,
                            outputLayerIndex: e,
                            layers: n
                        } = this.options;
                        if (!n) throw new Error("this.options.layers in unexpected state");
                        if ("number" != typeof t) throw new Error("inputLayerIndex not a number");
                        if ("number" != typeof e) throw new Error("inputLayerIndex not a number");
                        const i = n[t];
                        if (!i) throw new Error("inputLayer not found in this.options.layers");
                        const s = n[e];
                        if (!s) throw new Error("outputLayer not found in this.options.layers");
                        return this._inputLayer = i, this._hiddenLayers = n.slice(t, e - t), this._outputLayer = s, n
                    }
                    _connectNewLayers() {
                        const {
                            inputLayer: t,
                            outputLayer: e
                        } = this.options;
                        if (!t) throw new Error("inputLayer not defined");
                        const n = [];
                        this._inputLayer = t();
                        const i = this._connectHiddenLayers(this._inputLayer);
                        if (!e) throw new Error("outputLayer not defined");
                        return this._outputLayer = e(i[i.length - 1], i.length), n.push(this._inputLayer), n.push(...i), n.push(this._outputLayer), lt(n)
                    }
                    _connectHiddenLayers(t) {
                        this._hiddenLayers = [];
                        const e = [],
                            {
                                hiddenLayers: n
                            } = this.options;
                        if (!n) throw new Error("hiddenLayers not defined");
                        for (let i = 0; i < n.length; i++) {
                            const s = n[i](t, i);
                            e.push(s), this._hiddenLayers.push(s), t = s
                        }
                        return e
                    }
                    initialize() {
                        this.layers = this.options.layers ? this._connectOptionsLayers() : this._connectNewLayers(), this.initializeLayers(this.layers), this._model = this.layers.filter((t => t instanceof V))
                    }
                    initializeLayers(t) {
                        var e, n;
                        for (let i = 0; i < t.length; i++) {
                            const s = t[i];
                            s.setupKernels(!0), s instanceof V && null === s.praxis && "function" == typeof this.options.initPraxis && (s.praxis = this.options.initPraxis(s, null !== (n = null !== (e = s.settings.praxisOpts) && void 0 !== e ? e : this.options.praxisOpts) && void 0 !== n ? n : {}), s.praxis.setupKernels())
                        }
                        const i = t[t.length - 1];
                        this.meanSquaredError = new E({
                            width: i.width,
                            height: i.height
                        })
                    }
                    run(t) {
                        let n;
                        if (Array.isArray(t) || t.buffer) n = t;
                        else {
                            if (!this.inputLookup) throw new Error("input is incompatible with net");
                            n = K.toArray(this.inputLookup, t, this.inputLookupLength)
                        }
                        let i = this.runInput(n);
                        return i instanceof e.Texture && (i = i.toArray()), this.outputLookup ? K.toObject(this.outputLookup, i) : i
                    }
                    runInput(t) {
                        if (!this.layers) throw new Error("not initialized");
                        this.layers[0].predict(t);
                        for (let t = 1; t < this.layers.length; t++) this.layers[t].predict();
                        return this.layers[this.layers.length - 1].weights
                    }
                    train(t, e = {}) {
                        const {
                            preparedData: n,
                            status: i,
                            endTime: s
                        } = this._prepTraining(t, e);
                        let r = !0;
                        const a = () => this._calculateTrainingError(n),
                            o = () => this._trainPatterns(n);
                        for (; r;) r = this._trainingTick(i, s, a, o);
                        return i
                    }
                    async trainAsync(t, e = {}) {
                        const {
                            preparedData: n,
                            status: i,
                            endTime: s
                        } = this._prepTraining(t, e);
                        return await new Promise(((t, e) => {
                            try {
                                const e = () => this._calculateTrainingError(n),
                                    r = () => this._trainPatterns(n),
                                    a = new xn.Thaw(new Array(this.trainOpts.iterations), {
                                        delay: !0,
                                        each: () => this._trainingTick(i, s, e, r) || a.stop(),
                                        done: () => t(i)
                                    });
                                a.tick()
                            } catch (t) {
                                e(t)
                            }
                        }))
                    }
                    _trainingTick(t, e, n, i) {
                        const {
                            trainOpts: s
                        } = this;
                        return !(t.iterations >= s.iterations || t.error <= s.errorThresh || Date.now() >= e || ("function" == typeof s.log && t.iterations % s.logPeriod == 0 ? (t.error = n(), s.log(`iterations: ${t.iterations}, training error: ${t.error}`)) : t.iterations % s.errorCheckInterval == 0 ? t.error = n() : i(), s.callback && t.iterations % s.callbackPeriod == 0 && s.callback(Object.assign(t)), t.iterations++, 0))
                    }
                    _prepTraining(t, e) {
                        this._updateTrainingOptions(e);
                        const n = this.formatData(t),
                            i = this.trainOpts.timeout ? Date.now() + this.trainOpts.timeout : 0;
                        return this.verifyIsInitialized(), {
                            preparedData: this.transferData(n),
                            status: {
                                error: 1,
                                iterations: 0
                            },
                            endTime: i
                        }
                    }
                    verifyIsInitialized() {
                        this._model || this.initialize()
                    }
                    _calculateTrainingError(t) {
                        let n = new Float32Array([0]);
                        const i = this.meanSquaredError;
                        for (let e = 0; e < t.length; ++e) {
                            const s = n,
                                r = this._trainPattern(t[e].input, t[e].output, !0);
                            n = i.add(n, r), w(r), w(s)
                        }
                        const s = i.divide(t.length, n);
                        if (w(n), s instanceof e.Texture) {
                            const t = s.toArray();
                            return w(s), t[0]
                        }
                        return s[0]
                    }
                    _trainPatterns(t) {
                        for (let e = 0; e < t.length; ++e) this._trainPattern(t[e].input, t[e].output, !1)
                    }
                    _trainPattern(t, e, n) {
                        var i;
                        if (this.runInput(t), this._calculateDeltas(e), this.adjustWeights(), n) {
                            if (!(null === (i = this._outputLayer) || void 0 === i ? void 0 : i.errors)) throw new Error("outputLayer.errors not defined");
                            return this.meanSquaredError.calculate(this._outputLayer.errors)
                        }
                        return null
                    }
                    _calculateDeltas(t) {
                        const e = this.layers;
                        for (let n = e.length - 1; n > -1; n--) e[n].compare(t)
                    }
                    adjustWeights() {
                        const t = this._model;
                        for (let e = 0; e < t.length; e++) t[e].learn(this.trainOpts.learningRate)
                    }
                    formatData(t) {
                        if (!Array.isArray(t)) {
                            const e = [];
                            e.push(t), t = e
                        }
                        const e = t[0].input;
                        let n;
                        if (!Array.isArray(t) || Array.isArray(e) || e instanceof Float32Array) n = t;
                        else {
                            if (!this.inputLookup) {
                                const e = new dn(t, "input");
                                this.inputLookup = e.table, this.inputLookupLength = e.length
                            }
                            n = t.map((t => ({
                                input: K.toArray(this.inputLookup, t.input, this.inputLookupLength)
                            })), this)
                        }
                        const i = t[0].output;
                        if (!(Array.isArray(i) || i instanceof Float32Array)) {
                            if (!this.outputLookup) {
                                const e = new dn(t, "output");
                                this.outputLookup = e.table, this.outputLookupLength = e.length
                            }
                            n = t.map(((t, e) => {
                                const i = K.toArray(this.outputLookup, t.output, this.inputLookupLength);
                                return {
                                    input: n[e].input,
                                    output: i
                                }
                            }), this)
                        }
                        return n
                    }
                    transferData(t) {
                        const e = new Array(t.length),
                            n = _((function(t) {
                                return t[this.thread.x]
                            }), {
                                output: [t[0].input.length],
                                immutable: !0
                            }),
                            i = _((function(t) {
                                return t[this.thread.x]
                            }), {
                                output: [t[0].output.length],
                                immutable: !0
                            });
                        for (let s = 0; s < t.length; s++) {
                            const r = t[s];
                            e[s] = {
                                input: n(r.input),
                                output: i(r.output)
                            }
                        }
                        return e
                    }
                    test() {
                        throw new Error(`${this.constructor.name}-test is not yet implemented`)
                    }
                    toJSON() {
                        var t;
                        if (this.layers || this.initialize(), !(this._model && this.layers && this._inputLayer && this._hiddenLayers && this._outputLayer)) throw new Error("network is not initialized");
                        const e = [];
                        for (let t = 0; t < this.layers.length; t++) {
                            const n = this.layers[t],
                                i = n.toJSON();
                            n.hasOwnProperty("inputLayer") ? i.inputLayerIndex = this.layers.indexOf(n.inputLayer) : n.hasOwnProperty("inputLayer1") && n.hasOwnProperty("inputLayer2") && (i.inputLayer1Index = this.layers.indexOf(n.inputLayer1), i.inputLayer2Index = this.layers.indexOf(n.inputLayer2)), e.push(i)
                        }
                        return {
                            type: this.constructor.name,
                            sizes: null !== (t = this.options.sizes) && void 0 !== t ? t : [this._inputLayer.height].concat(this._hiddenLayers.map((t => t.height))).concat([this._outputLayer.height]),
                            outputLayerIndex: this.layers.indexOf(this._outputLayer),
                            layers: e,
                            inputLayerIndex: this.layers.indexOf(this._inputLayer)
                        }
                    }
                    static fromJSON(t, e) {
                        var n, i, s, r;
                        const a = t.layers,
                            o = [],
                            u = e ? null !== (n = pn(a[0])) && void 0 !== n ? n : e(a[0]) : pn(a[0]);
                        if (!u) throw new Error("unable to find layer");
                        o.push(u);
                        for (let t = 1; t < a.length; t++) {
                            const n = a[t];
                            if (void 0 === n.inputLayerIndex && void 0 === n.inputLayer1Index && void 0 === n.inputLayer2Index) {
                                const t = e ? null !== (i = pn(n)) && void 0 !== i ? i : e(n) : pn(n);
                                if (!t) throw new Error("unable to find layer");
                                o.push(t)
                            } else if ("number" == typeof n.inputLayerIndex) {
                                const t = o[n.inputLayerIndex];
                                if (!t) throw new Error("inputLayer1 not found");
                                const i = e ? null !== (s = pn(n, t)) && void 0 !== s ? s : e(n, t) : pn(n, t);
                                if (!i) throw new Error("unable to find layer");
                                o.push(i)
                            } else {
                                if ("number" != typeof n.inputLayer1Index) throw new Error("Cannot create network from provided JSON. inputLayer1Index not defined.");
                                if ("number" != typeof n.inputLayer2Index) throw new Error("Cannot create network from provided JSON. inputLayer2Index not defined.");
                                const t = o[n.inputLayer1Index],
                                    i = o[n.inputLayer2Index];
                                if (void 0 === t) throw new Error(`Cannot create network from provided JSON. layer of index ${n.inputLayer1Index} not found.`);
                                if (void 0 === i) throw new Error(`Cannot create network from provided JSON. layer of index ${n.inputLayer2Index} not found.`);
                                const s = e ? null !== (r = pn(n, t, i)) && void 0 !== r ? r : e(n, t, i) : pn(n, t, i);
                                if (!s) throw new Error("unable to find layer");
                                o.push(s)
                            }
                        }
                        return new this({
                            ...t,
                            layers: o
                        })
                    }
                    toFunction() {
                        throw new Error(`${this.constructor.name}-toFunction is not yet implemented`)
                    }
                    createTrainStream() {
                        throw new Error(`${this.constructor.name}-createTrainStream is not yet implemented`)
                    }
                }

                function Tn(t) {
                    const e = [];
                    for (let n = 0; n < t.length; n++) e.push(Float32Array.from(t[n]));
                    return e
                }

                function vn(t, e) {
                    const n = [];
                    for (let e = 0; e < t.length; e++) n.push(Float32Array.from(t[e]));
                    for (let t = 0; t < e.length; t++) n.push(Float32Array.from(e[t]));
                    return n
                }

                function En(t) {
                    const e = [];
                    for (let n = 0; n < t.length; n++) e.push(Float32Array.from([t[n]]));
                    return e
                }

                function An(t, e) {
                    const n = [];
                    for (let e = 0; e < t.length; e++) n.push(Float32Array.from([t[e]]));
                    for (let t = 0; t < e.length; t++) n.push(Float32Array.from([e[t]]));
                    return n
                }

                function In(t) {
                    return Float32Array.from(t)
                }

                function Sn(t, e, n, i, s, r) {
                    const a = [];
                    for (let e = 0; e < t.length; e++) {
                        const i = t[e],
                            r = new Float32Array(s);
                        for (const t in i) i.hasOwnProperty(t) && (r[n[t]] = i[t]);
                        a.push(r)
                    }
                    for (let t = 0; t < e.length; t++) {
                        const n = e[t],
                            s = new Float32Array(r);
                        for (const t in n) n.hasOwnProperty(t) && (s[i[t]] = n[t]);
                        a.push(s)
                    }
                    return a
                }

                function kn(t) {
                    const e = [];
                    for (const n in t) t.hasOwnProperty(n) && e.push(Float32Array.from([t[n]]));
                    return e
                }

                function Dn(t, e) {
                    const n = [];
                    for (const e in t) t.hasOwnProperty(e) && n.push(Float32Array.from([t[e]]));
                    for (const t in e) e.hasOwnProperty(t) && n.push(Float32Array.from([e[t]]));
                    return n
                }

                function Ln(t, e, n) {
                    const i = new Float32Array(n);
                    for (const n in t) t.hasOwnProperty(n) && (i[e[n]] = t[n]);
                    return i
                }

                function Cn(t) {
                    return Array.isArray(t) || t instanceof Float32Array ? Math.max(...t) : Math.max(...Object.values(t))
                }

                function Mn(t) {
                    let e = 0;
                    for (let n = 0; n < t.length; n++) e += t[n] ** 2;
                    return e / t.length
                }

                function On(t, e) {
                    if (t.buffer instanceof ArrayBuffer) return null;
                    if (Array.isArray(t)) return In;
                    if (!e) throw new Error("table is not Object");
                    const {
                        length: n
                    } = Object.keys(e);
                    return t => {
                        const i = new Float32Array(n);
                        for (const n in e) e.hasOwnProperty(n) && "number" == typeof t[n] && (i[e[n]] = t[n] || 0);
                        return i
                    }
                }
                class Rn {
                    constructor(t = {}) {
                        this.options = {
                            inputSize: 0,
                            outputSize: 0,
                            binaryThresh: .5
                        }, this.trainOpts = {
                            activation: "sigmoid",
                            iterations: 2e4,
                            errorThresh: .005,
                            log: !1,
                            logPeriod: 10,
                            leakyReluAlpha: .01,
                            learningRate: .3,
                            momentum: .1,
                            callbackPeriod: 10,
                            timeout: 1 / 0,
                            beta1: .9,
                            beta2: .999,
                            epsilon: 1e-8
                        }, this.sizes = [], this.outputLayer = -1, this.biases = [], this.weights = [], this.outputs = [], this.deltas = [], this.changes = [], this.errors = [], this.errorCheckInterval = 1, this.inputLookup = null, this.inputLookupLength = 0, this.outputLookup = null, this.outputLookupLength = 0, this._formatInput = null, this._formatOutput = null, this.runInput = t => (this.setActivation(), this.runInput(t)), this.calculateDeltas = t => (this.setActivation(), this.calculateDeltas(t)), this.biasChangesLow = [], this.biasChangesHigh = [], this.changesLow = [], this.changesHigh = [], this.iterations = 0, this.options = {
                            ...this.options,
                            ...t
                        }, this.updateTrainingOptions(t);
                        const {
                            inputSize: e,
                            hiddenLayers: n,
                            outputSize: i
                        } = this.options;
                        e && i && (this.sizes = [e].concat(null != n ? n : []).concat([i]))
                    }
                    initialize() {
                        if (!this.sizes.length) throw new Error("Sizes must be set before initializing");
                        this.outputLayer = this.sizes.length - 1, this.biases = new Array(this.outputLayer), this.weights = new Array(this.outputLayer), this.outputs = new Array(this.outputLayer), this.deltas = new Array(this.outputLayer), this.changes = new Array(this.outputLayer), this.errors = new Array(this.outputLayer);
                        for (let t = 0; t <= this.outputLayer; t++) {
                            const e = this.sizes[t];
                            if (this.deltas[t] = k(e), this.errors[t] = k(e), this.outputs[t] = k(e), t > 0) {
                                this.biases[t] = _t(e), this.weights[t] = new Array(e), this.changes[t] = new Array(e);
                                for (let n = 0; n < e; n++) {
                                    const e = this.sizes[t - 1];
                                    this.weights[t][n] = _t(e), this.changes[t][n] = k(e)
                                }
                            }
                        }
                        this.setActivation(), "adam" === this.trainOpts.praxis && this._setupAdam()
                    }
                    setActivation(t) {
                        const e = null != t ? t : this.trainOpts.activation;
                        switch (e) {
                            case "sigmoid":
                                this.runInput = this._runInputSigmoid, this.calculateDeltas = this._calculateDeltasSigmoid;
                                break;
                            case "relu":
                                this.runInput = this._runInputRelu, this.calculateDeltas = this._calculateDeltasRelu;
                                break;
                            case "leaky-relu":
                                this.runInput = this._runInputLeakyRelu, this.calculateDeltas = this._calculateDeltasLeakyRelu;
                                break;
                            case "tanh":
                                this.runInput = this._runInputTanh, this.calculateDeltas = this._calculateDeltasTanh;
                                break;
                            default:
                                throw new Error(`Unknown activation ${e}. Available activations are: 'sigmoid', 'relu', 'leaky-relu', 'tanh'`)
                        }
                    }
                    get isRunnable() {
                        return this.sizes.length > 0
                    }
                    run(t) {
                        if (!this.isRunnable) throw new Error("network not runnable");
                        let e;
                        e = this.inputLookup ? K.toArray(this.inputLookup, t, this.inputLookupLength) : t, this.validateInput(e);
                        const n = this.runInput(e).slice(0);
                        return this.outputLookup ? K.toObject(this.outputLookup, n) : n
                    }
                    _runInputSigmoid(t) {
                        this.outputs[0] = t;
                        let e = null;
                        for (let n = 1; n <= this.outputLayer; n++) {
                            const i = this.sizes[n],
                                s = this.weights[n],
                                r = this.biases[n],
                                a = this.outputs[n];
                            for (let e = 0; e < i; e++) {
                                const n = s[e];
                                let i = r[e];
                                for (let e = 0; e < n.length; e++) i += n[e] * t[e];
                                a[e] = 1 / (1 + Math.exp(-i))
                            }
                            e = t = a
                        }
                        if (!e) throw new Error("output was empty");
                        return e
                    }
                    _runInputRelu(t) {
                        this.outputs[0] = t;
                        let e = null;
                        for (let n = 1; n <= this.outputLayer; n++) {
                            const i = this.sizes[n],
                                s = this.weights[n],
                                r = this.biases[n],
                                a = this.outputs[n];
                            for (let e = 0; e < i; e++) {
                                const n = s[e];
                                let i = r[e];
                                for (let e = 0; e < n.length; e++) i += n[e] * t[e];
                                a[e] = i < 0 ? 0 : i
                            }
                            e = t = a
                        }
                        if (!e) throw new Error("output was empty");
                        return e
                    }
                    _runInputLeakyRelu(t) {
                        this.outputs[0] = t;
                        const {
                            leakyReluAlpha: e
                        } = this.trainOpts;
                        let n = null;
                        for (let i = 1; i <= this.outputLayer; i++) {
                            const s = this.sizes[i],
                                r = this.weights[i],
                                a = this.biases[i],
                                o = this.outputs[i];
                            for (let n = 0; n < s; n++) {
                                const i = r[n];
                                let s = a[n];
                                for (let e = 0; e < i.length; e++) s += i[e] * t[e];
                                o[n] = Math.max(s, e * s)
                            }
                            n = t = o
                        }
                        if (!n) throw new Error("output was empty");
                        return n
                    }
                    _runInputTanh(t) {
                        this.outputs[0] = t;
                        let e = null;
                        for (let n = 1; n <= this.outputLayer; n++) {
                            const i = this.sizes[n],
                                s = this.weights[n],
                                r = this.biases[n],
                                a = this.outputs[n];
                            for (let e = 0; e < i; e++) {
                                const n = s[e];
                                let i = r[e];
                                for (let e = 0; e < n.length; e++) i += n[e] * t[e];
                                a[e] = Math.tanh(i)
                            }
                            e = t = a
                        }
                        if (!e) throw new Error("output was empty");
                        return e
                    }
                    verifyIsInitialized(t) {
                        this.sizes.length && this.outputLayer > 0 || (this.sizes = [], this.sizes.push(t[0].input.length), this.options.hiddenLayers ? this.options.hiddenLayers.forEach((t => {
                            this.sizes.push(t)
                        })) : this.sizes.push(Math.max(3, Math.floor(t[0].input.length / 2))), this.sizes.push(t[0].output.length), this.initialize())
                    }
                    updateTrainingOptions(t) {
                        const e = {
                            ...this.trainOpts,
                            ...t
                        };
                        this.validateTrainingOptions(e), this.trainOpts = e, this.setLogMethod(this.trainOpts.log)
                    }
                    validateTrainingOptions(t) {
                        const e = {
                            activation: () => ["sigmoid", "relu", "leaky-relu", "tanh"].includes(t.activation),
                            iterations: () => {
                                const e = t.iterations;
                                return "number" == typeof e && e > 0
                            },
                            errorThresh: () => {
                                const e = t.errorThresh;
                                return "number" == typeof e && e > 0 && e < 1
                            },
                            log: () => {
                                const e = t.log;
                                return "function" == typeof e || "boolean" == typeof e
                            },
                            logPeriod: () => {
                                const e = t.logPeriod;
                                return "number" == typeof e && e > 0
                            },
                            leakyReluAlpha: () => {
                                const e = t.leakyReluAlpha;
                                return "number" == typeof e && e > 0 && e < 1
                            },
                            learningRate: () => {
                                const e = t.learningRate;
                                return "number" == typeof e && e > 0 && e < 1
                            },
                            momentum: () => {
                                const e = t.momentum;
                                return "number" == typeof e && e > 0 && e < 1
                            },
                            callback: () => {
                                const e = t.callback;
                                return "function" == typeof e || void 0 === e
                            },
                            callbackPeriod: () => {
                                const e = t.callbackPeriod;
                                return "number" == typeof e && e > 0
                            },
                            timeout: () => {
                                const e = t.timeout;
                                return "number" == typeof e && e > 0
                            },
                            praxis: () => {
                                const e = t.praxis;
                                return !e || "adam" === e
                            },
                            beta1: () => {
                                const e = t.beta1;
                                return e > 0 && e < 1
                            },
                            beta2: () => {
                                const e = t.beta2;
                                return e > 0 && e < 1
                            },
                            epsilon: () => {
                                const e = t.epsilon;
                                return e > 0 && e < 1
                            }
                        };
                        for (const n in e) {
                            const i = t;
                            if (!e[n]()) throw new Error(`[${n}, ${i[n]}] is out of normal training range, your network will probably not train.`)
                        }
                    }
                    getTrainOptsJSON() {
                        const {
                            activation: t,
                            iterations: e,
                            errorThresh: n,
                            log: i,
                            logPeriod: s,
                            leakyReluAlpha: r,
                            learningRate: a,
                            momentum: o,
                            callbackPeriod: u,
                            timeout: h,
                            praxis: l,
                            beta1: c,
                            beta2: p,
                            epsilon: d
                        } = this.trainOpts;
                        return {
                            activation: t,
                            iterations: e,
                            errorThresh: n,
                            log: "function" == typeof i || "boolean" == typeof i && i,
                            logPeriod: s,
                            leakyReluAlpha: r,
                            learningRate: a,
                            momentum: o,
                            callbackPeriod: u,
                            timeout: h === 1 / 0 ? "Infinity" : h,
                            praxis: l,
                            beta1: c,
                            beta2: p,
                            epsilon: d
                        }
                    }
                    setLogMethod(t) {
                        this.trainOpts.log = "function" == typeof t ? t : !!t && this.logTrainingStatus
                    }
                    logTrainingStatus(t) {
                        console.log(`iterations: ${t.iterations}, training error: ${t.error}`)
                    }
                    calculateTrainingError(t) {
                        let e = 0;
                        for (let n = 0; n < t.length; ++n) e += this.trainPattern(t[n], !0);
                        return e / t.length
                    }
                    trainPatterns(t) {
                        for (let e = 0; e < t.length; ++e) this.trainPattern(t[e])
                    }
                    trainingTick(t, e, n) {
                        const {
                            callback: i,
                            callbackPeriod: s,
                            errorThresh: r,
                            iterations: a,
                            log: o,
                            logPeriod: u
                        } = this.trainOpts;
                        return !(e.iterations >= a || e.error <= r || Date.now() >= n || (e.iterations++, o && e.iterations % u == 0 ? (e.error = this.calculateTrainingError(t), o(e)) : e.iterations % this.errorCheckInterval == 0 ? e.error = this.calculateTrainingError(t) : this.trainPatterns(t), i && e.iterations % s == 0 && i({
                            iterations: e.iterations,
                            error: e.error
                        }), 0))
                    }
                    prepTraining(t, e = {}) {
                        this.updateTrainingOptions(e);
                        const n = this.formatData(t),
                            i = Date.now() + this.trainOpts.timeout;
                        return this.verifyIsInitialized(n), this.validateData(n), {
                            preparedData: n,
                            status: {
                                error: 1,
                                iterations: 0
                            },
                            endTime: i
                        }
                    }
                    train(t, e = {}) {
                        const {
                            preparedData: n,
                            status: i,
                            endTime: s
                        } = this.prepTraining(t, e);
                        for (; this.trainingTick(n, i, s););
                        return i
                    }
                    async trainAsync(t, e = {}) {
                        const {
                            preparedData: n,
                            status: i,
                            endTime: s
                        } = this.prepTraining(t, e);
                        return await new Promise(((t, e) => {
                            try {
                                const e = new xn.Thaw(new Array(this.trainOpts.iterations), {
                                    delay: !0,
                                    each: () => this.trainingTick(n, i, s) || e.stop(),
                                    done: () => t(i)
                                });
                                e.tick()
                            } catch (t) {
                                e(t)
                            }
                        }))
                    }
                    trainPattern(t, e) {
                        return this.runInput(t.input), this.calculateDeltas(t.output), this.adjustWeights(), e ? Mn(this.errors[this.outputLayer]) : null
                    }
                    _calculateDeltasSigmoid(t) {
                        for (let e = this.outputLayer; e >= 0; e--) {
                            const n = this.sizes[e],
                                i = this.outputs[e],
                                s = this.errors[e],
                                r = this.deltas[e],
                                a = this.weights[e + 1];
                            for (let o = 0; o < n; o++) {
                                const n = i[o];
                                let u = 0;
                                if (e === this.outputLayer) u = t[o] - n;
                                else {
                                    const t = this.deltas[e + 1];
                                    for (let e = 0; e < t.length; e++) u += t[e] * a[e][o]
                                }
                                s[o] = u, r[o] = u * n * (1 - n)
                            }
                        }
                    }
                    _calculateDeltasRelu(t) {
                        for (let e = this.outputLayer; e >= 0; e--) {
                            const n = this.sizes[e],
                                i = this.outputs[e],
                                s = this.weights[e + 1],
                                r = this.deltas[e + 1],
                                a = this.errors[e],
                                o = this.deltas[e];
                            for (let u = 0; u < n; u++) {
                                const n = i[u];
                                let h = 0;
                                if (e === this.outputLayer) h = t[u] - n;
                                else
                                    for (let t = 0; t < r.length; t++) h += r[t] * s[t][u];
                                a[u] = h, o[u] = n > 0 ? h : 0
                            }
                        }
                    }
                    _calculateDeltasLeakyRelu(t) {
                        const e = this.trainOpts.leakyReluAlpha;
                        for (let n = this.outputLayer; n >= 0; n--) {
                            const i = this.sizes[n],
                                s = this.outputs[n],
                                r = this.deltas[n + 1],
                                a = this.weights[n + 1],
                                o = this.errors[n],
                                u = this.deltas[n];
                            for (let h = 0; h < i; h++) {
                                const i = s[h];
                                let l = 0;
                                if (n === this.outputLayer) l = t[h] - i;
                                else
                                    for (let t = 0; t < r.length; t++) l += r[t] * a[t][h];
                                o[h] = l, u[h] = i > 0 ? l : e * l
                            }
                        }
                    }
                    _calculateDeltasTanh(t) {
                        for (let e = this.outputLayer; e >= 0; e--) {
                            const n = this.sizes[e],
                                i = this.outputs[e],
                                s = this.deltas[e + 1],
                                r = this.weights[e + 1],
                                a = this.errors[e],
                                o = this.deltas[e];
                            for (let u = 0; u < n; u++) {
                                const n = i[u];
                                let h = 0;
                                if (e === this.outputLayer) h = t[u] - n;
                                else
                                    for (let t = 0; t < s.length; t++) h += s[t] * r[t][u];
                                a[u] = h, o[u] = (1 - n * n) * h
                            }
                        }
                    }
                    adjustWeights() {
                        const {
                            learningRate: t,
                            momentum: e
                        } = this.trainOpts;
                        for (let n = 1; n <= this.outputLayer; n++) {
                            const i = this.outputs[n - 1],
                                s = this.sizes[n],
                                r = this.deltas[n],
                                a = this.changes[n],
                                o = this.weights[n],
                                u = this.biases[n];
                            for (let n = 0; n < s; n++) {
                                const s = r[n];
                                for (let r = 0; r < i.length; r++) {
                                    let u = a[n][r];
                                    u = t * s * i[r] + e * u, a[n][r] = u, o[n][r] += u
                                }
                                u[n] += t * s
                            }
                        }
                    }
                    _setupAdam() {
                        this.biasChangesLow = [], this.biasChangesHigh = [], this.changesLow = [], this.changesHigh = [], this.iterations = 0;
                        for (let t = 0; t <= this.outputLayer; t++) {
                            const e = this.sizes[t];
                            if (t > 0) {
                                this.biasChangesLow[t] = k(e), this.biasChangesHigh[t] = k(e), this.changesLow[t] = new Array(e), this.changesHigh[t] = new Array(e);
                                for (let n = 0; n < e; n++) {
                                    const e = this.sizes[t - 1];
                                    this.changesLow[t][n] = k(e), this.changesHigh[t][n] = k(e)
                                }
                            }
                        }
                        this.adjustWeights = this._adjustWeightsAdam
                    }
                    _adjustWeightsAdam() {
                        this.iterations++;
                        const {
                            iterations: t
                        } = this, {
                            beta1: e,
                            beta2: n,
                            epsilon: i,
                            learningRate: s
                        } = this.trainOpts;
                        for (let r = 1; r <= this.outputLayer; r++) {
                            const a = this.outputs[r - 1],
                                o = this.sizes[r],
                                u = this.deltas[r],
                                h = this.changesLow[r],
                                l = this.changesHigh[r],
                                c = this.weights[r],
                                p = this.biases[r],
                                d = this.biasChangesLow[r],
                                m = this.biasChangesHigh[r];
                            for (let r = 0; r < o; r++) {
                                const o = u[r];
                                for (let u = 0; u < a.length; u++) {
                                    const p = o * a[u],
                                        d = h[r][u] * e + (1 - e) * p,
                                        m = l[r][u] * n + (1 - n) * p * p,
                                        g = d / (1 - Math.pow(e, t)),
                                        f = m / (1 - Math.pow(n, t));
                                    h[r][u] = d, l[r][u] = m, c[r][u] += s * g / (Math.sqrt(f) + i)
                                }
                                const g = u[r],
                                    f = d[r] * e + (1 - e) * g,
                                    y = m[r] * n + (1 - n) * g * g,
                                    x = d[r] / (1 - Math.pow(e, t)),
                                    _ = m[r] / (1 - Math.pow(n, t));
                                d[r] = f, m[r] = y, p[r] += s * x / (Math.sqrt(_) + i)
                            }
                        }
                    }
                    validateData(t) {
                        const e = this.sizes[0],
                            n = this.sizes[this.sizes.length - 1],
                            {
                                length: i
                            } = t;
                        for (let s = 0; s < i; s++) {
                            const {
                                input: i,
                                output: r
                            } = t[s];
                            if (i.length !== e) throw new Error(`input at index ${s} length ${i.length} must be ${e}`);
                            if (t[s].output.length !== n) throw new Error(`output at index ${s} length ${r.length} must be ${n}`)
                        }
                    }
                    validateInput(t) {
                        const e = this.sizes[0];
                        if (t.length !== e) throw new Error(`input length ${t.length} must match options.inputSize of ${e}`)
                    }
                    formatData(t) {
                        if (!Array.isArray(t[0].input))
                            if (this.inputLookup) this.inputLookupLength = Object.keys(this.inputLookup).length;
                            else {
                                const e = new dn(t, "input");
                                this.inputLookup = e.table, this.inputLookupLength = e.length
                            } if (!Array.isArray(t[0].output))
                            if (this.outputLookup) this.outputLookupLength = Object.keys(this.outputLookup).length;
                            else {
                                const e = new dn(t, "output");
                                this.outputLookup = e.table, this.outputLookupLength = e.length
                            } if (this._formatInput || (this._formatInput = On(t[0].input, this.inputLookup)), this._formatOutput || (this._formatOutput = On(t[0].output, this.outputLookup)), this._formatInput && this._formatOutput) {
                            const e = [];
                            for (let n = 0; n < t.length; n++) e.push({
                                input: this._formatInput(t[n].input),
                                output: this._formatOutput(t[n].output)
                            });
                            return e
                        }
                        if (this._formatInput) {
                            const e = [];
                            for (let n = 0; n < t.length; n++) e.push({
                                input: this._formatInput(t[n].input),
                                output: t[n].output
                            });
                            return e
                        }
                        if (this._formatOutput) {
                            const e = [];
                            for (let n = 0; n < t.length; n++) e.push({
                                input: t[n].input,
                                output: this._formatOutput(t[n].output)
                            });
                            return e
                        }
                        return t
                    }
                    addFormat(t) {
                        var e, n;
                        Array.isArray(t.input) && "number" == typeof t.input[0] || (this.inputLookup = K.addKeys(t.input, null !== (e = this.inputLookup) && void 0 !== e ? e : {}), this.inputLookup && (this.inputLookupLength = Object.keys(this.inputLookup).length)), Array.isArray(t.output) && "number" == typeof t.output[0] || (this.outputLookup = K.addKeys(t.output, null !== (n = this.outputLookup) && void 0 !== n ? n : {}), this.outputLookup && (this.outputLookupLength = Object.keys(this.outputLookup).length))
                    }
                    test(t) {
                        const {
                            preparedData: e
                        } = this.prepTraining(t), n = [];
                        let i = 0;
                        if (1 === e[0].output.length) {
                            let t = 0,
                                s = 0,
                                r = 0,
                                a = 0;
                            for (let o = 0; o < e.length; o++) {
                                const u = this.runInput(e[o].input),
                                    h = e[o].output,
                                    l = u[0] > this.options.binaryThresh ? 1 : 0,
                                    c = h[0];
                                if (l !== c) {
                                    const t = e[o];
                                    n.push({
                                        input: t.input,
                                        output: t.output,
                                        actual: l,
                                        expected: c
                                    })
                                }
                                0 === l && 0 === c ? a++ : 1 === l && 1 === c ? r++ : 0 === l && 1 === c ? s++ : 1 === l && 0 === c && t++, i += Mn(u.map(((t, e) => h[e] - t)))
                            }
                            return {
                                error: i / e.length,
                                misclasses: n,
                                total: e.length,
                                trueNeg: a,
                                truePos: r,
                                falseNeg: s,
                                falsePos: t,
                                precision: r > 0 ? r / (r + t) : 0,
                                recall: r > 0 ? r / (r + s) : 0,
                                accuracy: (a + r) / e.length
                            }
                        }
                        for (let t = 0; t < e.length; t++) {
                            const s = this.runInput(e[t].input),
                                r = e[t].output,
                                a = s.indexOf(Cn(s)),
                                o = r.indexOf(Cn(r));
                            if (a !== o) {
                                const i = e[t];
                                n.push({
                                    input: i.input,
                                    output: i.output,
                                    actual: a,
                                    expected: o
                                })
                            }
                            i += Mn(s.map(((t, e) => r[e] - t)))
                        }
                        return {
                            error: i / e.length,
                            misclasses: n,
                            total: e.length
                        }
                    }
                    toJSON() {
                        var t, e;
                        this.isRunnable || this.initialize();
                        const n = this.weights.map((t => t.map((t => Array.from(t))))),
                            i = this.biases.map((t => Array.from(t))),
                            s = [],
                            r = this.sizes.length - 1;
                        for (let a = 0; a <= r; a++) s.push({
                            weights: null !== (t = n[a]) && void 0 !== t ? t : [],
                            biases: null !== (e = i[a]) && void 0 !== e ? e : []
                        });
                        return {
                            type: "NeuralNetwork",
                            sizes: [...this.sizes],
                            layers: s,
                            inputLookup: this.inputLookup ? {
                                ...this.inputLookup
                            } : null,
                            inputLookupLength: this.inputLookupLength,
                            outputLookup: this.outputLookup ? {
                                ...this.outputLookup
                            } : null,
                            outputLookupLength: this.outputLookupLength,
                            options: {
                                ...this.options
                            },
                            trainOpts: this.getTrainOptsJSON()
                        }
                    }
                    fromJSON(t) {
                        if (this.options = {
                                inputSize: 0,
                                outputSize: 0,
                                binaryThresh: .5,
                                ...t.options
                            }, t.hasOwnProperty("trainOpts")) {
                            const e = {
                                ...t.trainOpts,
                                timeout: "Infinity" === t.trainOpts.timeout ? 1 / 0 : t.trainOpts.timeout
                            };
                            this.updateTrainingOptions(e)
                        }
                        this.sizes = t.sizes, this.initialize(), this.inputLookup = t.inputLookup ? {
                            ...t.inputLookup
                        } : null, this.inputLookupLength = t.inputLookupLength, this.outputLookup = t.outputLookup ? {
                            ...t.outputLookup
                        } : null, this.outputLookupLength = t.outputLookupLength;
                        const e = t.layers,
                            n = this.weights.map(((t, n) => e[n].weights.map((t => Float32Array.from(t))))),
                            i = this.biases.map(((t, n) => Float32Array.from(e[n].biases)));
                        for (let t = 0; t <= this.outputLayer; t++) this.weights[t] = n[t] || [], this.biases[t] = i[t] || [];
                        return this
                    }
                    toFunction(t) {
                        const {
                            activation: e,
                            leakyReluAlpha: n
                        } = this.trainOpts;
                        let i = !1;
                        const s = (t, r) => {
                            if (0 === t) return `(input[${r}]||0)`;
                            const a = this.weights[t][r],
                                o = this.biases[t][r];
                            if (!a) throw new Error(`weights at layerIndex ${t} & nodeIndex ${r} not found`);
                            if (!o) throw new Error(`bias as layerIndex ${t} & nodeIndex ${r} not found`);
                            const u = [];
                            a.forEach(((e, n) => {
                                e < 0 ? u.push(`${e}*${s(t-1,n)}`) : u.push(`+${e}*${s(t-1,n)}`)
                            }));
                            const h = `(${o.toString()}${u.join("")})`;
                            switch (e) {
                                case "sigmoid":
                                    return `1/(1+1/Math.exp(${h}))`;
                                case "relu":
                                    return i = !0, `((v=${h})<0?0:v)`;
                                case "leaky-relu":
                                    return i = !0, `Math.max((v=${h}),${n}*v)`;
                                case "tanh":
                                    return `Math.tanh(${h})`;
                                default:
                                    throw new Error(`Unknown activation ${e}. Available activations are: 'sigmoid', 'relu', 'leaky-relu', 'tanh'`)
                            }
                        };

                        function r(t) {
                            if (t.find((t => t.includes('"')))) throw new Error("key contains '\"', which is not compatible")
                        }
                        const a = [];
                        let o, u = "";
                        if (this.inputLookup && (r(Object.keys(this.inputLookup)), u = `input = new Float32Array([${Object.keys(this.inputLookup).map((t=>`input["${t}"]`)).join(",")}]);`), this.sizes.length < 1) throw new Error("No layers");
                        for (let t = 0; t < this.sizes[this.outputLayer]; t++) a.push(s(this.outputLayer, t));
                        if (this.outputLookup) {
                            const t = Object.keys(this.outputLookup);
                            r(t), o = `{${t.map(((t,e)=>`"${t}":${a[e]}`)).join(",")}}`
                        } else o = `[${a.join(",")}]`;
                        const h = `${u}${i?"var v;":""}return ${o};`;
                        return new Function("input", t ? t(h) : h)
                    }
                }

                function Nn(t, e, n) {
                    let i = e[this.thread.x];
                    for (let e = 0; e < this.constants.size; e++) i += t[this.thread.x][e] * n[e];
                    return 1 / (1 + Math.exp(-i))
                }

                function Pn(t, e, n) {
                    let i = e[this.thread.x];
                    for (let e = 0; e < this.constants.size; e++) i += t[this.thread.x][e] * n[e];
                    return i < 0 ? 0 : i
                }

                function $n(t, e, n) {
                    let i = e[this.thread.x];
                    for (let e = 0; e < this.constants.size; e++) i += t[this.thread.x][e] * n[e];
                    return i < 0 ? 0 : .01 * i
                }

                function Un(t, e, n) {
                    let i = e[this.thread.x];
                    for (let e = 0; e < this.constants.size; e++) i += t[this.thread.x][e] * n[e];
                    return Math.tanh(i)
                }

                function Fn(t, e) {
                    return e - t
                }

                function Bn(t, e) {
                    return t * e * (1 - e)
                }

                function zn(t, e) {
                    return e > 0 ? t : 0
                }

                function Vn(t, e) {
                    return e > 0 ? t : .01 * t
                }

                function Kn(t, e) {
                    return (1 - e * e) * t
                }

                function Gn(t, e, n, i) {
                    let s = 0;
                    for (let r = 0; r < e; r++) s += i[r] * n[r][t];
                    return s
                }

                function jn(t, e, n, i, s) {
                    return t * i * s + e * n
                }

                function Wn(t, e) {
                    return t + e
                }

                function Hn(t, e) {
                    return t[this.thread.x] + e[this.thread.x] * this.constants.learningRate
                }

                function Xn(t) {
                    let e = 0;
                    for (let n = 0; n < this.constants.size; n++) e += t[n] ** 2;
                    return e / this.constants.size
                }
                class Zn extends Rn {
                    constructor(t = {}) {
                        super(t), this.texturizeInputData = () => {
                            throw new Error("not yet setup")
                        }, this.forwardPropagate = [], this.backwardPropagate = [], this.changesPropagate = [], this.biasesPropagate = [], this.getMSE = () => {
                            throw new Error("not yet setup")
                        }, this._addMSE = () => {
                            throw new Error("not yet setup")
                        }, this._divideMSESum = () => {
                            throw new Error("not yet setup")
                        }, this.outputs = [], this.deltas = [], this.errors = [], this.weights = [], this.changes = [], this.biases = [], this.runInput = t => {
                            let e;
                            this.outputs[0] = t;
                            for (let n = 1; n <= this.outputLayer; n++) w(this.outputs[n]), this.outputs[n] = this.forwardPropagate[n](this.weights[n], this.biases[n], t), e = t = this.outputs[n];
                            return e
                        }, this.calculateDeltas = t => {
                            for (let e = this.outputLayer; e > 0; e--) {
                                let n;
                                w(this.deltas[e]), w(this.errors[e]), n = e === this.outputLayer ? this.backwardPropagate[e](this.outputs[e], t) : this.backwardPropagate[e](this.weights[e + 1], this.outputs[e], this.deltas[e + 1]), this.deltas[e] = n.result, this.errors[e] = n.error
                            }
                        }, this.errorCheckInterval = 100, this.gpu = new e.GPU({
                            mode: t.mode
                        })
                    }
                    initialize() {
                        super.initialize(), this.buildRunInput(), this.buildCalculateDeltas(), this.buildGetChanges(), this.buildChangeBiases(), this.buildGetMSE()
                    }
                    setActivation() {}
                    trainPattern(t, e) {
                        return this.runInput(t.input), this.calculateDeltas(t.output), this.adjustWeights(), e ? this.getMSE(this.errors[this.outputLayer]) : null
                    }
                    calculateTrainingError(t) {
                        let n = new Float32Array([0]);
                        for (let e = 0; e < t.length; ++e) {
                            const i = n,
                                s = this.trainPattern(t[e], !0);
                            n = this._addMSE(n, s), w(s), w(i)
                        }
                        const i = this._divideMSESum(t.length, n);
                        return w(n), (i instanceof e.Texture ? i.toArray() : i)[0]
                    }
                    adjustWeights() {
                        this.getChanges(), this.changeBiases()
                    }
                    buildRunInput() {
                        let t = null;
                        switch (this.trainOpts.activation) {
                            case "sigmoid":
                                t = Nn;
                                break;
                            case "relu":
                                t = Pn;
                                break;
                            case "leaky-relu":
                                t = $n;
                                break;
                            case "tanh":
                                t = Un;
                                break;
                            default:
                                throw new Error(`Unknown activation ${this.trainOpts.activation}. Available activations are: 'sigmoid', 'relu', 'leaky-relu', 'tanh'`)
                        }
                        for (let e = 1; e <= this.outputLayer; e++) this.forwardPropagate[e] = this.gpu.createKernel(t, {
                            output: [this.sizes[e]],
                            pipeline: !0,
                            constants: {
                                size: this.sizes[e - 1]
                            },
                            immutable: !0
                        });
                        this.texturizeInputData = this.gpu.createKernel((function(t) {
                            return t[this.thread.x]
                        }), {
                            output: [this.sizes[1]],
                            pipeline: !0,
                            immutable: !0
                        })
                    }
                    buildCalculateDeltas() {
                        let t;
                        switch (this.trainOpts.activation) {
                            case "sigmoid":
                                t = Bn;
                                break;
                            case "relu":
                                t = zn;
                                break;
                            case "leaky-relu":
                                t = Vn;
                                break;
                            case "tanh":
                                t = Kn;
                                break;
                            default:
                                throw new Error(`Unknown activation ${this.trainOpts.activation}. Available activations are: 'sigmoid', 'relu', 'leaky-relu', 'tanh'`)
                        }
                        t = e.alias(e.utils.getMinifySafeName((() => t)), t), this.gpu.addFunction(t);
                        for (let e = this.outputLayer; e > 0; e--) e === this.outputLayer ? this.backwardPropagate[this.outputLayer] = this.gpu.createKernelMap({
                            error: Fn
                        }, (function(e, n) {
                            const i = e[this.thread.x],
                                s = n[this.thread.x];
                            return t(Fn(i, s), i)
                        }), {
                            output: [this.sizes[this.outputLayer]],
                            pipeline: !0,
                            immutable: !0
                        }) : this.backwardPropagate[e] = this.gpu.createKernelMap({
                            error: Gn
                        }, (function(e, n, i) {
                            const s = n[this.thread.x];
                            return t(Gn(this.thread.x, this.constants.size, e, i), s)
                        }), {
                            output: [this.sizes[e]],
                            pipeline: !0,
                            constants: {
                                size: this.sizes[e + 1]
                            },
                            immutable: !0
                        })
                    }
                    buildGetChanges() {
                        for (let t = 1; t <= this.outputLayer; t++) this.changesPropagate[t] = this.gpu.createKernelMap({
                            weights: Wn,
                            changes: jn
                        }, (function(t, e, n, i) {
                            return Wn(jn(this.constants.learningRate, this.constants.momentum, i[this.thread.y][this.thread.x], e[this.thread.y], t[this.thread.x]), n[this.thread.y][this.thread.x])
                        }), {
                            output: [this.sizes[t - 1], this.sizes[t]],
                            pipeline: !0,
                            constants: {
                                size: this.sizes[t - 1],
                                learningRate: this.trainOpts.learningRate,
                                momentum: this.trainOpts.momentum
                            },
                            immutable: !0
                        })
                    }
                    getChanges() {
                        for (let t = 1; t <= this.outputLayer; t++) {
                            const e = this.weights[t],
                                n = this.changes[t],
                                i = this.changesPropagate[t](this.outputs[t - 1], this.deltas[t], e, n);
                            w(e), w(n), this.weights[t] = i.weights, this.changes[t] = i.changes, w(i.result)
                        }
                    }
                    buildChangeBiases() {
                        for (let t = 1; t <= this.outputLayer; t++) this.biasesPropagate[t] = this.gpu.createKernel(Hn, {
                            output: [this.sizes[t]],
                            pipeline: !0,
                            constants: {
                                learningRate: this.trainOpts.learningRate
                            },
                            immutable: !0
                        })
                    }
                    changeBiases() {
                        for (let t = 1; t <= this.outputLayer; t++) {
                            const e = this.biases[t];
                            this.biases[t] = this.biasesPropagate[t](e, this.deltas[t]), w(e)
                        }
                    }
                    buildGetMSE() {
                        this.getMSE = this.gpu.createKernel(Xn, {
                            output: [1],
                            constants: {
                                size: this.sizes[this.outputLayer]
                            },
                            pipeline: !0,
                            immutable: !0
                        }), this._addMSE = this.gpu.createKernel((function(t, e) {
                            return t[0] + e[0]
                        }), {
                            output: [1],
                            pipeline: !0,
                            immutable: !0
                        }), this._divideMSESum = this.gpu.createKernel((function(t, e) {
                            const n = e[0];
                            return n > 0 ? n / t : 0
                        }), {
                            output: [1]
                        })
                    }
                    run(t) {
                        if (!this.isRunnable) throw new Error("network not runnable");
                        let n;
                        n = this.inputLookup ? K.toArray(this.inputLookup, t, this.inputLookupLength) : t, this.validateInput(n);
                        const i = this.runInput(n),
                            s = i instanceof e.Texture ? i.toArray() : i;
                        return this.outputLookup ? K.toObject(this.outputLookup, s) : s
                    }
                    prepTraining(t, e = {}) {
                        this.updateTrainingOptions(e);
                        const n = this.formatData(t),
                            i = Date.now() + this.trainOpts.timeout;
                        this.verifyIsInitialized(n);
                        const s = this.gpu.createKernel((function(t) {
                            return t[this.thread.x]
                        }), {
                            output: [n[0].output.length],
                            pipeline: !0,
                            immutable: !0
                        });
                        return {
                            preparedData: n.map((t => ({
                                input: this.texturizeInputData(t.input),
                                output: s(t.output)
                            }))),
                            status: {
                                error: 1,
                                iterations: 0
                            },
                            endTime: i
                        }
                    }
                    toFunction() {
                        throw new Error(`${this.constructor.name}-toFunction is not yet implemented`)
                    }
                    toJSON() {
                        var t, n;
                        null === this.sizes && this.initialize();
                        const i = this.weights.map((t => (t instanceof e.Texture ? t.toArray() : t).map((t => Array.from(t))))),
                            s = this.biases.map((t => Array.from(t instanceof e.Texture ? t.toArray() : t))),
                            r = [];
                        for (let e = 0; e <= this.outputLayer; e++) r.push({
                            weights: null !== (t = i[e]) && void 0 !== t ? t : [],
                            biases: null !== (n = s[e]) && void 0 !== n ? n : []
                        });
                        return {
                            type: "NeuralNetworkGPU",
                            sizes: [...this.sizes],
                            layers: r,
                            inputLookup: this.inputLookup ? {
                                ...this.inputLookup
                            } : null,
                            inputLookupLength: this.inputLookupLength,
                            outputLookup: this.outputLookup ? {
                                ...this.outputLookup
                            } : null,
                            outputLookupLength: this.outputLookupLength,
                            options: {
                                ...this.options
                            },
                            trainOpts: this.getTrainOptsJSON()
                        }
                    }
                }
                class qn extends O {
                    constructor() {
                        super(...arguments), this.settings = {}, this.layer = null
                    }
                    setLayer(t) {
                        this.layer = t
                    }
                    get width() {
                        if (!this.layer) throw new Error("layer not set");
                        return this.layer.width
                    }
                    set width(t) {
                        throw new Error(`${this.constructor.name}-width is not yet implemented`)
                    }
                    get height() {
                        if (!this.layer) throw new Error("layer not set");
                        return this.layer.height
                    }
                    set height(t) {
                        throw new Error(`${this.constructor.name}-height is not yet implemented`)
                    }
                    get deltas() {
                        if (!this.layer) throw new Error("layer not set");
                        return this.layer.deltas
                    }
                    set deltas(t) {
                        if (!this.layer) throw new Error("layer not set");
                        w(this.layer.deltas), this.layer.deltas = t
                    }
                    get weights() {
                        if (!this.layer) throw new Error("layer not set");
                        return this.layer.weights
                    }
                    set weights(t) {
                        if (!this.layer) throw new Error("layer not set");
                        w(this.layer.weights), this.layer.weights = t
                    }
                    predict() {}
                    compare() {}
                    learn() {
                        throw new Error("no longer using")
                    }
                    setupKernels() {}
                    reuseKernels() {}
                }
                class Yn extends wn {
                    constructor(t = {}) {
                        super(t), this.trainOpts = {}, this._outputConnection = null, this._layerSets = [], this._hiddenLayerOutputIndices = [], this._model = null
                    }
                    _connectLayers() {
                        if (!this.options.inputLayer) throw new Error("inputLayer not found");
                        if (!this.options.outputLayer) throw new Error("outputLayer not found");
                        const t = this.options.inputLayer(),
                            e = this._connectHiddenLayers(t);
                        return {
                            inputLayer: t,
                            hiddenLayers: e,
                            outputLayer: this.options.outputLayer(e[e.length - 1], -1)
                        }
                    }
                    _connectLayersDeep() {
                        const t = [],
                            e = this._layerSets[this._layerSets.length - 1];
                        let n = 0;

                        function i(n) {
                            const i = e.indexOf(n);
                            if (i < 0) throw new Error("unable to find layer");
                            return t[i]
                        }

                        function s(t) {
                            return {
                                ...t.settings,
                                weights: null,
                                deltas: null,
                                praxis: null
                            }
                        }
                        for (let r = 0; r < e.length; r++) {
                            const a = e[r];
                            let o;
                            if (a instanceof C) o = new a.constructor(i(a.inputLayer), s(a));
                            else if (a instanceof z) o = new a.constructor(s(a));
                            else if (a instanceof M) o = new a.constructor(s(a.inputLayer), i(a.inputLayer));
                            else if (a instanceof O) {
                                const t = e[this._hiddenLayerOutputIndices[n++]];
                                if (a instanceof qn) throw new Error("unfinished");
                                if (a instanceof $e) o = new $e(t);
                                else {
                                    if (!(a instanceof Ue)) throw new Error(`hidden layer ${a.constructor.name} extends unknown hidden layer`);
                                    o = new $e(t)
                                }
                            } else if (a instanceof B || a instanceof V) o = a;
                            else if (a instanceof R) o = new a.constructor(i(a.inputLayer), s(a.inputLayer));
                            else if (a instanceof N) o = new a.constructor(i(a.inputLayer1), i(a.inputLayer2), s(a));
                            else {
                                if (!(a instanceof U)) throw new Error(`hidden layer ${a.constructor.name} extends unknown hidden layer`);
                                o = new a.constructor(s(a), i(a.inputLayer))
                            }
                            t.push(o)
                        }
                        return t
                    }
                    _connectHiddenLayers(t) {
                        const e = [];
                        if (!this.options.hiddenLayers) throw new Error("hiddenLayers not defined");
                        for (let n = 0; n < this.options.hiddenLayers.length; n++) {
                            const i = new Ue,
                                s = this.options.hiddenLayers[n](t, i, n);
                            t = s, e.push(s)
                        }
                        return e
                    }
                    initialize() {
                        let t;
                        if (this._outputConnection = new qn, this.options.layers) t = this._connectOptionsLayers();
                        else {
                            const {
                                inputLayer: e,
                                hiddenLayers: n,
                                outputLayer: i
                            } = this._connectLayers();
                            t = lt([e, ...n, i]), this._hiddenLayerOutputIndices = n.map((e => t.indexOf(e))), this._inputLayer = e, this._hiddenLayers = n, this._outputLayer = i
                        }
                        this.layers = t, this._layerSets = [t], this._model = t.filter((t => t instanceof V || t instanceof B)), this.initializeLayers(t)
                    }
                    initializeDeep() {
                        const t = this._connectLayersDeep();
                        for (let e = 0; e < t.length; e++) {
                            const n = t[e];
                            n.setupKernels(!0), n.reuseKernels(this._layerSets[0][e])
                        }
                        this._layerSets.push(t)
                    }
                    run(t) {
                        for (; this._layerSets.length <= t.length;) this.initializeDeep();
                        const n = this.runInputs(t);
                        return n instanceof e.Texture ? n.toArray() : n
                    }
                    runInput(t) {
                        throw new Error("use .runInputs()")
                    }
                    runInputs(t) {
                        for (; this._layerSets.length < t.length;) this.initializeDeep();
                        const e = t.length - 1;
                        for (let n = 0; n <= e; n++) {
                            const e = this._layerSets[n];
                            e[0].predict(t[n]);
                            for (let t = 1; t < e.length; t++) e[t].predict()
                        }
                        const n = this._layerSets[e],
                            i = n[n.length - 1].weights;
                        return this.end(), i
                    }
                    train(t, e = {}) {
                        const {
                            preparedData: n,
                            status: i,
                            endTime: s
                        } = this._prepTraining(t, e);
                        let r = !0;
                        const a = () => this._calculateTrainingError(n),
                            o = () => this._trainPatterns(n);
                        for (; r;) r = this._trainingTick(i, s, a, o);
                        return i
                    }
                    end() {
                        const t = this._layerSets.length - 1,
                            e = this._layerSets[t];
                        e[0].predict([new Float32Array([0])]);
                        for (let t = 1; t < e.length; t++) e[t].predict()
                    }
                    transferData(t) {
                        return t
                    }
                    _prepTraining(t, e) {
                        this._updateTrainingOptions(e);
                        const n = this.trainOpts.timeout ? Date.now() + this.trainOpts.timeout : 0;
                        return this.verifyIsInitialized(), {
                            preparedData: this.transferData(t),
                            status: {
                                error: 1,
                                iterations: 0
                            },
                            endTime: n
                        }
                    }
                    _calculateTrainingError(t) {
                        if (!this.meanSquaredError) throw new Error("this.meanSquaredError not setup");
                        let n = new Float32Array(1);
                        for (let e = 0; e < t.length; ++e) {
                            const i = n,
                                s = this._trainPattern(t[e], !0);
                            n = this.meanSquaredError.add(n, s), w(s), w(i)
                        }
                        const i = this.meanSquaredError.divide(t.length, n);
                        return w(n), i instanceof e.Texture ? i.toArray()[0] : i[0]
                    }
                    formatData(t) {
                        return t
                    }
                    _calculateDeltas(t) {
                        const e = this._layerSets[this._layerSets.length - 1];
                        for (let t = e.length - 2; t >= 0; t--) e[t].compare();
                        for (let e = t.length - 2; e >= 0; e--) {
                            const n = this._layerSets[e];
                            n[n.length - 1].compare(t[e + 1]);
                            for (let t = n.length - 2; t >= 0; t--) n[t].compare()
                        }
                    }
                    adjustWeights() {
                        var t;
                        const e = this._model;
                        for (let n = 0; n < e.length; n++) e[n].learn(null !== (t = this.options.learningRate) && void 0 !== t ? t : 0)
                    }
                    _trainPatterns(t) {
                        for (let e = 0; e < t.length; ++e) this._trainPattern(t[e], !1)
                    }
                    _trainPattern(t, e) {
                        if (this.runInputs(t), this._calculateDeltas(t), this.adjustWeights(), e) {
                            if (!this.meanSquaredError) throw new Error("this.meanSquaredError not setup");
                            let e = new Float32Array(1);
                            for (let n = 0, i = t.length - 2; n <= i; n++) {
                                const t = this._layerSets[n],
                                    i = t[t.length - 1],
                                    s = e;
                                e = this.meanSquaredError.addAbsolute(s, i.errors), w(s)
                            }
                            return T(this.meanSquaredError.divide(t.length, e))
                        }
                        return null
                    }
                }
                class Jn {
                    constructor(t, e) {
                        this.rows = 0, this.columns = 0, t && (this.rows = t), e && (this.columns = e), this.weights = k(this.rows * this.columns), this.deltas = k(this.rows * this.columns)
                    }
                    getWeight(t, e) {
                        const n = this.columns * t + e;
                        if (n < 0 || n >= this.weights.length) throw new Error("get accessor is skewed");
                        return this.weights[n]
                    }
                    setWeight(t, e, n) {
                        const i = this.columns * t + e;
                        if (i < 0 || i >= this.weights.length) throw new Error("set accessor is skewed");
                        return this.weights[i] = n, this
                    }
                    getDelta(t, e) {
                        const n = this.columns * t + e;
                        if (n < 0 || n >= this.deltas.length) throw new Error("get accessor is skewed");
                        return this.deltas[n]
                    }
                    setDelta(t, e, n) {
                        const i = this.columns * t + e;
                        if (i < 0 || i >= this.weights.length) throw new Error("set accessor is skewed");
                        return this.deltas[i] = n, this
                    }
                    toJSON() {
                        return {
                            rows: this.rows,
                            columns: this.columns,
                            weights: Array.from(this.weights.slice(0))
                        }
                    }
                    static fromJSON(t) {
                        const e = new Jn(t.rows, t.columns);
                        for (let n = 0, i = t.rows * t.columns; n < i; n++) e.weights[n] = t.weights[n];
                        return e
                    }
                    static fromArray(t) {
                        const e = new Jn(t.length, t[0].length);
                        return e.fromArray(t), e
                    }
                    deltasToArray() {
                        return this.toArray("deltas")
                    }
                    weightsToArray() {
                        return this.toArray("weights")
                    }
                    toArray(t = "weights") {
                        const e = new Array(this.rows);
                        return this.iterate({
                            row: t => {
                                e[t] = new Array(this.columns)
                            },
                            column: (n, i) => {
                                "weights" === t ? e[n][i] = this.getWeight(n, i) : "deltas" === t && (e[n][i] = this.getDelta(n, i))
                            }
                        }), e
                    }
                    fromArray(t, e = "weights") {
                        if (t.length !== this.rows) throw new Error("rows do not match");
                        if (t[0].length !== this.columns) throw new Error("columns do not match");
                        return this.iterate({
                            column: (n, i) => {
                                const s = t[n][i];
                                if ("number" != typeof s) throw new Error("value not number");
                                "weights" === e ? this.setWeight(n, i, s) : "deltas" === e && this.setDelta(n, i, s)
                            }
                        }), this
                    }
                    iterate(t) {
                        const e = this.rows,
                            n = this.columns;
                        for (let i = 0; i < e; i++) {
                            t.row && t.row(i);
                            for (let e = 0; e < n; e++) t.column && t.column(i, e)
                        }
                        return this
                    }
                }
                class Qn extends Jn {
                    constructor(t, e, n) {
                        super(t, e), this.std = n;
                        for (let t = 0, e = this.weights.length; t < e; t++) this.weights[t] = ft(-n, n)
                    }
                }
                class ti {
                    constructor(t, e = 0) {
                        this.values = t, this.indexTable = {}, this.characterTable = {}, this.characters = [], this.specialIndexes = [], this.isSetup = !1, void 0 !== t && this.setup(t, e)
                    }
                    setup(t, e = 0) {
                        if (this.isSetup) throw new Error("DataFormatter is already setup");
                        this.values = t, this.buildCharactersFromIterable(t), this.buildTables(e), t[0].input && this.addInputOutput(), this.addUnrecognized(), this.isSetup = !0
                    }
                    buildCharactersFromIterable(t) {
                        const e = {};
                        for (let n = 0, i = t.length; n < i; n++) {
                            const i = t[n];
                            if (i.hasOwnProperty("length")) {
                                const t = i;
                                for (let n = 0, i = t.length; n < i; n++) {
                                    const i = t[n];
                                    e.hasOwnProperty(i) || (e[i] = !0, this.characters.push(i))
                                }
                            } else if ("number" == typeof i) {
                                if (e.hasOwnProperty(i)) continue;
                                e[i] = !0, this.characters.push(i)
                            } else if ("boolean" == typeof i) {
                                const t = i.toString();
                                if (e.hasOwnProperty(t)) continue;
                                e[t] = !0, this.characters.push(t)
                            } else if (Array.isArray(i) && "string" == typeof i[0])
                                for (let t = 0; t < i.length; t++) {
                                    const n = i[t];
                                    e.hasOwnProperty(n) || (e[n] = !0, this.characters.push(n))
                                } else if (!Array.isArray(i) || "number" != typeof i[0] && "boolean" != typeof i[0]) {
                                    if (!i.hasOwnProperty("input") || !i.hasOwnProperty("output")) throw new Error("Unhandled value"); {
                                        const {
                                            input: t,
                                            output: n
                                        } = i;
                                        Array.isArray(t) ? this.addCharacters(t, e) : this.addCharacters(t.toString(), e), Array.isArray(n) ? this.addCharacters(n, e) : this.addCharacters(n.toString(), e)
                                    }
                                } else
                                    for (let t = 0; t < i.length; t++) {
                                        const s = i[t].toString();
                                        e.hasOwnProperty(n) || (e[s] = !0, this.characters.push(s))
                                    }
                        }
                    }
                    addCharacters(t, e) {
                        for (let n = 0; n < t.length; n++) {
                            const i = t[n].toString();
                            e.hasOwnProperty(i) || (e[i] = !0, this.characters.push(i))
                        }
                    }
                    buildTables(t) {
                        const e = this.characters.length;
                        for (let n = 0; n < e; n++) {
                            const e = this.characters[n];
                            n >= t && (this.indexTable[e] = n, this.characterTable[n] = e)
                        }
                    }
                    toIndexes(t, e = 0) {
                        const n = [],
                            {
                                indexTable: i
                            } = this;
                        switch (typeof t) {
                            case "number":
                            case "boolean":
                                t = t.toString()
                        }
                        for (let s = 0, r = t.length; s < r; s++) {
                            const r = t[s].toString();
                            let a = i[r];
                            if (void 0 === a) {
                                if (!i.unrecognized) throw new Error(`unrecognized character "${r}"`);
                                a = i.unrecognized
                            }
                            a < e || n.push(a)
                        }
                        return n
                    }
                    toIndexesInputOutput(t, e, n = 0) {
                        const i = this.toIndexesValue(t, n, !0);
                        return void 0 === e ? i : i.concat(this.toIndexesValue(e, n, !1))
                    }
                    toIndexesValue(t, e, n) {
                        if ("string" == typeof t) t = t.split("");
                        else if ("number" == typeof t || "boolean" == typeof t) t = t.toString().split("");
                        else {
                            if (!Array.isArray(t) || "number" != typeof t[0] && "boolean" != typeof t[0] && "string" != typeof t[0]) throw new Error("unrecognized value");
                            t = t.map((t => t.toString()))
                        }
                        return n && (t = t.concat(["stop-input", "start-output"])), this.toIndexes(t, e)
                    }
                    toCharacters(t, e = 0) {
                        const n = [],
                            {
                                indexTable: i,
                                characterTable: s
                            } = this;
                        for (let r = 0, a = t.length; r < a; r++) {
                            const a = t[r];
                            if (a < e) continue;
                            let o = s[a];
                            if (void 0 === o) {
                                if (!i.unrecognized) throw new Error(`unrecognized index "${a}"`);
                                o = s[i.unrecognized]
                            } else null !== o && n.push(o.toString())
                        }
                        return n
                    }
                    toString(t, e) {
                        return this.toCharacters(t, e).join("")
                    }
                    addInputOutput() {
                        this.addSpecial("stop-input"), this.addSpecial("start-output")
                    }
                    addUnrecognized() {
                        this.addSpecial("unrecognized")
                    }
                    static fromAllPrintable(t, e = ["\n"]) {
                        for (let t = 32; t <= 126; t++) e.push(String.fromCharCode(t));
                        return new ti(e, t)
                    }
                    static fromAllPrintableInputOutput(t, e = ["\n"]) {
                        const n = ti.fromAllPrintable(t, e);
                        return n.addInputOutput(), n.addUnrecognized(), n
                    }
                    static fromStringInputOutput(t, e) {
                        const n = Array.from(new Set(t)).join(""),
                            i = new ti(n.split(""), e);
                        return i.addInputOutput(), i.addUnrecognized(), i.isSetup = !0, i
                    }
                    static fromArrayInputOutput(t, e) {
                        const n = [];
                        for (let e = 0; e < t.length; e++) {
                            const i = t[e];
                            n.push(ei(i.input), ei(i.output))
                        }
                        const i = Array.isArray(n) ? n.flat() : n,
                            s = new ti(Array.from(new Set(i)), e);
                        return s.addInputOutput(), s.addUnrecognized(), s.isSetup = !0, s
                    }
                    static fromString(t, e = 0) {
                        const n = Array.from(new Set(t)).join("");
                        return new ti(n.split(""), e)
                    }
                    toJSON() {
                        return {
                            indexTable: this.indexTable,
                            characterTable: this.characterTable,
                            values: this.values,
                            characters: this.characters,
                            specialIndexes: this.specialIndexes
                        }
                    }
                    static fromJSON(t) {
                        const e = new ti;
                        return e.indexTable = t.indexTable, e.characterTable = t.characterTable, e.values = t.values, e.characters = t.characters, e.specialIndexes = t.specialIndexes, e.isSetup = !0, e
                    }
                    addSpecial(t, e = null) {
                        const n = this.indexTable[t] = this.characters.length;
                        this.characterTable[n] = e, this.specialIndexes.push(this.characters.length), this.characters.push(t)
                    }
                    toFunctionString() {
                        return `\nvar characterTable = ${JSON.stringify(this.characterTable)};\nvar indexTable = ${JSON.stringify(this.indexTable)};\nvar characters = ${JSON.stringify(this.characters)};\nvar dataFormatter = {\n  toIndexes: function ${this.toIndexes.toString()},\n  toIndexesInputOutput: function ${this.toIndexesInputOutput.toString()},\n  toCharacters: function ${this.toCharacters.toString()},\n  toIndexesValue: function ${this.toIndexesValue.toString()},\n};`
                    }
                    formatDataIn(t, e) {
                        var n;
                        return void 0 === t ? [] : Array.isArray(t) && "number" == typeof t[0] ? t : (null === (n = this.indexTable) || void 0 === n ? void 0 : n.hasOwnProperty("stop-input")) ? this.toIndexesInputOutput(t, e) : this.toIndexes(t)
                    }
                    formatDataOut(t, e) {
                        return this.toCharacters(e).join("")
                    }
                    format(t) {
                        if (!("number" != typeof t[0] || Array.isArray(t[0]) || t[0].hasOwnProperty("input") && t[0].hasOwnProperty("output"))) return t;
                        const e = [];
                        if ("string" == typeof t[0] || "number" == typeof t[0] || Array.isArray(t[0]))
                            if (this.isSetup)
                                for (let n = 0, i = t.length; n < i; n++) e.push(this.formatDataIn(t[n]));
                            else {
                                this.setup(t);
                                for (let n = 0; n < t.length; n++) e.push(this.formatDataIn(ei(t[n])))
                            }
                        else {
                            if (!t[0].input || !t[0].output) throw new Error("unrecognized data");
                            this.isSetup || this.setup(t);
                            for (let n = 0, i = t.length; n < i; n++) e.push(this.formatDataIn(ei(t[n].input), ei(t[n].output)))
                        }
                        return e
                    }
                }

                function ei(t) {
                    if ("string" == typeof t) return t;
                    if ("number" == typeof t) return t.toString();
                    if ("boolean" == typeof t) return t.toString();
                    if (Array.isArray(t) && "string" == typeof t[0]) return t;
                    if ("boolean" == typeof t[0]) return t.map((t => t.toString()));
                    if ("number" == typeof t[0]) return t.map((t => t.toString()));
                    throw new Error("unrecognized value, expected string[], string, number[], number, boolean[], or boolean")
                }

                function ni(t, e, n) {
                    for (let i = 0; i < e.weights.length; i++) t.weights[i] = e.weights[i] + n.weights[i], t.deltas[i] = 0
                }

                function ii(t, e, n) {
                    for (let i = 0; i < t.deltas.length; i++) e.deltas[i] = t.deltas[i], n.deltas[i] = t.deltas[i]
                }

                function si(t) {
                    for (let e = 0; e < t.weights.length; e++) t.weights[e] = 1, t.deltas[e] = 0
                }

                function ri(t, e) {
                    t.rows = e.rows, t.columns = e.columns, t.weights = e.weights.slice(0), t.deltas = e.deltas.slice(0);
                    for (let n = 0; n < e.weights.length; n++) t.weights[n] = -e.weights[n], t.deltas[n] = 0
                }

                function ai(t, e, n) {
                    const i = e.rows,
                        s = e.columns,
                        r = n.columns;
                    for (let a = 0; a < i; a++) {
                        const i = s * a,
                            o = r * a;
                        for (let a = 0; a < r; a++) {
                            let u = 0;
                            for (let t = 0; t < s; t++) {
                                const s = i + t,
                                    o = r * t + a;
                                u += e.weights[s] * n.weights[o], e.deltas[s] = 0, n.deltas[o] = 0
                            }
                            t.weights[o + a] = u
                        }
                    }
                }

                function oi(t, e, n) {
                    const i = e.rows,
                        s = e.columns,
                        r = n.columns;
                    for (let a = 0; a < i; a++) {
                        const i = s * a,
                            o = r * a;
                        for (let a = 0; a < r; a++)
                            for (let u = 0; u < s; u++) {
                                const s = i + u,
                                    h = r * u + a,
                                    l = t.deltas[o + a];
                                e.deltas[s] += n.weights[h] * l, n.deltas[h] += e.weights[s] * l
                            }
                    }
                }

                function ui(t, e, n) {
                    const {
                        weights: i
                    } = e;
                    for (let s = 0; s < i.length; s++) t.weights[s] = e.weights[s] * n.weights[s], t.deltas[s] = 0
                }

                function hi(t, e, n) {
                    for (let i = 0; i < e.weights.length; i++) e.deltas[i] = n.weights[i] * t.deltas[i], n.deltas[i] = e.weights[i] * t.deltas[i]
                }

                function li(t, e) {
                    for (let n = 0; n < e.weights.length; n++) t.weights[n] = Math.max(0, e.weights[n]), t.deltas[n] = 0
                }

                function ci(t, e) {
                    for (let n = 0; n < t.deltas.length; n++) e.deltas[n] = e.weights[n] > 0 ? t.deltas[n] : 0
                }

                function pi(t, e, n) {
                    const {
                        columns: i
                    } = e, s = i * n;
                    for (let n = 0; n < i; n++) t.weights[n] = e.weights[s + n], t.deltas[n] = 0
                }

                function di(t, e, n) {
                    const {
                        columns: i
                    } = e, s = i * n;
                    for (let n = 0; n < i; n++) e.deltas[s + n] = t.deltas[n]
                }

                function mi(t, e) {
                    for (let n = 0; n < e.weights.length; n++) t.weights[n] = 1 / (1 + Math.exp(-e.weights[n])), t.deltas[n] = 0
                }

                function gi(t, e) {
                    for (let n = 0; n < t.deltas.length; n++) {
                        const i = t.weights[n];
                        e.deltas[n] = i * (1 - i) * t.deltas[n]
                    }
                }

                function fi(t) {
                    const e = new Jn(t.rows, t.columns);
                    let n = -999999;
                    for (let e = 0; e < t.weights.length; e++) t.weights[e] > n && (n = t.weights[e]);
                    let i = 0;
                    for (let s = 0; s < t.weights.length; s++) e.weights[s] = Math.exp(t.weights[s] - n), i += e.weights[s];
                    for (let n = 0; n < t.weights.length; n++) e.weights[n] /= i;
                    return e
                }

                function yi(t, e) {
                    for (let n = 0; n < e.weights.length; n++) t.weights[n] = Math.tanh(e.weights[n]), t.deltas[n] = 0
                }

                function xi(t, e) {
                    for (let n = 0; n < t.deltas.length; n++) {
                        const i = t.weights[n];
                        e.deltas[n] = (1 - i * i) * t.deltas[n]
                    }
                }
                class _i {
                    constructor() {
                        this.states = [], this.inputRow = 0
                    }
                    add(t, e) {
                        if (t.weights.length !== e.weights.length) throw new Error("misaligned matrices");
                        const n = new Jn(t.rows, t.columns);
                        return this.states.push({
                            name: "add",
                            product: n,
                            left: t,
                            right: e,
                            forwardFn: ni,
                            backpropagationFn: ii
                        }), n
                    }
                    allOnes(t, e) {
                        const n = new Jn(t, e);
                        return this.states.push({
                            name: "allOnes",
                            product: n,
                            left: n,
                            forwardFn: si,
                            backpropagationFn: () => {}
                        }), n
                    }
                    cloneNegative(t) {
                        const e = new Jn(t.rows, t.columns);
                        return this.states.push({
                            name: "cloneNegative",
                            product: e,
                            left: t,
                            forwardFn: ri,
                            backpropagationFn: () => {}
                        }), e
                    }
                    subtract(t, e) {
                        if (t.weights.length !== e.weights.length) throw new Error("misaligned matrices");
                        return this.add(this.add(this.allOnes(t.rows, t.columns), this.cloneNegative(t)), e)
                    }
                    multiply(t, e) {
                        if (t.columns !== e.rows) throw new Error("misaligned matrices");
                        const n = new Jn(t.rows, e.columns);
                        return this.states.push({
                            name: "multiply",
                            product: n,
                            left: t,
                            right: e,
                            forwardFn: ai,
                            backpropagationFn: oi
                        }), n
                    }
                    multiplyElement(t, e) {
                        if (t.weights.length !== e.weights.length) throw new Error("misaligned matrices");
                        const n = new Jn(t.rows, t.columns);
                        return this.states.push({
                            name: "multiplyElement",
                            product: n,
                            left: t,
                            right: e,
                            forwardFn: ui,
                            backpropagationFn: hi
                        }), n
                    }
                    relu(t) {
                        const e = new Jn(t.rows, t.columns);
                        return this.states.push({
                            name: "relu",
                            product: e,
                            left: t,
                            forwardFn: li,
                            backpropagationFn: ci
                        }), e
                    }
                    input(t) {
                        return this.states.push({
                            name: "input",
                            product: t,
                            forwardFn: e => {
                                if (this.inputValue) {
                                    if (this.inputValue.length !== e.weights.length) throw new Error("this.inputValue is of wrong dimensions");
                                    e.weights = t.weights = this.inputValue
                                }
                            },
                            backpropagationFn: () => {}
                        }), t
                    }
                    inputMatrixToRow(t) {
                        const e = this,
                            n = new Jn(t.columns, 1);
                        return this.states.push({
                            name: "inputMatrixToRow",
                            product: n,
                            left: t,
                            get right() {
                                return e.inputRow
                            },
                            forwardFn: pi,
                            backpropagationFn: di
                        }), n
                    }
                    sigmoid(t) {
                        const e = new Jn(t.rows, t.columns);
                        return this.states.push({
                            name: "sigmoid",
                            product: e,
                            left: t,
                            forwardFn: mi,
                            backpropagationFn: gi
                        }), e
                    }
                    tanh(t) {
                        const e = new Jn(t.rows, t.columns);
                        return this.states.push({
                            name: "tanh",
                            product: e,
                            left: t,
                            forwardFn: yi,
                            backpropagationFn: xi
                        }), e
                    }
                    observe(t) {
                        return this.states.push({
                            name: "observe",
                            product: new Jn,
                            forwardFn: () => {},
                            backpropagationFn: () => {}
                        }), t
                    }
                    runIndex(t = 0) {
                        this.inputRow = t;
                        let e = this.states[0];
                        for (let t = 0, n = this.states.length; t < n; t++) e = this.states[t], e.hasOwnProperty("forwardFn") && e.forwardFn(e.product, e.left, e.right);
                        return e.product
                    }
                    runInput(t) {
                        this.inputValue = t;
                        let e = this.states[0];
                        for (let t = 0, n = this.states.length; t < n; t++) e = this.states[t], e.hasOwnProperty("forwardFn") && e.forwardFn(e.product, e.left, e.right);
                        return e.product
                    }
                    backpropagate() {
                        let t = this.states.length,
                            e = this.states[0];
                        for (; t-- > 0;) e = this.states[t], e.hasOwnProperty("backpropagationFn") && e.backpropagationFn(e.product, e.left, e.right);
                        return e.product
                    }
                    backpropagateIndex(t = 0) {
                        this.inputRow = t;
                        let e = this.states.length,
                            n = this.states[0];
                        for (; e-- > 0;) n = this.states[e], n.hasOwnProperty("backpropagationFn") && n.backpropagationFn(n.product, n.left, n.right);
                        return n.product
                    }
                    predictTarget(t, e) {
                        let n = 0;
                        const i = this.runInput(t);
                        for (let t = 0; t < i.weights.length; t++) {
                            const s = i.weights[t] - e[t];
                            n += Math.abs(s), i.deltas[t] = s
                        }
                        return n
                    }
                    predictTargetIndex(t, e) {
                        const n = this.runIndex(t),
                            i = n,
                            s = fi(n);
                        return i.deltas = s.weights.slice(0), i.deltas[e] -= 1, -Math.log2(s.weights[e])
                    }
                }

                function bi(t) {
                    const {
                        weights: e
                    } = t;
                    let n = e[0],
                        i = 0;
                    for (let t = 1; t < e.length; t++) {
                        const s = e[t];
                        s < n || (i = t, n = s)
                    }
                    return i
                }

                function wi(t) {
                    const e = ft(0, 1),
                        n = t.weights;
                    let i = 0,
                        s = 0;
                    for (;;) {
                        if (i += n[s], i > e) return s;
                        s++
                    }
                }
                const Ti = {
                        iterations: 2e4,
                        errorThresh: .005,
                        log: !1,
                        logPeriod: 10,
                        learningRate: .01,
                        callbackPeriod: 10,
                        timeout: 1 / 0
                    },
                    vi = () => ({
                        inputSize: 20,
                        inputRange: 20,
                        hiddenLayers: [20, 20],
                        outputSize: 20,
                        decayRate: .999,
                        smoothEps: 1e-8,
                        regc: 1e-6,
                        clipval: 5,
                        maxPredictionLength: 100,
                        dataFormatter: new ti
                    });
                class Ei {
                    constructor(t = {}) {
                        this.options = {
                            ...vi()
                        }, this.trainOpts = {
                            ...Ti
                        }, this.stepCache = {}, this.runs = 0, this.ratioClipped = 0, this.model = Object.seal({
                            isInitialized: !1,
                            input: new Jn(0, 0),
                            hiddenLayers: [],
                            output: new Jn(0, 0),
                            equations: [],
                            allMatrices: [],
                            equationConnections: [],
                            outputConnector: new Qn(0, 0, .08)
                        }), this.initialLayerInputs = [], this.options = {
                            ...this.options,
                            ...t
                        }, this.updateTrainingOptions({
                            ...Ti
                        }), t.json && this.fromJSON(t.json)
                    }
                    initialize() {
                        const {
                            dataFormatter: t
                        } = this.options;
                        (null == t ? void 0 : t.characters.length) && (this.options.inputSize = this.options.inputRange = this.options.outputSize = t.characters.length), this.model = this.mapModel()
                    }
                    createHiddenLayers() {
                        const {
                            hiddenLayers: t,
                            inputSize: e
                        } = this.options, n = [];
                        n.push(this.getHiddenLayer(t[0], e));
                        let i = t[0];
                        for (let e = 1; e < t.length; e++) {
                            const s = t[e];
                            n.push(this.getHiddenLayer(s, i)), i = s
                        }
                        return n
                    }
                    getHiddenLayer(t, e) {
                        return {
                            weight: new Qn(t, e, .08),
                            transition: new Qn(t, t, .08),
                            bias: new Jn(t, 1)
                        }
                    }
                    getEquation(t, e, n, i) {
                        if (!i.weight || !i.transition || !i.bias) throw new Error("hiddenLayer does not have expected properties");
                        const s = t.relu.bind(t),
                            r = t.add.bind(t),
                            a = t.multiply.bind(t);
                        return s(r(r(a(i.weight, e), a(i.transition, n)), i.bias))
                    }
                    createInputMatrix() {
                        const {
                            inputRange: t,
                            inputSize: e
                        } = this.options;
                        if (t < 1) throw new Error("this.options.inputRange not an expected number");
                        if (e < 1) throw new Error("this.options.inputSize not an expected number");
                        return new Qn(t + 1, e, .08)
                    }
                    createOutputMatrices() {
                        const {
                            outputSize: t,
                            hiddenLayers: e
                        } = this.options, n = Ai(e);
                        return {
                            outputConnector: new Qn(t + 1, n, .08),
                            output: new Jn(t + 1, 1)
                        }
                    }
                    bindEquation() {
                        const {
                            model: t
                        } = this, {
                            hiddenLayers: e
                        } = this.options, n = new _i, i = [], s = t.equationConnections.length > 0 ? Ai(t.equationConnections) : this.initialLayerInputs;
                        let r = this.getEquation(n, n.inputMatrixToRow(t.input), s[0], t.hiddenLayers[0]);
                        i.push(r);
                        for (let a = 1, o = e.length; a < o; a++) {
                            if (!s[a]) throw new Error(`Cannot find equation at index ${a}`);
                            r = this.getEquation(n, r, s[a], t.hiddenLayers[a]), i.push(r)
                        }
                        t.equationConnections.push(i), n.add(n.multiply(t.outputConnector, r), t.output), t.equations.push(n)
                    }
                    mapModel() {
                        const t = [];
                        this.initialLayerInputs = this.options.hiddenLayers.map((t => new Jn(t, 1)));
                        const e = this.createInputMatrix();
                        t.push(e);
                        const n = this.createHiddenLayers();
                        if (!n.length) throw new Error("net.hiddenLayers not set");
                        for (let e = 0, i = n.length; e < i; e++) {
                            const i = n[e];
                            for (const e in i) i.hasOwnProperty(e) && t.push(i[e])
                        }
                        const {
                            output: i,
                            outputConnector: s
                        } = this.createOutputMatrices();
                        return t.push(s), t.push(i), Object.seal({
                            isInitialized: !0,
                            input: e,
                            hiddenLayers: n,
                            output: i,
                            equations: [],
                            allMatrices: t,
                            equationConnections: [],
                            outputConnector: s
                        })
                    }
                    trainInput(t) {
                        this.runs++;
                        const {
                            model: e
                        } = this, n = t.length;
                        let i, s = 0;
                        for (; e.equations.length <= t.length + 1;) this.bindEquation();
                        for (let r = -1, a = t.length; r < a; r++) {
                            const a = r + 1;
                            i = e.equations[a];
                            const o = -1 === r ? 0 : t[r] + 1,
                                u = r === n - 1 ? 0 : t[r + 1] + 1;
                            s += i.predictTargetIndex(o, u)
                        }
                        return Math.pow(2, s / (n - 1)) / 100
                    }
                    backpropagate(t) {
                        let e = t.length;
                        const {
                            model: n
                        } = this, {
                            equations: i
                        } = n;
                        for (; e > 0;) i[e].backpropagateIndex(t[e - 1] + 1), e--;
                        i[0].backpropagateIndex(0)
                    }
                    adjustWeights() {
                        const {
                            regc: t,
                            clipval: e,
                            decayRate: n,
                            smoothEps: i
                        } = this.options, {
                            trainOpts: s,
                            model: r,
                            stepCache: a
                        } = this, {
                            learningRate: o
                        } = s, {
                            allMatrices: u
                        } = r;
                        let h = 0,
                            l = 0;
                        for (let s = 0; s < u.length; s++) {
                            const r = u[s],
                                {
                                    weights: c,
                                    deltas: p
                                } = r;
                            s in a || (a[s] = k(r.rows * r.columns));
                            const d = a[s];
                            for (let s = 0; s < c.length; s++) {
                                let r = p[s];
                                const a = c[s];
                                d[s] = d[s] * n + (1 - n) * r * r, r > e ? (r = e, h++) : r < -e && (r = -e, h++), l++, c[s] = a + -o * r / Math.sqrt(d[s] + i) - t * a
                            }
                        }
                        this.ratioClipped = h / l
                    }
                    get isRunnable() {
                        return !this.model || 0 !== this.model.equations.length || (console.error("No equations bound, did you run train()?"), !1)
                    }
                    checkRunnable() {
                        if (!this.isRunnable) throw new Error("Network not runnable")
                    }
                    run(t = [], e = !1, n = 1) {
                        const i = this.options.maxPredictionLength + (null !== t ? t.length : 0) + (this.options.dataFormatter ? this.options.dataFormatter.specialIndexes.length : 0);
                        this.checkRunnable();
                        const s = this.options.dataFormatter && t.length > 0 ? this.options.dataFormatter.formatDataIn(t) : t,
                            {
                                model: r
                            } = this,
                            a = [];
                        let o = 0;
                        for (;;) {
                            const t = 0 === o ? 0 : o < s.length ? s[o - 1] + 1 : a[o - 1];
                            for (; r.equations.length <= o;) this.bindEquation();
                            const l = r.equations[o].runIndex(t),
                                c = new Jn(r.output.rows, r.output.columns);
                            if (h = l, (u = c).rows = h.rows, u.columns = h.columns, u.weights = h.weights.slice(0), u.deltas = h.deltas.slice(0), 1 !== n && e)
                                for (let t = 0, e = c.weights.length; t < e; t++) c.weights[t] /= n;
                            const p = fi(c),
                                d = e ? wi(p) : bi(p);
                            if (o++, 0 === d) break;
                            if (o >= i) break;
                            a.push(d)
                        }
                        var u, h;
                        return this.options.dataFormatter.formatDataOut(s, a.slice(s.length).map((t => t - 1)))
                    }
                    verifyIsInitialized() {
                        this.model.isInitialized || this.initialize()
                    }
                    updateTrainingOptions(t) {
                        var e;
                        this.trainOpts = {
                            ...Ti,
                            ...t
                        }, this.validateTrainingOptions(this.trainOpts), this.setLogMethod(null !== (e = t.log) && void 0 !== e ? e : this.trainOpts.log)
                    }
                    validateTrainingOptions(t) {
                        const e = {
                            iterations: () => {
                                const e = t.iterations;
                                return "number" == typeof e && e > 0
                            },
                            errorThresh: () => {
                                const e = t.errorThresh;
                                return "number" == typeof e && e > 0 && e < 1
                            },
                            log: () => {
                                const e = t.log;
                                return "function" == typeof e || "boolean" == typeof e
                            },
                            logPeriod: () => {
                                const e = t.logPeriod;
                                return "number" == typeof e && e > 0
                            },
                            learningRate: () => {
                                const e = t.learningRate;
                                return "number" == typeof e && e > 0 && e < 1
                            },
                            callback: () => {
                                const e = t.callback;
                                return "function" == typeof e || void 0 === e
                            },
                            callbackPeriod: () => {
                                const e = t.callbackPeriod;
                                return "number" == typeof e && e > 0
                            },
                            timeout: () => {
                                const e = t.timeout;
                                return "number" == typeof e && e > 0
                            }
                        };
                        for (const n in e) {
                            const i = t;
                            if (!e[n]()) throw new Error(`[${n}, ${i[n]}] is out of normal training range, your network will probably not train.`)
                        }
                    }
                    setLogMethod(t) {
                        this.trainOpts.log = "function" == typeof t ? t : !!t && console.log
                    }
                    prepTraining(t, e) {
                        var n;
                        this.updateTrainingOptions(e);
                        const i = this.options.dataFormatter.format(t),
                            s = Date.now() + (null !== (n = this.trainOpts.timeout) && void 0 !== n ? n : 0);
                        return this.verifyIsInitialized(), {
                            preparedData: i,
                            status: {
                                error: 1,
                                iterations: 0
                            },
                            endTime: s
                        }
                    }
                    train(t, e = {}) {
                        var n;
                        this.trainOpts = e = {
                            ...Ti,
                            ...e
                        };
                        const {
                            iterations: i,
                            errorThresh: s,
                            logPeriod: r,
                            callback: a,
                            callbackPeriod: o
                        } = this.trainOpts, u = !0 === e.log ? console.log : e.log;
                        let h, l, c = 1 / 0;
                        if (null === (n = this.options) || void 0 === n ? void 0 : n.dataFormatter) l = this.options.dataFormatter.format(t);
                        else {
                            if (!Array.isArray(t) || !Array.isArray(t[0]) || "number" != typeof t[0][0]) throw new Error("training not in expected format of number[][]");
                            l = t
                        }
                        for (this.verifyIsInitialized(), h = 0; h < i && c > s; h++) {
                            let e = 0;
                            for (let t = 0; t < l.length; t++) e += this.trainPattern(l[t], !0);
                            if (c = e / t.length, isNaN(c)) throw new Error("Network error rate is unexpected NaN, check network configurations and try again. Most probably input format is not correct or training data is not enough. ");
                            u && h % r == 0 && u(`iterations: ${h}, training error: ${c}`), a && h % o == 0 && a({
                                error: c,
                                iterations: h
                            })
                        }
                        return {
                            error: c,
                            iterations: h
                        }
                    }
                    addFormat(t) {}
                    formatData(t) {
                        const e = [];
                        for (let n = 0; n < t.length; n++) e.push(this.options.dataFormatter.formatDataIn(t[n]));
                        return e
                    }
                    toJSON() {
                        this.model.isInitialized || this.initialize();
                        const {
                            model: t,
                            options: e
                        } = this;
                        return {
                            type: this.constructor.name,
                            options: {
                                ...e,
                                dataFormatter: e.dataFormatter.toJSON()
                            },
                            trainOpts: {
                                ...this.trainOpts,
                                timeout: this.trainOpts.timeout === 1 / 0 ? "Infinity" : this.trainOpts.timeout
                            },
                            input: t.input.toJSON(),
                            hiddenLayers: t.hiddenLayers.map((t => {
                                const e = {};
                                for (const n in t) t.hasOwnProperty(n) && (e[n] = t[n].toJSON());
                                return e
                            })),
                            outputConnector: this.model.outputConnector.toJSON(),
                            output: this.model.output.toJSON()
                        }
                    }
                    fromJSON(t) {
                        const {
                            options: e
                        } = t, n = [], i = Jn.fromJSON(t.input);
                        n.push(i);
                        const s = [];
                        t.hiddenLayers.forEach((t => {
                            const e = {};
                            for (const i in t) e[i] = Jn.fromJSON(t[i]), n.push(e[i]);
                            s.push(e)
                        }));
                        const r = Jn.fromJSON(t.outputConnector);
                        n.push(r);
                        const a = Jn.fromJSON(t.output);
                        return n.push(a), e.dataFormatter ? this.options = {
                            ...vi(),
                            ...e,
                            dataFormatter: ti.fromJSON(e.dataFormatter)
                        } : this.options = {
                            ...vi(),
                            ...e,
                            dataFormatter: new ti
                        }, this.model = Object.seal({
                            isInitialized: !0,
                            input: i,
                            hiddenLayers: s,
                            output: a,
                            allMatrices: n,
                            outputConnector: r,
                            equations: [],
                            equationConnections: []
                        }), this.initialLayerInputs = this.options.hiddenLayers.map((t => new Jn(t, 1))), this.bindEquation(), this
                    }
                    toFunction(t) {
                        const {
                            model: e
                        } = this, {
                            equations: n
                        } = this.model, i = n[1], {
                            states: s
                        } = i, r = JSON.stringify(this.toJSON());

                        function a(t) {
                            const i = e.equationConnections[0],
                                {
                                    states: s
                                } = n[0];
                            for (let e = 0, n = s.length; e < n; e++)
                                if (s[e].product === t) return e;
                            return i.indexOf(t)
                        }

                        function o(t, n) {
                            if (!t || !t.rows || !t.columns) return "null";
                            if (t === e.input) return "json.input";
                            if (t === e.outputConnector) return "json.outputConnector";
                            if (t === e.output) return "json.output";
                            for (let n = 0, i = e.hiddenLayers.length; n < i; n++) {
                                const i = e.hiddenLayers[n];
                                for (const e in i)
                                    if (i.hasOwnProperty(e) && i[e] === t) return `json.hiddenLayers[${n}].${e}`
                            }
                            return function(t, e) {
                                for (let n = 0, i = s.length; n < i; n++) {
                                    const i = s[n];
                                    if (n === e) {
                                        const e = a(t);
                                        return e > -1 && (t === i.left || t === i.right) ? `typeof prevStates[${e}] === 'object' ? prevStates[${e}].product : new Matrix(${t.rows}, ${t.columns})` : `new Matrix(${t.rows}, ${t.columns})`
                                    }
                                    if (t === i.product) return `states[${n}].product`;
                                    if (t === i.right) return `states[${n}].right`;
                                    if (t === i.left) return `states[${n}].left`
                                }
                                return ""
                            }(t, n)
                        }

                        function u(t) {
                            const e = t.toString().split("{");
                            e.shift();
                            const n = e.join("{").split("}");
                            return n.pop(), n.join("}").split("\n").join("\n        ").replace("product.deltas[i] = 0;", "").replace("product.deltas[column] = 0;", "").replace("left.deltas[leftIndex] = 0;", "").replace("right.deltas[rightIndex] = 0;", "").replace("product.deltas = left.deltas.slice(0);", "")
                        }

                        function h(t) {
                            return `src/recurrent/matrix/${t.replace(/[A-Z]/g,(function(t){return`-${t.toLowerCase()}`}))}.js`
                        }
                        const l = [],
                            c = {},
                            p = [];
                        for (let t = 0, e = s.length; t < e; t++) {
                            const e = s[t];
                            l.push(`states[${t}] = {\n      name: '${e.forwardFn.name}',\n      left: ${e.left?o(e.left,t):"undefined"},\n      right: ${e.right?o(e.right,t):"undefined"},\n      product: ${o(e.product,t)}\n    }`);
                            const n = e.forwardFn.name;
                            c[n] || (c[n] = !0, p.push(`        case '${n}': //compiled from ${h(n)}\n          ${u(e.forwardFn.toString())}\n          break;`))
                        }
                        const d = `\n  if (typeof rawInput === 'undefined') rawInput = [];\n  if (typeof isSampleI === 'undefined') isSampleI = false;\n  if (typeof temperature === 'undefined') temperature = 1;\n  var json = ${r};\n  ${this.options.dataFormatter?`${this.options.dataFormatter.toFunctionString()};\n  Object.assign(dataFormatter, json.options.dataFormatter);`:""}\n  ${this.options.dataFormatter&&"function"==typeof this.options.dataFormatter.formatDataIn?`const formatDataIn = function (input, output) { ${u(this.options.dataFormatter.formatDataIn.toString())} }.bind(dataFormatter);`:""}\n  ${null!==this.options.dataFormatter&&"function"==typeof this.options.dataFormatter.formatDataOut?`const formatDataOut = function formatDataOut(input, output) { ${u(this.options.dataFormatter.formatDataOut.toString())} }.bind(dataFormatter);`:""}\n  var maxPredictionLength =\n    ${this.options.maxPredictionLength} +\n    rawInput.length +\n    ${this.options.dataFormatter?this.options.dataFormatter.specialIndexes.length:0};\n  var input = ${this.options.dataFormatter&&"function"==typeof this.options.dataFormatter.formatDataIn?"formatDataIn(rawInput)":"rawInput"};\n  var _i = 0;\n  var output = [];\n  var states = [];\n  var prevStates;\n  while (true) {\n    var previousIndex = (_i === 0\n        ? 0\n        : _i < input.length\n          ? input[_i - 1] + 1\n          : output[_i - 1])\n          ;\n    var rowPluckIndex = previousIndex;\n    prevStates = states;\n    states = [];\n    ${l.join(";\n    ")};\n    for (var stateIndex = 0, stateMax = ${l.length}; stateIndex < stateMax; stateIndex++) {\n      var state = states[stateIndex];\n      var product = state.product;\n      var left = state.left;\n      var right = state.right;\n      switch (state.name) {\n${p.join("\n")}\n      }\n    }\n\n    var logProbabilities = state.product;\n    if (temperature !== 1 && isSampleI) {\n      for (var q = 0, nq = logProbabilities.weights.length; q < nq; q++) {\n        logProbabilities.weights[q] /= temperature;\n      }\n    }\n\n    var probs = softmax(logProbabilities);\n    var nextIndex = isSampleI ? sampleI(probs) : maxI(probs);\n\n    _i++;\n    if (nextIndex === 0) {\n      break;\n    }\n    if (_i >= maxPredictionLength) {\n      break;\n    }\n\n    output.push(nextIndex);\n  }\n  ${this.options.dataFormatter&&"function"==typeof this.options.dataFormatter.formatDataOut?"return formatDataOut(input, output.slice(input.length).map(function(value) { return value - 1; }))":"return output.slice(input.length).map(function(value) { return value - 1; })"};\n  function Matrix(rows, columns) {\n    this.rows = rows;\n    this.columns = columns;\n    this.weights = zeros(rows * columns);\n  }\n  ${k.toString()}\n  ${fi.toString().replace("_1.Matrix","Matrix")}\n  ${ft.toString()}\n  ${wi.toString()}\n  ${bi.toString()}`;
                        return new Function("rawInput", "isSampleI", "temperature", t ? t(d) : d)
                    }
                    trainPattern(t, e) {
                        const n = this.trainInput(t);
                        return this.backpropagate(t), this.adjustWeights(), e ? n : 0
                    }
                }

                function Ai(t) {
                    return t[t.length - 1]
                }
                class Ii extends Ei {
                    getHiddenLayer(t, e) {
                        return Si(t, e)
                    }
                    getEquation(t, e, n, i) {
                        return ki(t, e, n, i)
                    }
                }

                function Si(t, e) {
                    return {
                        updateGateInputMatrix: new Qn(t, e, .08),
                        updateGateHiddenMatrix: new Qn(t, t, .08),
                        updateGateBias: new Jn(t, 1),
                        resetGateInputMatrix: new Qn(t, e, .08),
                        resetGateHiddenMatrix: new Qn(t, t, .08),
                        resetGateBias: new Jn(t, 1),
                        cellWriteInputMatrix: new Qn(t, e, .08),
                        cellWriteHiddenMatrix: new Qn(t, t, .08),
                        cellWriteBias: new Jn(t, 1)
                    }
                }

                function ki(t, e, n, i) {
                    if (!(i.updateGateInputMatrix && i.updateGateHiddenMatrix && i.updateGateBias && i.resetGateInputMatrix && i.resetGateHiddenMatrix && i.resetGateBias && i.cellWriteInputMatrix && i.cellWriteHiddenMatrix && i.cellWriteBias)) throw new Error("hiddenLayer does not have expected properties");
                    const s = t.sigmoid.bind(t),
                        r = t.add.bind(t),
                        a = t.multiply.bind(t),
                        o = t.multiplyElement.bind(t),
                        u = t.tanh.bind(t),
                        h = t.allOnes.bind(t),
                        l = t.cloneNegative.bind(t),
                        c = s(r(r(a(i.updateGateInputMatrix, e), a(i.updateGateHiddenMatrix, n)), i.updateGateBias)),
                        p = s(r(r(a(i.resetGateInputMatrix, e), a(i.resetGateHiddenMatrix, n)), i.resetGateBias)),
                        d = u(r(r(a(i.cellWriteInputMatrix, e), a(i.cellWriteHiddenMatrix, o(p, n))), i.cellWriteBias));
                    return r(o(r(h(c.rows, c.columns), l(c)), d), o(n, c))
                }
                class Di {
                    constructor(t, e) {
                        this.prop = e, this.length = 0, this.table = {};
                        for (let n = 0; n < t.length; n++) {
                            const i = t[n][e];
                            for (let t = 0; t < i.length; t++) {
                                const e = i[t];
                                for (const t in e) e.hasOwnProperty(t) && (this.table.hasOwnProperty(t) || (this.table[t] = this.length++))
                            }
                        }
                    }
                }
                const Li = () => ({
                    ...vi(),
                    inputSize: 1,
                    hiddenLayers: [20],
                    outputSize: 1,
                    inputRange: 0
                });
                class Ci extends Ei {
                    constructor(t = {}) {
                        super(), this.inputLookupLength = 0, this.inputLookup = null, this.outputLookup = null, this.outputLookupLength = 0, this.model = Object.seal({
                            isInitialized: !1,
                            hiddenLayers: [],
                            output: new Jn(0, 0),
                            equations: [],
                            allMatrices: [],
                            equationConnections: [],
                            outputConnector: new Qn(0, 0, .08)
                        }), this.options = Li(), this.options = {
                            ...this.options,
                            ...t
                        }, this.updateTrainingOptions({
                            ...Mi,
                            ...t
                        }), t.json && this.fromJSON(t.json)
                    }
                    createInputMatrix() {
                        throw new Error("Input Matrices do not exist on RNNTimeStep")
                    }
                    createOutputMatrices() {
                        const {
                            outputSize: t
                        } = this.options, e = Ai(this.options.hiddenLayers), n = new Qn(t, e, .08);
                        return {
                            output: new Qn(t, 1, .08),
                            outputConnector: n
                        }
                    }
                    bindEquation() {
                        const {
                            model: t,
                            options: e
                        } = this, {
                            hiddenLayers: n,
                            inputSize: i
                        } = e, s = t.hiddenLayers, r = new _i, a = [], o = t.equationConnections.length > 0 ? t.equationConnections[t.equationConnections.length - 1] : this.initialLayerInputs;
                        let u = this.getEquation(r, r.input(new Jn(i, 1)), o[0], s[0]);
                        a.push(u);
                        for (let t = 1, e = n.length; t < e; t++) u = this.getEquation(r, u, o[t], s[t]), a.push(u);
                        t.equationConnections.push(a), r.add(r.multiply(t.outputConnector, u), t.output), t.equations.push(r)
                    }
                    initialize() {
                        this.model = this.mapModel()
                    }
                    mapModel() {
                        const t = [];
                        this.initialLayerInputs = this.options.hiddenLayers.map((t => new Jn(t, 1)));
                        const e = this.createHiddenLayers();
                        for (let n = 0, i = e.length; n < i; n++) {
                            const i = e[n];
                            for (const e in i) i.hasOwnProperty(e) && t.push(i[e])
                        }
                        const {
                            outputConnector: n,
                            output: i
                        } = this.createOutputMatrices();
                        return t.push(n), t.push(i), Object.seal({
                            isInitialized: !0,
                            hiddenLayers: e,
                            output: i,
                            equations: [],
                            allMatrices: t,
                            equationConnections: [],
                            outputConnector: n
                        })
                    }
                    backpropagate() {
                        for (let t = this.model.equations.length - 1; t > -1; t--) this.model.equations[t].backpropagate()
                    }
                    run(t) {
                        const e = K.dataShape(t).join(",");
                        switch (e) {
                            case "array,number":
                                return this.runArray(t);
                            case "array,array,number":
                                return this.runArrayOfArray(t);
                            case "object,number":
                                return this.runObject(t);
                            case "array,object,number":
                                return this.runArrayOfObject(t);
                            default:
                                throw new Error(`Unrecognized data shape ${e}`)
                        }
                    }
                    forecast(t, e = 1) {
                        const n = K.dataShape(t).join(",");
                        switch (n) {
                            case "array,number":
                                return this.forecastArray(t, e);
                            case "array,array,number":
                                return this.forecastArrayOfArray(t, e);
                            case "object,number":
                                return this.runObject(t);
                            case "array,object,number":
                                return this.forecastArrayOfObject(t, e);
                            default:
                                throw new Error(`Unrecognized data shape ${n}`)
                        }
                    }
                    forecastArray(t, e = 1) {
                        this.checkRunnable();
                        const {
                            model: n
                        } = this, {
                            equations: i
                        } = n, s = t.length + e;
                        for (; i.length <= s;) this.bindEquation();
                        let r, a = 0;
                        if (1 === this.options.inputSize)
                            for (let e = 0; e < t.length; e++) r = i[a++].runInput(Float32Array.from([t[e]]));
                        else
                            for (let e = 0; e < t.length; e++) r = i[a++].runInput(Float32Array.from([]));
                        if (!r) throw new Error("lastOutput not set");
                        const o = [r.weights[0]];
                        for (let t = 0, n = e - 1; t < n; t++) r = i[a++].runInput(r.weights), o.push(r.weights[0]);
                        return this.end(), Float32Array.from(o)
                    }
                    forecastArrayOfArray(t, e = 1) {
                        this.checkRunnable();
                        const {
                            model: n
                        } = this, {
                            equations: i
                        } = n, s = t.length + e;
                        for (; i.length <= s;) this.bindEquation();
                        let r, a = 0;
                        for (let e = 0; e < t.length; e++) r = i[a++].runInput(t[e]);
                        if (!r) throw new Error("lastOutput not set");
                        const o = [Float32Array.from(r.weights)];
                        for (let t = 0, n = e - 1; t < n; t++) r = i[a++].runInput(r.weights), o.push(Float32Array.from(r.weights.slice(0)));
                        return this.end(), o
                    }
                    forecastArrayOfObject(t, e = 1) {
                        if (!this.inputLookup) throw new Error("this.inputLookup not set");
                        if (!this.outputLookup) throw new Error("this.outputLookup not set");
                        const n = t.map((t => K.toArray(this.inputLookup, t, this.inputLookupLength)));
                        return this.forecastArrayOfArray(n, e).map((t => K.toObject(this.outputLookup, t)))
                    }
                    train(t, e = {}) {
                        this.trainOpts = e = {
                            ...Ti,
                            ...e
                        }, 1 === this.options.inputSize && 1 === this.options.outputSize && this.setSize(t), this.verifySize();
                        const n = this.formatData(t);
                        let i, s = 1 / 0;
                        this.verifyIsInitialized();
                        const {
                            iterations: r,
                            errorThresh: a,
                            logPeriod: o,
                            callback: u,
                            callbackPeriod: h
                        } = this.trainOpts, l = !0 === e.log ? console.log : e.log;
                        for (i = 0; i < r && s > a; i++) {
                            let t = 0;
                            for (let e = 0; e < n.length; e++) t += this.trainPattern(n[e], !0);
                            if (s = t / n.length, isNaN(s)) throw new Error("Network error rate is unexpected NaN, check network configurations and try again. Most probably input format is not correct or training data is not enough. ");
                            l && i % o == 0 && l(`iterations: ${i}, training error: ${s}`), u && i % h == 0 && u({
                                error: s,
                                iterations: i
                            })
                        }
                        return {
                            error: s,
                            iterations: i
                        }
                    }
                    trainArrayOfArray(t) {
                        if (t.length < 2) throw new Error("input must be an array of 2 or more");
                        const {
                            equations: e
                        } = this.model;
                        for (; e.length < t.length;) this.bindEquation();
                        let n = 0;
                        for (let i = 0, s = t.length - 1; i < s; i++) n += e[i].predictTarget(t[i], t[i + 1]);
                        return this.end(), n / t.length
                    }
                    trainPattern(t, e) {
                        const n = this.trainArrayOfArray(t);
                        return this.backpropagate(), this.adjustWeights(), e ? n : 0
                    }
                    setSize(t) {
                        let e = 0;
                        switch (K.dataShape(t).join(",")) {
                            case "array,array,number":
                            case "array,object,number":
                            case "array,datum,array,number":
                            case "array,datum,object,number":
                                e = 1;
                                break;
                            case "array,array,array,number":
                                e = t[0][0].length;
                                break;
                            case "array,array,object,number":
                                e = Object.keys(K.toTable2D(t)).length;
                                break;
                            case "array,datum,array,array,number":
                                e = t[0].input[0].length;
                                break;
                            case "array,datum,array,object,number":
                                e = Object.keys(K.toInputTable2D(t)).length;
                                break;
                            default:
                                throw new Error("unknown data shape or configuration")
                        }
                        this.options = Object.seal({
                            ...this.options,
                            inputSize: e,
                            outputSize: e
                        })
                    }
                    verifySize() {
                        if ((this.options.inputSize || this.options.outputSize) && this.options.inputSize !== this.options.outputSize) throw new Error("manually set inputSize and outputSize mismatch")
                    }
                    runArray(t) {
                        this.checkRunnable();
                        const {
                            equations: e
                        } = this.model;
                        for (; e.length <= t.length;) this.bindEquation();
                        let n;
                        for (let i = 0; i < t.length; i++) n = e[i].runInput(new Float32Array([t[i]]));
                        return this.end(), n.weights[0]
                    }
                    runArrayOfArray(t) {
                        this.checkRunnable();
                        const {
                            model: e
                        } = this, {
                            equations: n
                        } = e;
                        for (; n.length <= t.length;) this.bindEquation();
                        let i;
                        for (let e = 0; e < t.length; e++) i = n[e].runInput(t[e]).weights;
                        return this.end(), null != i ? i : Float32Array.from([])
                    }
                    runObject(t) {
                        if (!this.inputLookup) throw new Error("this.inputLookup not set");
                        if (!this.outputLookup) throw new Error("this.outputLookup not set");
                        if (!this.outputLookupLength) throw new Error("this.outputLookupLength not set");
                        if (this.inputLookup === this.outputLookup) {
                            const e = K.toArrayShort(this.inputLookup, t);
                            return K.toObjectPartial(this.outputLookup, this.forecastArray(e, this.outputLookupLength - e.length), e.length)
                        }
                        return K.toObject(this.outputLookup, this.forecastArray(K.toArray(this.inputLookup, t, this.inputLookupLength), this.outputLookupLength))
                    }
                    runArrayOfObject(t) {
                        if (null === this.inputLookup) throw new Error("this.inputLookup not set");
                        if (null === this.outputLookup) throw new Error("this.outputLookup not set");
                        const e = t.map((t => K.toArray(this.inputLookup, t, this.inputLookupLength)));
                        return this.forecastArrayOfArray(e, 1).map((t => K.toObject(this.outputLookup, t)))[0]
                    }
                    runArrayOfObjectOfArray(t) {
                        if (!this.inputLookup) throw new Error("this.inputLookup not set");
                        if (!this.outputLookup) throw new Error("this.outputLookup not set");
                        return K.toObject(this.outputLookup, this.runArrayOfArray(K.toArrays(this.inputLookup, t, this.inputLookupLength)))
                    }
                    end() {
                        this.model.equations[this.model.equations.length - 1].runInput(new Float32Array(this.options.outputSize))
                    }
                    requireInputOutputOfOne() {
                        if (1 !== this.options.inputSize) throw new Error("inputSize must be 1 for this data size");
                        if (1 !== this.options.outputSize) throw new Error("outputSize must be 1 for this data size")
                    }
                    formatArray(t) {
                        const e = [];
                        this.requireInputOutputOfOne();
                        for (let n = 0; n < t.length; n++) e.push(Float32Array.from([t[n]]));
                        return [e]
                    }
                    formatArrayOfArray(t) {
                        const e = [],
                            {
                                inputSize: n,
                                outputSize: i
                            } = this.options;
                        if (1 === n && 1 === i) {
                            for (let n = 0; n < t.length; n++) e.push(En(t[n]));
                            return e
                        }
                        if (n !== t[0].length) throw new Error("inputSize must match data input size");
                        if (i !== t[0].length) throw new Error("outputSize must match data output size");
                        for (let n = 0; n < t.length; n++) e.push(Float32Array.from(t[n]));
                        return [e]
                    }
                    formatArrayOfObject(t) {
                        if (this.requireInputOutputOfOne(), !this.inputLookup) {
                            const e = new dn(t);
                            this.inputLookup = this.outputLookup = e.table, this.inputLookupLength = this.outputLookupLength = e.length
                        }
                        const e = [];
                        for (let n = 0; n < t.length; n++) e.push(kn(t[n]));
                        return e
                    }
                    formatArrayOfObjectMulti(t) {
                        if (!this.inputLookup) {
                            const e = new dn(t);
                            this.inputLookup = this.outputLookup = e.table, this.inputLookupLength = this.outputLookupLength = e.length
                        }
                        const e = [];
                        for (let n = 0; n < t.length; n++) e.push([Ln(t[n], this.inputLookup, this.inputLookupLength)]);
                        return e
                    }
                    formatArrayOfDatumOfArray(t) {
                        const e = [];
                        this.requireInputOutputOfOne();
                        for (let n = 0; n < t.length; n++) {
                            const i = t[n];
                            e.push(An(i.input, i.output))
                        }
                        return e
                    }
                    formatArrayOfDatumOfObject(t) {
                        if (this.requireInputOutputOfOne(), !this.inputLookup) {
                            const e = new dn(t, "input");
                            this.inputLookup = e.table, this.inputLookupLength = e.length
                        }
                        if (!this.outputLookup) {
                            const e = new dn(t, "output");
                            this.outputLookup = e.table, this.outputLookupLength = e.length
                        }
                        const e = [];
                        for (let n = 0; n < t.length; n++) {
                            const i = t[n];
                            e.push(Dn(i.input, i.output))
                        }
                        return e
                    }
                    formatArrayOfArrayOfArray(t) {
                        const e = [];
                        for (let n = 0; n < t.length; n++) e.push(Tn(t[n]));
                        return e
                    }
                    formatArrayOfArrayOfObject(t) {
                        if (!this.inputLookup) {
                            const e = new dn(t);
                            this.inputLookup = this.outputLookup = e.table, this.inputLookupLength = this.outputLookupLength = e.length
                        }
                        const e = [];
                        for (let n = 0; n < t.length; n++) {
                            const i = [];
                            for (let e = 0; e < t[n].length; e++) i.push(Ln(t[n][e], this.inputLookup, this.inputLookupLength));
                            e.push(i)
                        }
                        return e
                    }
                    formatArrayOfDatumOfArrayOfArray(t) {
                        const e = [],
                            {
                                inputSize: n,
                                outputSize: i
                            } = this.options;
                        if (n !== t[0].input[0].length) throw new Error("inputSize must match data input size");
                        if (i !== t[0].output[0].length) throw new Error("outputSize must match data output size");
                        for (let n = 0; n < t.length; n++) {
                            const i = t[n];
                            e.push(vn(i.input, i.output))
                        }
                        return e
                    }
                    formatArrayOfDatumOfArrayOfObject(t) {
                        if (!this.inputLookup) {
                            const e = new Di(t, "input");
                            this.inputLookup = e.table, this.inputLookupLength = e.length
                        }
                        if (!this.outputLookup) {
                            const e = new Di(t, "output");
                            this.outputLookup = e.table, this.outputLookupLength = e.length
                        }
                        if (!this.outputLookupLength) throw new Error("this.outputLookupLength not set to usable number");
                        const e = [];
                        for (let n = 0; n < t.length; n++) {
                            const i = t[n];
                            e.push(Sn(i.input, i.output, this.inputLookup, this.outputLookup, this.inputLookupLength, this.outputLookupLength))
                        }
                        return e
                    }
                    formatData(t) {
                        switch (K.dataShape(t).join(",")) {
                            case "array,number":
                                return this.formatArray(t);
                            case "array,array,number":
                                return this.formatArrayOfArray(t);
                            case "array,object,number":
                                return 1 === this.options.inputSize ? this.formatArrayOfObject(t) : this.formatArrayOfObjectMulti(t);
                            case "array,datum,array,number":
                                return this.formatArrayOfDatumOfArray(t);
                            case "array,datum,object,number":
                                return this.formatArrayOfDatumOfObject(t);
                            case "array,array,array,number":
                                return this.formatArrayOfArrayOfArray(t);
                            case "array,array,object,number":
                                return this.formatArrayOfArrayOfObject(t);
                            case "array,datum,array,array,number":
                                return this.formatArrayOfDatumOfArrayOfArray(t);
                            case "array,datum,array,object,number":
                                return this.formatArrayOfDatumOfArrayOfObject(t);
                            default:
                                throw new Error("unknown data shape or configuration")
                        }
                    }
                    test(t) {
                        const e = [];
                        let n = 0;
                        const i = this.formatData(t);
                        for (let s = 0; s < i.length; s++) {
                            const r = i[s],
                                a = this.run(r.splice(0, r.length - 1)),
                                o = r[r.length - 1];
                            let u = 0,
                                h = 0;
                            for (let t = 0; t < a.length; t++) {
                                h++;
                                const e = o[t] - a[t];
                                u += e * e
                            }
                            if (n += u / h, Math.abs(u) > this.trainOpts.errorThresh) {
                                const n = t[s];
                                e.push({
                                    value: n,
                                    actual: a
                                })
                            }
                        }
                        return {
                            error: n / i.length,
                            misclasses: e,
                            total: i.length
                        }
                    }
                    addFormat(t) {
                        var e, n, i, s, r, a;
                        switch (K.dataShape(t).join(",")) {
                            case "array,array,number":
                            case "datum,array,array,number":
                            case "array,number":
                            case "datum,array,number":
                                return;
                            case "datum,object,number":
                                this.inputLookup = K.addKeys(t.input, null !== (e = this.inputLookup) && void 0 !== e ? e : {}), this.inputLookup && (this.inputLookupLength = Object.keys(this.inputLookup).length), this.outputLookup = K.addKeys(t.output, null !== (n = this.outputLookup) && void 0 !== n ? n : {}), this.outputLookup && (this.outputLookupLength = Object.keys(this.outputLookup).length);
                                break;
                            case "object,number":
                                this.inputLookup = this.outputLookup = K.addKeys(t, null !== (i = this.inputLookup) && void 0 !== i ? i : {}), this.inputLookup && (this.inputLookupLength = this.outputLookupLength = Object.keys(this.inputLookup).length);
                                break;
                            case "array,object,number": {
                                const e = t;
                                for (let t = 0; t < e.length; t++) this.inputLookup = this.outputLookup = K.addKeys(e[t], null !== (s = this.inputLookup) && void 0 !== s ? s : {}), this.inputLookup && (this.inputLookupLength = this.outputLookupLength = Object.keys(this.inputLookup).length);
                                break
                            }
                            case "datum,array,object,number": {
                                const e = t,
                                    n = e.input;
                                for (let t = 0; t < n.length; t++) this.inputLookup = K.addKeys(n[t], null !== (r = this.inputLookup) && void 0 !== r ? r : {}), this.inputLookup && (this.inputLookupLength = Object.keys(this.inputLookup).length);
                                const i = e.output;
                                for (let t = 0; t < i.length; t++) this.outputLookup = K.addKeys(i[t], null !== (a = this.outputLookup) && void 0 !== a ? a : {}), this.outputLookup && (this.outputLookupLength = Object.keys(this.outputLookup).length);
                                break
                            }
                            default:
                                throw new Error("unknown data shape or configuration")
                        }
                    }
                    toJSON() {
                        this.model || this.initialize();
                        const {
                            model: t
                        } = this, e = {
                            ...this.options,
                            ...vi
                        };
                        return {
                            type: this.constructor.name,
                            options: e,
                            hiddenLayers: t.hiddenLayers.map((t => {
                                const e = {};
                                for (const n in t) t.hasOwnProperty(n) && (e[n] = t[n].toJSON());
                                return e
                            })),
                            outputConnector: t.outputConnector.toJSON(),
                            output: t.output.toJSON(),
                            inputLookup: this.inputLookup,
                            inputLookupLength: this.inputLookupLength,
                            outputLookup: this.outputLookup,
                            outputLookupLength: this.outputLookupLength
                        }
                    }
                    fromJSON(t) {
                        const {
                            options: e
                        } = t, n = [], i = [];
                        t.hiddenLayers.forEach((t => {
                            const e = {};
                            for (const i in t) e[i] = Jn.fromJSON(t[i]), n.push(e[i]);
                            i.push(e)
                        }));
                        const s = Jn.fromJSON(t.outputConnector);
                        n.push(s);
                        const r = Jn.fromJSON(t.output);
                        return n.push(r), this.options = {
                            ...Li(),
                            ...e
                        }, this.inputLookup = t.inputLookup, this.inputLookupLength = t.inputLookupLength, this.outputLookup = t.outputLookup, this.outputLookupLength = t.outputLookupLength, this.model = Object.seal({
                            isInitialized: !0,
                            hiddenLayers: i,
                            output: r,
                            allMatrices: n,
                            outputConnector: s,
                            equations: [],
                            equationConnections: []
                        }), this.initialLayerInputs = e.hiddenLayers.map((t => new Jn(t, 1))), this.bindEquation(), this
                    }
                    toFunction(t) {
                        const {
                            model: e,
                            inputLookup: n,
                            inputLookupLength: i,
                            outputLookup: s,
                            outputLookupLength: r
                        } = this, {
                            inputSize: a
                        } = this.options, {
                            equations: o
                        } = e, u = o[1], {
                            states: h
                        } = u, l = JSON.stringify(this.toJSON());

                        function c(t) {
                            const n = e.equationConnections[0],
                                {
                                    states: i
                                } = o[0];
                            for (let e = 0, n = i.length; e < n; e++)
                                if (i[e].product === t) return e;
                            return n.indexOf(t)
                        }

                        function p(t, n) {
                            if (!t || !t.rows || !t.columns) return "null";
                            if (t === e.outputConnector) return "json.outputConnector";
                            if (t === e.output) return "json.output";
                            for (let n = 0, i = e.hiddenLayers.length; n < i; n++) {
                                const i = e.hiddenLayers[n];
                                for (const e in i)
                                    if (i.hasOwnProperty(e) && i[e] === t) return `json.hiddenLayers[${n}].${e}`
                            }
                            return function(t, e) {
                                for (let n = 0, i = h.length; n < i; n++) {
                                    const i = h[n];
                                    if (n === e) {
                                        const e = c(t);
                                        switch (t) {
                                            case i.left:
                                                if (e > -1) return `typeof prevStates[${e}] === 'object' ? prevStates[${e}].product : new Matrix(${t.rows}, ${t.columns})`;
                                            case i.right:
                                                if (e > -1) return `typeof prevStates[${e}] === 'object' ? prevStates[${e}].product : new Matrix(${t.rows}, ${t.columns})`;
                                            case i.product:
                                                return `new Matrix(${t.rows}, ${t.columns})`;
                                            default:
                                                throw Error("unknown state")
                                        }
                                    }
                                    if (t === i.product) return `states[${n}].product`;
                                    if (t === i.right) return `states[${n}].right`;
                                    if (t === i.left) return `states[${n}].left`
                                }
                                return ""
                            }(t, n)
                        }

                        function d(t) {
                            const e = t.toString().split("{");
                            e.shift();
                            const n = e.join("{").split("}");
                            return n.pop(), n.join("}").split("\n").join("\n        ").replace("product.deltas[i] = 0;", "").replace("product.deltas[column] = 0;", "").replace("left.deltas[leftIndex] = 0;", "").replace("right.deltas[rightIndex] = 0;", "").replace("product.deltas = left.deltas.slice(0);", "")
                        }

                        function m(t) {
                            return `src/recurrent/matrix/${t.replace(/[A-Z]/g,(function(t){return`-${t.toLowerCase()}`}))}.js`
                        }
                        const g = [],
                            f = {},
                            y = [];
                        for (let t = 0, e = h.length; t < e; t++) {
                            const e = h[t];
                            g.push(`states[${t}] = {\n      name: '${e.forwardFn.name}',\n      left: ${e.left?p(e.left,t):"undefined"},\n      right: ${e.right?p(e.right,t):"undefined"},\n      product: ${p(e.product,t)}\n    }`);
                            const i = e.forwardFn.name;
                            f[i] || (f[i] = !0, "input" === e.name ? (y.push(`case '${i}':`), y.push(n && 1 === a ? "product.weights = _i < input.length ? input[_i]: prevStates[prevStates.length - 1].product.weights;" : 1 === a ? "product.weights = [input[_i]];" : "product.weights = input[_i];"), y.push("break;")) : y.push(`        case '${i}':${"forwardFn"!==i?` //compiled from ${m(i)}`:""}\n          ${d(e.forwardFn.toString())}\n          break;`))
                        }
                        const x = 1 === a && this.outputLookup,
                            _ = `\n  var input = ${this.inputLookup?"lookupInput(rawInput)":"rawInput"};\n  var json = ${l};\n  var output = [];\n  var states = [];\n  var prevStates;\n  var state;\n  var max = ${x?n===s?i:"input.length + "+(r-1):"input.length"};\n  for (var _i = 0; _i < max; _i++) {\n    prevStates = states;\n    states = [];\n    ${g.join(";\n    ")};\n    for (var stateIndex = 0, stateMax = ${g.length}; stateIndex < stateMax; stateIndex++) {\n      state = states[stateIndex];\n      var product = state.product;\n      var left = state.left;\n      var right = state.right;\n\n      switch (state.name) {\n${y.join("\n")}\n      }\n    }\n    ${1===a&&n?"if (_i >= input.length - 1) { output.push(state.product.weights); }":"output = state.product.weights;"}\n  }\n  ${s?s===n?"return lookupOutputPartial(output, input)":"return lookupOutput(output)":1===a?"return output[0]":"return output"};\n  ${n?1===a?n===s?`function lookupInput(input) {\n            var table = ${JSON.stringify(n)};\n            var result = [];\n            for (var p in table) {\n              if (!input.hasOwnProperty(p)) break;\n              result.push(Float32Array.from([input[p]]));\n            }\n            return result;\n          }`:`function lookupInput(input) {\n          var table = ${JSON.stringify(n)};\n          var result = [];\n          for (var p in table) {\n            result.push(Float32Array.from([input[p]]));\n          }\n          return result;\n        }`:`function lookupInput(rawInputs) {\n        var table = ${JSON.stringify(n)};\n        var result = [];\n        for (var i = 0; i < rawInputs.length; i++) {\n          var rawInput = rawInputs[i];\n          var input = new Float32Array(${i});\n          for (var p in table) {\n            input[table[p]] = rawInput.hasOwnProperty(p) ? rawInput[p] : 0;\n          }\n          result.push(input);\n        }\n        return result;\n      }`:""}\n  ${s?1===a?n===s?`function lookupOutputPartial(output, input) {\n            var table = ${JSON.stringify(s)};\n            var offset = input.length;\n            var result = {};\n            var i = 0;\n            for (var p in table) {\n              if (i++ < offset) continue;\n              result[p] = output[table[p] - offset][0];\n            }\n            return result;\n          }`:`function lookupOutput(output) {\n          var table = ${JSON.stringify(s)};\n          var result = {};\n          for (var p in table) {\n            result[p] = output[table[p]][0];\n          }\n          return result;\n        }`:`function lookupOutput(output) {\n        var table = ${JSON.stringify(s)};\n        var result = {};\n        for (var p in table) {\n          result[p] = output[table[p]];\n        }\n        return result;\n      }`:""}\n\n  function Matrix(rows, columns) {\n    this.rows = rows;\n    this.columns = columns;\n    this.weights = new Float32Array(rows * columns);\n  }\n  ${fi.toString().replace("_2.default","Matrix")}\n  ${ft.toString()}\n  ${wi.toString()}\n  ${bi.toString()}`;
                        return new Function("rawInput", t ? t(_) : _)
                    }
                }
                const Mi = {
                    ...Ti
                };
                class Oi extends Ci {
                    getHiddenLayer(t, e) {
                        return Si(t, e)
                    }
                    getEquation(t, e, n, i) {
                        return ki(t, e, n, i)
                    }
                }
                class Ri extends Ei {
                    getHiddenLayer(t, e) {
                        return Ni(t, e)
                    }
                    getEquation(t, e, n, i) {
                        return Pi(t, e, n, i)
                    }
                }

                function Ni(t, e) {
                    return {
                        inputMatrix: new Qn(t, e, .08),
                        inputHidden: new Qn(t, t, .08),
                        inputBias: new Jn(t, 1),
                        forgetMatrix: new Qn(t, e, .08),
                        forgetHidden: new Qn(t, t, .08),
                        forgetBias: new Jn(t, 1),
                        outputMatrix: new Qn(t, e, .08),
                        outputHidden: new Qn(t, t, .08),
                        outputBias: new Jn(t, 1),
                        cellActivationMatrix: new Qn(t, e, .08),
                        cellActivationHidden: new Qn(t, t, .08),
                        cellActivationBias: new Jn(t, 1)
                    }
                }

                function Pi(t, e, n, i) {
                    if (!(i.inputMatrix && i.inputHidden && i.inputBias && i.forgetMatrix && i.forgetHidden && i.forgetBias && i.outputMatrix && i.outputHidden && i.outputBias && i.cellActivationMatrix && i.cellActivationHidden && i.cellActivationBias)) throw new Error("hiddenLayer does not have expected properties");
                    const s = t.sigmoid.bind(t),
                        r = t.add.bind(t),
                        a = t.multiply.bind(t),
                        o = t.multiplyElement.bind(t),
                        u = t.tanh.bind(t),
                        h = s(r(r(a(i.inputMatrix, e), a(i.inputHidden, n)), i.inputBias)),
                        l = s(r(r(a(i.forgetMatrix, e), a(i.forgetHidden, n)), i.forgetBias)),
                        c = s(r(r(a(i.outputMatrix, e), a(i.outputHidden, n)), i.outputBias)),
                        p = u(r(r(a(i.cellActivationMatrix, e), a(i.cellActivationHidden, n)), i.cellActivationBias)),
                        d = o(l, n),
                        m = o(h, p);
                    return o(c, u(r(d, m)))
                }
                class $i extends Ci {
                    getHiddenLayer(t, e) {
                        return Ni(t, e)
                    }
                    getEquation(t, e, n, i) {
                        return Pi(t, e, n, i)
                    }
                }

                function Ui({
                    pixelX: t,
                    pixelY: e,
                    radius: n,
                    inputs: i,
                    row: s,
                    line: r,
                    fontSize: a,
                    fontClassName: o
                }) {
                    let u = `<rect\n              x="${t/2-n}"\n              y="${e/2+s*e-n}"\n              width="${2*n}"\n              height="${2*n}"\n              stroke="black"\n              stroke-width="1"\n              fill="${i.color}"\n              class="${i.className}" />\n            <line\n              x1="${t/4}"\n              y1="${e/2+s*e}"\n              x2="${t/2-n}"\n              y2="${e/2+s*e}"\n              style="stroke:${r.color};stroke-width:${r.width}"\n              class="${r.className}" />`;
                    return i.labels && (u += `<text\n              x="${t/8}"\n              y="${e/2+s*e-5}"\n              fill="black"\n              font-size="${a}"\n              class="${o}">${i.labels[s]}</text>`), u
                }

                function Fi({
                    pixelX: t,
                    pixelY: e,
                    row: n,
                    column: i,
                    radius: s,
                    hidden: r
                }) {
                    return `<circle\n            cx="${t/2+i*t}"\n            cy="${e/2+n*e}"\n            r="${s}"\n            stroke="black"\n            stroke-width="1"\n            fill="${r.color}"\n            class="${r.className}" />`
                }

                function Bi({
                    pixelX: t,
                    pixelY: e,
                    row: n,
                    column: i,
                    line: s,
                    outputs: r,
                    radius: a
                }) {
                    return `<circle\n            cx="${t/2+i*t}"\n            cy="${e/2+n*e}"\n            r="${a}"\n            stroke="black"\n            stroke-width="1"\n            fill="${r.color}"\n            class="${r.className}" />\n          <line\n            x1="${t/2+i*t+a}"\n            y1="${e/2+n*e}"\n            x2="${t/2+i*t+t/4}"\n            y2="${e/2+n*e}"\n            style="stroke:${s.color};stroke-width:${s.width}"\n            class="${s.className}" />`
                }

                function zi({
                    pixelX: t,
                    pixelY: e,
                    row: n,
                    column: i,
                    radius: s,
                    lineY: r,
                    line: a,
                    previousConnectionIndex: o
                }) {
                    return `<line\n            x1="${t/2+(i-1)*t+s}"\n            y1="${r/2+o*r}"\n            x2="${t/2+i*t-s}"\n            y2="${e/2+n*e}"\n            style="stroke:${a.color};stroke-width:${a.width}"\n            class="${a.className}" />`
                }

                function Vi(t) {
                    const {
                        sizes: e,
                        height: n,
                        width: i
                    } = t;
                    let s = "";
                    const r = i / e.length;
                    for (let i = 0; i < e.length; i++) {
                        const a = e[i],
                            o = n / a;
                        for (let u = 0; u < a; u++)
                            if (0 === i) s += Ui({
                                pixelX: r,
                                pixelY: o,
                                row: u,
                                column: i,
                                ...t
                            });
                            else {
                                i === e.length - 1 ? s += Bi({
                                    pixelX: r,
                                    pixelY: o,
                                    row: u,
                                    column: i,
                                    ...t
                                }) : s += Fi({
                                    pixelX: r,
                                    pixelY: o,
                                    row: u,
                                    column: i,
                                    ...t
                                });
                                const a = e[i - 1],
                                    h = n / a;
                                for (let e = 0; e < a; e++) s += zi({
                                    pixelX: r,
                                    pixelY: o,
                                    row: u,
                                    column: i,
                                    lineY: h,
                                    previousConnectionIndex: e,
                                    ...t
                                })
                            }
                    }
                    return s
                }

                function Ki({
                    pixelX: t,
                    pixelY: e,
                    row: n,
                    column: i,
                    radius: s,
                    recurrentLine: r
                }) {
                    const a = t / 2 + i * t + s + 1,
                        o = e / 2 + n * e,
                        u = a - 2 * s - 2;
                    return `<path\n              d="M ${a} ${o} C ${u+100} ${o+50}, ${a-100} ${o+50}, ${u} ${o}"\n              stroke="${r.color}"\n              stroke-width="${r.width}"\n              fill="transparent"\n              stroke-linecap="round"\n              marker-end="url(#arrow)"\n              class="${r.className}" />`
                }

                function Gi(t) {
                    const {
                        width: e,
                        height: n,
                        recurrentLine: i,
                        sizes: s,
                        radius: r
                    } = t, a = e / s.length;
                    let o = `<defs>\n              <marker id="arrow" markerWidth="10" markerHeight="10" refX="8" refY="3" orient="auto" markerUnits="strokeWidth">\n                <path d="M0,0 L0,6 L9,3 z" fill="${i.color}" />\n              </marker>\n            </defs>`;
                    o += Vi(t);
                    for (let t = 1; t < s.length; t++) {
                        const e = s[t],
                            u = n / e;
                        for (let n = 0; n < e; n++) o += Ki({
                            pixelX: a,
                            pixelY: u,
                            row: n,
                            column: t,
                            radius: r,
                            recurrentLine: i
                        })
                    }
                    return o
                }

                function ji(t, e, n) {
                    return `<svg\n            xmlns="http://www.w3.org/2000/svg"\n            xmlns:xlink="http://www.w3.org/1999/xlink"\n            version="1.1"\n            width="${e}"\n            height="${n}">${t}</svg>`
                }

                function Wi(t) {
                    const {
                        options: e
                    } = t, {
                        inputSize: n,
                        outputSize: i,
                        hiddenLayers: s
                    } = e;
                    return [n].concat(s).concat([i])
                }

                function Hi(t, e) {
                    if (!t) throw new Error("sizes not set");
                    if (t.some((t => t < 1))) throw new Error("sizes not set correctly");
                    if (e && e.length !== t[0]) throw new Error("not enough labels for inputs");
                    return t
                }
                const Xi = {
                        RNNTimeStep: Ci,
                        LSTMTimeStep: $i,
                        GRUTimeStep: Oi,
                        RNN: Ei,
                        LSTM: Ri,
                        GRU: Ii
                    },
                    Zi = {
                        max: Cn,
                        mse: Mn,
                        ones: pe,
                        ones2D: de,
                        random: xt,
                        randomWeight: gt,
                        randos: _t,
                        range: function(t, e) {
                            const n = [];
                            for (; t < e; t++) n.push(t);
                            return n
                        },
                        toArray: function(t) {
                            return Array.isArray(t) ? Float32Array.from(t) : Float32Array.from(Object.values(t))
                        },
                        DataFormatter: ti,
                        zeros: k,
                        toSVG: function(t, e) {
                            const n = {
                                    line: {
                                        width: .5,
                                        color: "black",
                                        className: "connection"
                                    },
                                    recurrentLine: {
                                        width: 1,
                                        color: "red",
                                        className: "recurrence"
                                    },
                                    inputs: {
                                        color: "rgba(0, 128, 0, 0.5)",
                                        labels: null,
                                        className: "input"
                                    },
                                    outputs: {
                                        color: "rgba(100, 149, 237, 0.5)",
                                        className: "output"
                                    },
                                    hidden: {
                                        color: "rgba(255, 127, 80, 0.5)",
                                        className: "hidden-neuron"
                                    },
                                    fontSize: "14px",
                                    fontClassName: "label",
                                    radius: 8,
                                    width: 400,
                                    height: 250,
                                    sizes: [],
                                    ...e
                                },
                                {
                                    width: i,
                                    height: s,
                                    inputs: r
                                } = n;
                            let a = [];
                            if (t instanceof Rn || t instanceof Zn) a = function(t) {
                                const {
                                    options: e,
                                    sizes: n
                                } = t, {
                                    inputSize: i,
                                    outputSize: s,
                                    hiddenLayers: r
                                } = e;
                                if (!n) {
                                    if ("number" == typeof i && i < 1) throw new Error("inputSize not set");
                                    if ("number" == typeof s && s < 1) throw new Error("outputSize not set");
                                    if (null == r ? void 0 : r.some((t => t < 1))) throw new Error("hiddenLayers not set")
                                }
                                return "number" == typeof i && Array.isArray(r) && "number" == typeof s ? [i].concat(r).concat([s]) : n
                            }(t);
                            else if (t instanceof Yn) {
                                const {
                                    inputSize: e,
                                    hiddenLayers: n,
                                    outputSize: i
                                } = function(t) {
                                    const e = [],
                                        {
                                            options: n
                                        } = t;
                                    if (!n.inputLayer) throw new Error("inputLayer not defined");
                                    if (!n.outputLayer) throw new Error("outputLayer not defined");
                                    const i = n.inputLayer();
                                    e.push(n.hiddenLayers[0](i, Fe(), 0));
                                    for (let t = 1; t < n.hiddenLayers.length; t++) e.push(n.hiddenLayers[t](e[t - 1], Fe(), t));
                                    const s = n.outputLayer(e[e.length - 1], -1);
                                    return {
                                        inputSize: i.height,
                                        hiddenLayers: e.map((t => t.height)),
                                        outputSize: s.height
                                    }
                                }(t);
                                a = [e].concat(n).concat([i])
                            } else if (t instanceof wn) {
                                const {
                                    inputSize: e,
                                    hiddenLayers: n,
                                    outputSize: i
                                } = function(t) {
                                    const {
                                        options: e
                                    } = t;
                                    if (!e) throw new Error("options not defined");
                                    if (!e.inputLayer) throw new Error("options.inputLater not defined");
                                    if (!e.hiddenLayers) throw new Error("options.hiddenLayers not defined");
                                    if (e.hiddenLayers.length < 1) throw new Error("options.hiddenLayers is empty");
                                    if (!e.outputLayer) throw new Error("options.outputLayer not defined");
                                    const n = e.inputLayer(),
                                        i = [];
                                    i.push(e.hiddenLayers[0](n, 0));
                                    for (let t = 1; t < e.hiddenLayers.length; t++) i.push(e.hiddenLayers[t](i[t - 1], t));
                                    const s = e.outputLayer(i[i.length - 1], i.length);
                                    return {
                                        inputSize: n.height,
                                        hiddenLayers: i.map((t => t.height)),
                                        outputSize: s.height
                                    }
                                }(t);
                                a = [e].concat(n).concat([i])
                            } else {
                                if (t instanceof Ei || t instanceof Ri || t instanceof Ii || t instanceof Ci || t instanceof $i || t instanceof Oi) return ji(Gi({
                                    ...n,
                                    sizes: Hi(Wi(t), r.labels)
                                }), i, s);
                                if (t.hasOwnProperty("type")) switch (t.type) {
                                    case "NeuralNetwork":
                                    case "NeuralNetworkGPU":
                                        return ji(Vi({
                                            ...n,
                                            sizes: Hi((o = t, o.sizes), r.labels)
                                        }), i, s);
                                    case "RNN":
                                    case "GRU":
                                    case "LSTM":
                                    case "RNNTimeStep":
                                    case "GRUTimeStep":
                                    case "LSTMTimeStep":
                                        return ji(Gi({
                                            ...n,
                                            sizes: Hi(Wi(t), r.labels)
                                        }), i, s);
                                    default:
                                        throw new Error("unrecognized network")
                                } else if (t.hasOwnProperty("inputSize") && t.hasOwnProperty("hiddenLayers") && t.hasOwnProperty("outputSize")) {
                                    const {
                                        inputSize: e,
                                        hiddenLayers: n,
                                        outputSize: i
                                    } = t;
                                    a = [e, ...n, i]
                                } else {
                                    if (!t.hasOwnProperty("sizes")) throw new Error("unrecognized network");
                                    a = t.sizes
                                }
                            }
                            var o;
                            return ji(Vi({
                                ...n,
                                sizes: Hi(a, r.labels)
                            }), i, s)
                        }
                    };
                t.CrossValidate = f, t.FeedForward = wn, t.NeuralNetwork = Rn, t.NeuralNetworkGPU = Zn, t.Recurrent = Yn, t.activation = g, t.layer = ln, t.layerTypes = hn, t.likely = function(t, e) {
                    if (!e) throw new TypeError(`Required parameter 'net' is of type ${typeof e}. Must be of type 'brain.NeuralNetwork'`);
                    const n = e.run(t);
                    let i = null,
                        s = -1;
                    return Object.entries(n).forEach((([t, e]) => {
                        void 0 !== e && "number" == typeof e && e > s && (i = t, s = e)
                    })), i
                }, t.lookup = K, t.praxis = ut, t.recurrent = Xi, t.utilities = Zi, Object.defineProperty(t, "__esModule", {
                    value: !0
                })
            }(e, n(130))
        },
        130: t => {
            t.exports = function t(e, n, i) {
                function s(a, o) {
                    if (!n[a]) {
                        if (!e[a]) {
                            if (r) return r(a, !0);
                            var u = new Error("Cannot find module '" + a + "'");
                            throw u.code = "MODULE_NOT_FOUND", u
                        }
                        var h = n[a] = {
                            exports: {}
                        };
                        e[a][0].call(h.exports, (function(t) {
                            return s(e[a][1][t] || t)
                        }), h, h.exports, t, e, n, i)
                    }
                    return n[a].exports
                }
                for (var r = void 0, a = 0; a < i.length; a++) s(i[a]);
                return s
            }({
                1: [function(t, e, n) {
                    var i, s;
                    i = this, s = function(t) {
                        var e = {
                                3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
                                5: "class enum extends super const export import",
                                6: "enum",
                                strict: "implements interface let package private protected public static yield",
                                strictBind: "eval arguments"
                            },
                            n = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this",
                            i = {
                                5: n,
                                "5module": n + " export import",
                                6: n + " const class extends export import super"
                            },
                            s = /^in(stanceof)?$/,
                            r = "---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------",
                            a = "--------------------------------------------------------------------------------------------------------------------------------------------------",
                            o = new RegExp("[" + r + "]"),
                            u = new RegExp("[" + r + a + "]");
                        r = a = null;
                        var h = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 477, 28, 11, 0, 9, 21, 155, 22, 13, 52, 76, 44, 33, 24, 27, 35, 30, 0, 12, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 0, 33, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 230, 43, 117, 63, 32, 0, 161, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 35, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 270, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 754, 9486, 286, 50, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 2357, 44, 11, 6, 17, 0, 370, 43, 1301, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42710, 42, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541],
                            l = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 525, 10, 176, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 4, 9, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 232, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 135, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 19723, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 419, 13, 1495, 6, 110, 6, 6, 9, 792487, 239];

                        function c(t, e) {
                            for (var n = 65536, i = 0; i < e.length; i += 2) {
                                if ((n += e[i]) > t) return !1;
                                if ((n += e[i + 1]) >= t) return !0
                            }
                        }

                        function p(t, e) {
                            return t < 65 ? 36 === t : t < 91 || (t < 97 ? 95 === t : t < 123 || (t <= 65535 ? t >= 170 && o.test(String.fromCharCode(t)) : !1 !== e && c(t, h)))
                        }

                        function d(t, e) {
                            return t < 48 ? 36 === t : t < 58 || !(t < 65) && (t < 91 || (t < 97 ? 95 === t : t < 123 || (t <= 65535 ? t >= 170 && u.test(String.fromCharCode(t)) : !1 !== e && (c(t, h) || c(t, l)))))
                        }
                        var m = function(t, e) {
                            void 0 === e && (e = {}), this.label = t, this.keyword = e.keyword, this.beforeExpr = !!e.beforeExpr, this.startsExpr = !!e.startsExpr, this.isLoop = !!e.isLoop, this.isAssign = !!e.isAssign, this.prefix = !!e.prefix, this.postfix = !!e.postfix, this.binop = e.binop || null, this.updateContext = null
                        };

                        function g(t, e) {
                            return new m(t, {
                                beforeExpr: !0,
                                binop: e
                            })
                        }
                        var f = {
                                beforeExpr: !0
                            },
                            y = {
                                startsExpr: !0
                            },
                            x = {};

                        function _(t, e) {
                            return void 0 === e && (e = {}), e.keyword = t, x[t] = new m(t, e)
                        }
                        var b = {
                                num: new m("num", y),
                                regexp: new m("regexp", y),
                                string: new m("string", y),
                                name: new m("name", y),
                                eof: new m("eof"),
                                bracketL: new m("[", {
                                    beforeExpr: !0,
                                    startsExpr: !0
                                }),
                                bracketR: new m("]"),
                                braceL: new m("{", {
                                    beforeExpr: !0,
                                    startsExpr: !0
                                }),
                                braceR: new m("}"),
                                parenL: new m("(", {
                                    beforeExpr: !0,
                                    startsExpr: !0
                                }),
                                parenR: new m(")"),
                                comma: new m(",", f),
                                semi: new m(";", f),
                                colon: new m(":", f),
                                dot: new m("."),
                                question: new m("?", f),
                                arrow: new m("=>", f),
                                template: new m("template"),
                                invalidTemplate: new m("invalidTemplate"),
                                ellipsis: new m("...", f),
                                backQuote: new m("`", y),
                                dollarBraceL: new m("${", {
                                    beforeExpr: !0,
                                    startsExpr: !0
                                }),
                                eq: new m("=", {
                                    beforeExpr: !0,
                                    isAssign: !0
                                }),
                                assign: new m("_=", {
                                    beforeExpr: !0,
                                    isAssign: !0
                                }),
                                incDec: new m("++/--", {
                                    prefix: !0,
                                    postfix: !0,
                                    startsExpr: !0
                                }),
                                prefix: new m("!/~", {
                                    beforeExpr: !0,
                                    prefix: !0,
                                    startsExpr: !0
                                }),
                                logicalOR: g("||", 1),
                                logicalAND: g("&&", 2),
                                bitwiseOR: g("|", 3),
                                bitwiseXOR: g("^", 4),
                                bitwiseAND: g("&", 5),
                                equality: g("==/!=/===/!==", 6),
                                relational: g("</>/<=/>=", 7),
                                bitShift: g("<</>>/>>>", 8),
                                plusMin: new m("+/-", {
                                    beforeExpr: !0,
                                    binop: 9,
                                    prefix: !0,
                                    startsExpr: !0
                                }),
                                modulo: g("%", 10),
                                star: g("*", 10),
                                slash: g("/", 10),
                                starstar: new m("**", {
                                    beforeExpr: !0
                                }),
                                _break: _("break"),
                                _case: _("case", f),
                                _catch: _("catch"),
                                _continue: _("continue"),
                                _debugger: _("debugger"),
                                _default: _("default", f),
                                _do: _("do", {
                                    isLoop: !0,
                                    beforeExpr: !0
                                }),
                                _else: _("else", f),
                                _finally: _("finally"),
                                _for: _("for", {
                                    isLoop: !0
                                }),
                                _function: _("function", y),
                                _if: _("if"),
                                _return: _("return", f),
                                _switch: _("switch"),
                                _throw: _("throw", f),
                                _try: _("try"),
                                _var: _("var"),
                                _const: _("const"),
                                _while: _("while", {
                                    isLoop: !0
                                }),
                                _with: _("with"),
                                _new: _("new", {
                                    beforeExpr: !0,
                                    startsExpr: !0
                                }),
                                _this: _("this", y),
                                _super: _("super", y),
                                _class: _("class", y),
                                _extends: _("extends", f),
                                _export: _("export"),
                                _import: _("import", y),
                                _null: _("null", y),
                                _true: _("true", y),
                                _false: _("false", y),
                                _in: _("in", {
                                    beforeExpr: !0,
                                    binop: 7
                                }),
                                _instanceof: _("instanceof", {
                                    beforeExpr: !0,
                                    binop: 7
                                }),
                                _typeof: _("typeof", {
                                    beforeExpr: !0,
                                    prefix: !0,
                                    startsExpr: !0
                                }),
                                _void: _("void", {
                                    beforeExpr: !0,
                                    prefix: !0,
                                    startsExpr: !0
                                }),
                                _delete: _("delete", {
                                    beforeExpr: !0,
                                    prefix: !0,
                                    startsExpr: !0
                                })
                            },
                            w = /\r\n?|\n|\u2028|\u2029/,
                            T = new RegExp(w.source, "g");

                        function v(t, e) {
                            return 10 === t || 13 === t || !e && (8232 === t || 8233 === t)
                        }
                        var E = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/,
                            A = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g,
                            I = Object.prototype,
                            S = I.hasOwnProperty,
                            k = I.toString;

                        function D(t, e) {
                            return S.call(t, e)
                        }
                        var L = Array.isArray || function(t) {
                            return "[object Array]" === k.call(t)
                        };

                        function C(t) {
                            return new RegExp("^(?:" + t.replace(/ /g, "|") + ")$")
                        }
                        var M = function(t, e) {
                            this.line = t, this.column = e
                        };
                        M.prototype.offset = function(t) {
                            return new M(this.line, this.column + t)
                        };
                        var O = function(t, e, n) {
                            this.start = e, this.end = n, null !== t.sourceFile && (this.source = t.sourceFile)
                        };

                        function R(t, e) {
                            for (var n = 1, i = 0;;) {
                                T.lastIndex = i;
                                var s = T.exec(t);
                                if (!(s && s.index < e)) return new M(n, e - i);
                                ++n, i = s.index + s[0].length
                            }
                        }
                        var N = {
                            ecmaVersion: 10,
                            sourceType: "script",
                            onInsertedSemicolon: null,
                            onTrailingComma: null,
                            allowReserved: null,
                            allowReturnOutsideFunction: !1,
                            allowImportExportEverywhere: !1,
                            allowAwaitOutsideFunction: !1,
                            allowHashBang: !1,
                            locations: !1,
                            onToken: null,
                            onComment: null,
                            ranges: !1,
                            program: null,
                            sourceFile: null,
                            directSourceFile: null,
                            preserveParens: !1
                        };

                        function P(t) {
                            var e = {};
                            for (var n in N) e[n] = t && D(t, n) ? t[n] : N[n];
                            if (e.ecmaVersion >= 2015 && (e.ecmaVersion -= 2009), null == e.allowReserved && (e.allowReserved = e.ecmaVersion < 5), L(e.onToken)) {
                                var i = e.onToken;
                                e.onToken = function(t) {
                                    return i.push(t)
                                }
                            }
                            return L(e.onComment) && (e.onComment = function(t, e) {
                                return function(n, i, s, r, a, o) {
                                    var u = {
                                        type: n ? "Block" : "Line",
                                        value: i,
                                        start: s,
                                        end: r
                                    };
                                    t.locations && (u.loc = new O(this, a, o)), t.ranges && (u.range = [s, r]), e.push(u)
                                }
                            }(e, e.onComment)), e
                        }

                        function $(t, e) {
                            return 2 | (t ? 4 : 0) | (e ? 8 : 0)
                        }
                        var U = function(t, n, s) {
                                this.options = t = P(t), this.sourceFile = t.sourceFile, this.keywords = C(i[t.ecmaVersion >= 6 ? 6 : "module" === t.sourceType ? "5module" : 5]);
                                var r = "";
                                if (!0 !== t.allowReserved) {
                                    for (var a = t.ecmaVersion; !(r = e[a]); a--);
                                    "module" === t.sourceType && (r += " await")
                                }
                                this.reservedWords = C(r);
                                var o = (r ? r + " " : "") + e.strict;
                                this.reservedWordsStrict = C(o), this.reservedWordsStrictBind = C(o + " " + e.strictBind), this.input = String(n), this.containsEsc = !1, s ? (this.pos = s, this.lineStart = this.input.lastIndexOf("\n", s - 1) + 1, this.curLine = this.input.slice(0, this.lineStart).split(w).length) : (this.pos = this.lineStart = 0, this.curLine = 1), this.type = b.eof, this.value = null, this.start = this.end = this.pos, this.startLoc = this.endLoc = this.curPosition(), this.lastTokEndLoc = this.lastTokStartLoc = null, this.lastTokStart = this.lastTokEnd = this.pos, this.context = this.initialContext(), this.exprAllowed = !0, this.inModule = "module" === t.sourceType, this.strict = this.inModule || this.strictDirective(this.pos), this.potentialArrowAt = -1, this.yieldPos = this.awaitPos = this.awaitIdentPos = 0, this.labels = [], this.undefinedExports = {}, 0 === this.pos && t.allowHashBang && "#!" === this.input.slice(0, 2) && this.skipLineComment(2), this.scopeStack = [], this.enterScope(1), this.regexpState = null
                            },
                            F = {
                                inFunction: {
                                    configurable: !0
                                },
                                inGenerator: {
                                    configurable: !0
                                },
                                inAsync: {
                                    configurable: !0
                                },
                                allowSuper: {
                                    configurable: !0
                                },
                                allowDirectSuper: {
                                    configurable: !0
                                },
                                treatFunctionsAsVar: {
                                    configurable: !0
                                }
                            };
                        U.prototype.parse = function() {
                            var t = this.options.program || this.startNode();
                            return this.nextToken(), this.parseTopLevel(t)
                        }, F.inFunction.get = function() {
                            return (2 & this.currentVarScope().flags) > 0
                        }, F.inGenerator.get = function() {
                            return (8 & this.currentVarScope().flags) > 0
                        }, F.inAsync.get = function() {
                            return (4 & this.currentVarScope().flags) > 0
                        }, F.allowSuper.get = function() {
                            return (64 & this.currentThisScope().flags) > 0
                        }, F.allowDirectSuper.get = function() {
                            return (128 & this.currentThisScope().flags) > 0
                        }, F.treatFunctionsAsVar.get = function() {
                            return this.treatFunctionsAsVarInScope(this.currentScope())
                        }, U.prototype.inNonArrowFunction = function() {
                            return (2 & this.currentThisScope().flags) > 0
                        }, U.extend = function() {
                            for (var t = [], e = arguments.length; e--;) t[e] = arguments[e];
                            for (var n = this, i = 0; i < t.length; i++) n = t[i](n);
                            return n
                        }, U.parse = function(t, e) {
                            return new this(e, t).parse()
                        }, U.parseExpressionAt = function(t, e, n) {
                            var i = new this(n, t, e);
                            return i.nextToken(), i.parseExpression()
                        }, U.tokenizer = function(t, e) {
                            return new this(e, t)
                        }, Object.defineProperties(U.prototype, F);
                        var B = U.prototype,
                            z = /^(?:'((?:\\.|[^'])*?)'|"((?:\\.|[^"])*?)")/;

                        function V() {
                            this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1
                        }
                        B.strictDirective = function(t) {
                            for (;;) {
                                A.lastIndex = t, t += A.exec(this.input)[0].length;
                                var e = z.exec(this.input.slice(t));
                                if (!e) return !1;
                                if ("use strict" === (e[1] || e[2])) return !0;
                                t += e[0].length, A.lastIndex = t, t += A.exec(this.input)[0].length, ";" === this.input[t] && t++
                            }
                        }, B.eat = function(t) {
                            return this.type === t && (this.next(), !0)
                        }, B.isContextual = function(t) {
                            return this.type === b.name && this.value === t && !this.containsEsc
                        }, B.eatContextual = function(t) {
                            return !!this.isContextual(t) && (this.next(), !0)
                        }, B.expectContextual = function(t) {
                            this.eatContextual(t) || this.unexpected()
                        }, B.canInsertSemicolon = function() {
                            return this.type === b.eof || this.type === b.braceR || w.test(this.input.slice(this.lastTokEnd, this.start))
                        }, B.insertSemicolon = function() {
                            if (this.canInsertSemicolon()) return this.options.onInsertedSemicolon && this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc), !0
                        }, B.semicolon = function() {
                            this.eat(b.semi) || this.insertSemicolon() || this.unexpected()
                        }, B.afterTrailingComma = function(t, e) {
                            if (this.type === t) return this.options.onTrailingComma && this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc), e || this.next(), !0
                        }, B.expect = function(t) {
                            this.eat(t) || this.unexpected()
                        }, B.unexpected = function(t) {
                            this.raise(null != t ? t : this.start, "Unexpected token")
                        }, B.checkPatternErrors = function(t, e) {
                            if (t) {
                                t.trailingComma > -1 && this.raiseRecoverable(t.trailingComma, "Comma is not permitted after the rest element");
                                var n = e ? t.parenthesizedAssign : t.parenthesizedBind;
                                n > -1 && this.raiseRecoverable(n, "Parenthesized pattern")
                            }
                        }, B.checkExpressionErrors = function(t, e) {
                            if (!t) return !1;
                            var n = t.shorthandAssign,
                                i = t.doubleProto;
                            if (!e) return n >= 0 || i >= 0;
                            n >= 0 && this.raise(n, "Shorthand property assignments are valid only in destructuring patterns"), i >= 0 && this.raiseRecoverable(i, "Redefinition of __proto__ property")
                        }, B.checkYieldAwaitInDefaultParams = function() {
                            this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos) && this.raise(this.yieldPos, "Yield expression cannot be a default value"), this.awaitPos && this.raise(this.awaitPos, "Await expression cannot be a default value")
                        }, B.isSimpleAssignTarget = function(t) {
                            return "ParenthesizedExpression" === t.type ? this.isSimpleAssignTarget(t.expression) : "Identifier" === t.type || "MemberExpression" === t.type
                        };
                        var K = U.prototype;
                        K.parseTopLevel = function(t) {
                            var e = {};
                            for (t.body || (t.body = []); this.type !== b.eof;) {
                                var n = this.parseStatement(null, !0, e);
                                t.body.push(n)
                            }
                            if (this.inModule)
                                for (var i = 0, s = Object.keys(this.undefinedExports); i < s.length; i += 1) {
                                    var r = s[i];
                                    this.raiseRecoverable(this.undefinedExports[r].start, "Export '" + r + "' is not defined")
                                }
                            return this.adaptDirectivePrologue(t.body), this.next(), t.sourceType = this.options.sourceType, this.finishNode(t, "Program")
                        };
                        var G = {
                                kind: "loop"
                            },
                            j = {
                                kind: "switch"
                            };
                        K.isLet = function(t) {
                            if (this.options.ecmaVersion < 6 || !this.isContextual("let")) return !1;
                            A.lastIndex = this.pos;
                            var e = A.exec(this.input),
                                n = this.pos + e[0].length,
                                i = this.input.charCodeAt(n);
                            if (91 === i) return !0;
                            if (t) return !1;
                            if (123 === i) return !0;
                            if (p(i, !0)) {
                                for (var r = n + 1; d(this.input.charCodeAt(r), !0);) ++r;
                                var a = this.input.slice(n, r);
                                if (!s.test(a)) return !0
                            }
                            return !1
                        }, K.isAsyncFunction = function() {
                            if (this.options.ecmaVersion < 8 || !this.isContextual("async")) return !1;
                            A.lastIndex = this.pos;
                            var t = A.exec(this.input),
                                e = this.pos + t[0].length;
                            return !(w.test(this.input.slice(this.pos, e)) || "function" !== this.input.slice(e, e + 8) || e + 8 !== this.input.length && d(this.input.charAt(e + 8)))
                        }, K.parseStatement = function(t, e, n) {
                            var i, s = this.type,
                                r = this.startNode();
                            switch (this.isLet(t) && (s = b._var, i = "let"), s) {
                                case b._break:
                                case b._continue:
                                    return this.parseBreakContinueStatement(r, s.keyword);
                                case b._debugger:
                                    return this.parseDebuggerStatement(r);
                                case b._do:
                                    return this.parseDoStatement(r);
                                case b._for:
                                    return this.parseForStatement(r);
                                case b._function:
                                    return t && (this.strict || "if" !== t && "label" !== t) && this.options.ecmaVersion >= 6 && this.unexpected(), this.parseFunctionStatement(r, !1, !t);
                                case b._class:
                                    return t && this.unexpected(), this.parseClass(r, !0);
                                case b._if:
                                    return this.parseIfStatement(r);
                                case b._return:
                                    return this.parseReturnStatement(r);
                                case b._switch:
                                    return this.parseSwitchStatement(r);
                                case b._throw:
                                    return this.parseThrowStatement(r);
                                case b._try:
                                    return this.parseTryStatement(r);
                                case b._const:
                                case b._var:
                                    return i = i || this.value, t && "var" !== i && this.unexpected(), this.parseVarStatement(r, i);
                                case b._while:
                                    return this.parseWhileStatement(r);
                                case b._with:
                                    return this.parseWithStatement(r);
                                case b.braceL:
                                    return this.parseBlock(!0, r);
                                case b.semi:
                                    return this.parseEmptyStatement(r);
                                case b._export:
                                case b._import:
                                    if (this.options.ecmaVersion > 10 && s === b._import) {
                                        A.lastIndex = this.pos;
                                        var a = A.exec(this.input),
                                            o = this.pos + a[0].length;
                                        if (40 === this.input.charCodeAt(o)) return this.parseExpressionStatement(r, this.parseExpression())
                                    }
                                    return this.options.allowImportExportEverywhere || (e || this.raise(this.start, "'import' and 'export' may only appear at the top level"), this.inModule || this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'")), s === b._import ? this.parseImport(r) : this.parseExport(r, n);
                                default:
                                    if (this.isAsyncFunction()) return t && this.unexpected(), this.next(), this.parseFunctionStatement(r, !0, !t);
                                    var u = this.value,
                                        h = this.parseExpression();
                                    return s === b.name && "Identifier" === h.type && this.eat(b.colon) ? this.parseLabeledStatement(r, u, h, t) : this.parseExpressionStatement(r, h)
                            }
                        }, K.parseBreakContinueStatement = function(t, e) {
                            var n = "break" === e;
                            this.next(), this.eat(b.semi) || this.insertSemicolon() ? t.label = null : this.type !== b.name ? this.unexpected() : (t.label = this.parseIdent(), this.semicolon());
                            for (var i = 0; i < this.labels.length; ++i) {
                                var s = this.labels[i];
                                if (null == t.label || s.name === t.label.name) {
                                    if (null != s.kind && (n || "loop" === s.kind)) break;
                                    if (t.label && n) break
                                }
                            }
                            return i === this.labels.length && this.raise(t.start, "Unsyntactic " + e), this.finishNode(t, n ? "BreakStatement" : "ContinueStatement")
                        }, K.parseDebuggerStatement = function(t) {
                            return this.next(), this.semicolon(), this.finishNode(t, "DebuggerStatement")
                        }, K.parseDoStatement = function(t) {
                            return this.next(), this.labels.push(G), t.body = this.parseStatement("do"), this.labels.pop(), this.expect(b._while), t.test = this.parseParenExpression(), this.options.ecmaVersion >= 6 ? this.eat(b.semi) : this.semicolon(), this.finishNode(t, "DoWhileStatement")
                        }, K.parseForStatement = function(t) {
                            this.next();
                            var e = this.options.ecmaVersion >= 9 && (this.inAsync || !this.inFunction && this.options.allowAwaitOutsideFunction) && this.eatContextual("await") ? this.lastTokStart : -1;
                            if (this.labels.push(G), this.enterScope(0), this.expect(b.parenL), this.type === b.semi) return e > -1 && this.unexpected(e), this.parseFor(t, null);
                            var n = this.isLet();
                            if (this.type === b._var || this.type === b._const || n) {
                                var i = this.startNode(),
                                    s = n ? "let" : this.value;
                                return this.next(), this.parseVar(i, !0, s), this.finishNode(i, "VariableDeclaration"), (this.type === b._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && 1 === i.declarations.length ? (this.options.ecmaVersion >= 9 && (this.type === b._in ? e > -1 && this.unexpected(e) : t.await = e > -1), this.parseForIn(t, i)) : (e > -1 && this.unexpected(e), this.parseFor(t, i))
                            }
                            var r = new V,
                                a = this.parseExpression(!0, r);
                            return this.type === b._in || this.options.ecmaVersion >= 6 && this.isContextual("of") ? (this.options.ecmaVersion >= 9 && (this.type === b._in ? e > -1 && this.unexpected(e) : t.await = e > -1), this.toAssignable(a, !1, r), this.checkLVal(a), this.parseForIn(t, a)) : (this.checkExpressionErrors(r, !0), e > -1 && this.unexpected(e), this.parseFor(t, a))
                        }, K.parseFunctionStatement = function(t, e, n) {
                            return this.next(), this.parseFunction(t, H | (n ? 0 : X), !1, e)
                        }, K.parseIfStatement = function(t) {
                            return this.next(), t.test = this.parseParenExpression(), t.consequent = this.parseStatement("if"), t.alternate = this.eat(b._else) ? this.parseStatement("if") : null, this.finishNode(t, "IfStatement")
                        }, K.parseReturnStatement = function(t) {
                            return this.inFunction || this.options.allowReturnOutsideFunction || this.raise(this.start, "'return' outside of function"), this.next(), this.eat(b.semi) || this.insertSemicolon() ? t.argument = null : (t.argument = this.parseExpression(), this.semicolon()), this.finishNode(t, "ReturnStatement")
                        }, K.parseSwitchStatement = function(t) {
                            var e;
                            this.next(), t.discriminant = this.parseParenExpression(), t.cases = [], this.expect(b.braceL), this.labels.push(j), this.enterScope(0);
                            for (var n = !1; this.type !== b.braceR;)
                                if (this.type === b._case || this.type === b._default) {
                                    var i = this.type === b._case;
                                    e && this.finishNode(e, "SwitchCase"), t.cases.push(e = this.startNode()), e.consequent = [], this.next(), i ? e.test = this.parseExpression() : (n && this.raiseRecoverable(this.lastTokStart, "Multiple default clauses"), n = !0, e.test = null), this.expect(b.colon)
                                } else e || this.unexpected(), e.consequent.push(this.parseStatement(null));
                            return this.exitScope(), e && this.finishNode(e, "SwitchCase"), this.next(), this.labels.pop(), this.finishNode(t, "SwitchStatement")
                        }, K.parseThrowStatement = function(t) {
                            return this.next(), w.test(this.input.slice(this.lastTokEnd, this.start)) && this.raise(this.lastTokEnd, "Illegal newline after throw"), t.argument = this.parseExpression(), this.semicolon(), this.finishNode(t, "ThrowStatement")
                        };
                        var W = [];
                        K.parseTryStatement = function(t) {
                            if (this.next(), t.block = this.parseBlock(), t.handler = null, this.type === b._catch) {
                                var e = this.startNode();
                                if (this.next(), this.eat(b.parenL)) {
                                    e.param = this.parseBindingAtom();
                                    var n = "Identifier" === e.param.type;
                                    this.enterScope(n ? 32 : 0), this.checkLVal(e.param, n ? 4 : 2), this.expect(b.parenR)
                                } else this.options.ecmaVersion < 10 && this.unexpected(), e.param = null, this.enterScope(0);
                                e.body = this.parseBlock(!1), this.exitScope(), t.handler = this.finishNode(e, "CatchClause")
                            }
                            return t.finalizer = this.eat(b._finally) ? this.parseBlock() : null, t.handler || t.finalizer || this.raise(t.start, "Missing catch or finally clause"), this.finishNode(t, "TryStatement")
                        }, K.parseVarStatement = function(t, e) {
                            return this.next(), this.parseVar(t, !1, e), this.semicolon(), this.finishNode(t, "VariableDeclaration")
                        }, K.parseWhileStatement = function(t) {
                            return this.next(), t.test = this.parseParenExpression(), this.labels.push(G), t.body = this.parseStatement("while"), this.labels.pop(), this.finishNode(t, "WhileStatement")
                        }, K.parseWithStatement = function(t) {
                            return this.strict && this.raise(this.start, "'with' in strict mode"), this.next(), t.object = this.parseParenExpression(), t.body = this.parseStatement("with"), this.finishNode(t, "WithStatement")
                        }, K.parseEmptyStatement = function(t) {
                            return this.next(), this.finishNode(t, "EmptyStatement")
                        }, K.parseLabeledStatement = function(t, e, n, i) {
                            for (var s = 0, r = this.labels; s < r.length; s += 1) r[s].name === e && this.raise(n.start, "Label '" + e + "' is already declared");
                            for (var a = this.type.isLoop ? "loop" : this.type === b._switch ? "switch" : null, o = this.labels.length - 1; o >= 0; o--) {
                                var u = this.labels[o];
                                if (u.statementStart !== t.start) break;
                                u.statementStart = this.start, u.kind = a
                            }
                            return this.labels.push({
                                name: e,
                                kind: a,
                                statementStart: this.start
                            }), t.body = this.parseStatement(i ? -1 === i.indexOf("label") ? i + "label" : i : "label"), this.labels.pop(), t.label = n, this.finishNode(t, "LabeledStatement")
                        }, K.parseExpressionStatement = function(t, e) {
                            return t.expression = e, this.semicolon(), this.finishNode(t, "ExpressionStatement")
                        }, K.parseBlock = function(t, e) {
                            for (void 0 === t && (t = !0), void 0 === e && (e = this.startNode()), e.body = [], this.expect(b.braceL), t && this.enterScope(0); !this.eat(b.braceR);) {
                                var n = this.parseStatement(null);
                                e.body.push(n)
                            }
                            return t && this.exitScope(), this.finishNode(e, "BlockStatement")
                        }, K.parseFor = function(t, e) {
                            return t.init = e, this.expect(b.semi), t.test = this.type === b.semi ? null : this.parseExpression(), this.expect(b.semi), t.update = this.type === b.parenR ? null : this.parseExpression(), this.expect(b.parenR), t.body = this.parseStatement("for"), this.exitScope(), this.labels.pop(), this.finishNode(t, "ForStatement")
                        }, K.parseForIn = function(t, e) {
                            var n = this.type === b._in;
                            return this.next(), "VariableDeclaration" === e.type && null != e.declarations[0].init && (!n || this.options.ecmaVersion < 8 || this.strict || "var" !== e.kind || "Identifier" !== e.declarations[0].id.type) ? this.raise(e.start, (n ? "for-in" : "for-of") + " loop variable declaration may not have an initializer") : "AssignmentPattern" === e.type && this.raise(e.start, "Invalid left-hand side in for-loop"), t.left = e, t.right = n ? this.parseExpression() : this.parseMaybeAssign(), this.expect(b.parenR), t.body = this.parseStatement("for"), this.exitScope(), this.labels.pop(), this.finishNode(t, n ? "ForInStatement" : "ForOfStatement")
                        }, K.parseVar = function(t, e, n) {
                            for (t.declarations = [], t.kind = n;;) {
                                var i = this.startNode();
                                if (this.parseVarId(i, n), this.eat(b.eq) ? i.init = this.parseMaybeAssign(e) : "const" !== n || this.type === b._in || this.options.ecmaVersion >= 6 && this.isContextual("of") ? "Identifier" === i.id.type || e && (this.type === b._in || this.isContextual("of")) ? i.init = null : this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value") : this.unexpected(), t.declarations.push(this.finishNode(i, "VariableDeclarator")), !this.eat(b.comma)) break
                            }
                            return t
                        }, K.parseVarId = function(t, e) {
                            t.id = this.parseBindingAtom(), this.checkLVal(t.id, "var" === e ? 1 : 2, !1)
                        };
                        var H = 1,
                            X = 2;
                        K.parseFunction = function(t, e, n, i) {
                            this.initFunction(t), (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !i) && (this.type === b.star && e & X && this.unexpected(), t.generator = this.eat(b.star)), this.options.ecmaVersion >= 8 && (t.async = !!i), e & H && (t.id = 4 & e && this.type !== b.name ? null : this.parseIdent(), !t.id || e & X || this.checkLVal(t.id, this.strict || t.generator || t.async ? this.treatFunctionsAsVar ? 1 : 2 : 3));
                            var s = this.yieldPos,
                                r = this.awaitPos,
                                a = this.awaitIdentPos;
                            return this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope($(t.async, t.generator)), e & H || (t.id = this.type === b.name ? this.parseIdent() : null), this.parseFunctionParams(t), this.parseFunctionBody(t, n, !1), this.yieldPos = s, this.awaitPos = r, this.awaitIdentPos = a, this.finishNode(t, e & H ? "FunctionDeclaration" : "FunctionExpression")
                        }, K.parseFunctionParams = function(t) {
                            this.expect(b.parenL), t.params = this.parseBindingList(b.parenR, !1, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams()
                        }, K.parseClass = function(t, e) {
                            this.next();
                            var n = this.strict;
                            this.strict = !0, this.parseClassId(t, e), this.parseClassSuper(t);
                            var i = this.startNode(),
                                s = !1;
                            for (i.body = [], this.expect(b.braceL); !this.eat(b.braceR);) {
                                var r = this.parseClassElement(null !== t.superClass);
                                r && (i.body.push(r), "MethodDefinition" === r.type && "constructor" === r.kind && (s && this.raise(r.start, "Duplicate constructor in the same class"), s = !0))
                            }
                            return t.body = this.finishNode(i, "ClassBody"), this.strict = n, this.finishNode(t, e ? "ClassDeclaration" : "ClassExpression")
                        }, K.parseClassElement = function(t) {
                            var e = this;
                            if (this.eat(b.semi)) return null;
                            var n = this.startNode(),
                                i = function(t, i) {
                                    void 0 === i && (i = !1);
                                    var s = e.start,
                                        r = e.startLoc;
                                    return !(!e.eatContextual(t) || (e.type === b.parenL || i && e.canInsertSemicolon()) && (n.key && e.unexpected(), n.computed = !1, n.key = e.startNodeAt(s, r), n.key.name = t, e.finishNode(n.key, "Identifier"), 1))
                                };
                            n.kind = "method", n.static = i("static");
                            var s = this.eat(b.star),
                                r = !1;
                            s || (this.options.ecmaVersion >= 8 && i("async", !0) ? (r = !0, s = this.options.ecmaVersion >= 9 && this.eat(b.star)) : i("get") ? n.kind = "get" : i("set") && (n.kind = "set")), n.key || this.parsePropertyName(n);
                            var a = n.key,
                                o = !1;
                            return n.computed || n.static || !("Identifier" === a.type && "constructor" === a.name || "Literal" === a.type && "constructor" === a.value) ? n.static && "Identifier" === a.type && "prototype" === a.name && this.raise(a.start, "Classes may not have a static property named prototype") : ("method" !== n.kind && this.raise(a.start, "Constructor can't have get/set modifier"), s && this.raise(a.start, "Constructor can't be a generator"), r && this.raise(a.start, "Constructor can't be an async method"), n.kind = "constructor", o = t), this.parseClassMethod(n, s, r, o), "get" === n.kind && 0 !== n.value.params.length && this.raiseRecoverable(n.value.start, "getter should have no params"), "set" === n.kind && 1 !== n.value.params.length && this.raiseRecoverable(n.value.start, "setter should have exactly one param"), "set" === n.kind && "RestElement" === n.value.params[0].type && this.raiseRecoverable(n.value.params[0].start, "Setter cannot use rest params"), n
                        }, K.parseClassMethod = function(t, e, n, i) {
                            return t.value = this.parseMethod(e, n, i), this.finishNode(t, "MethodDefinition")
                        }, K.parseClassId = function(t, e) {
                            this.type === b.name ? (t.id = this.parseIdent(), e && this.checkLVal(t.id, 2, !1)) : (!0 === e && this.unexpected(), t.id = null)
                        }, K.parseClassSuper = function(t) {
                            t.superClass = this.eat(b._extends) ? this.parseExprSubscripts() : null
                        }, K.parseExport = function(t, e) {
                            if (this.next(), this.eat(b.star)) return this.expectContextual("from"), this.type !== b.string && this.unexpected(), t.source = this.parseExprAtom(), this.semicolon(), this.finishNode(t, "ExportAllDeclaration");
                            if (this.eat(b._default)) {
                                var n;
                                if (this.checkExport(e, "default", this.lastTokStart), this.type === b._function || (n = this.isAsyncFunction())) {
                                    var i = this.startNode();
                                    this.next(), n && this.next(), t.declaration = this.parseFunction(i, 4 | H, !1, n)
                                } else if (this.type === b._class) {
                                    var s = this.startNode();
                                    t.declaration = this.parseClass(s, "nullableID")
                                } else t.declaration = this.parseMaybeAssign(), this.semicolon();
                                return this.finishNode(t, "ExportDefaultDeclaration")
                            }
                            if (this.shouldParseExportStatement()) t.declaration = this.parseStatement(null), "VariableDeclaration" === t.declaration.type ? this.checkVariableExport(e, t.declaration.declarations) : this.checkExport(e, t.declaration.id.name, t.declaration.id.start), t.specifiers = [], t.source = null;
                            else {
                                if (t.declaration = null, t.specifiers = this.parseExportSpecifiers(e), this.eatContextual("from")) this.type !== b.string && this.unexpected(), t.source = this.parseExprAtom();
                                else {
                                    for (var r = 0, a = t.specifiers; r < a.length; r += 1) {
                                        var o = a[r];
                                        this.checkUnreserved(o.local), this.checkLocalExport(o.local)
                                    }
                                    t.source = null
                                }
                                this.semicolon()
                            }
                            return this.finishNode(t, "ExportNamedDeclaration")
                        }, K.checkExport = function(t, e, n) {
                            t && (D(t, e) && this.raiseRecoverable(n, "Duplicate export '" + e + "'"), t[e] = !0)
                        }, K.checkPatternExport = function(t, e) {
                            var n = e.type;
                            if ("Identifier" === n) this.checkExport(t, e.name, e.start);
                            else if ("ObjectPattern" === n)
                                for (var i = 0, s = e.properties; i < s.length; i += 1) {
                                    var r = s[i];
                                    this.checkPatternExport(t, r)
                                } else if ("ArrayPattern" === n)
                                    for (var a = 0, o = e.elements; a < o.length; a += 1) {
                                        var u = o[a];
                                        u && this.checkPatternExport(t, u)
                                    } else "Property" === n ? this.checkPatternExport(t, e.value) : "AssignmentPattern" === n ? this.checkPatternExport(t, e.left) : "RestElement" === n ? this.checkPatternExport(t, e.argument) : "ParenthesizedExpression" === n && this.checkPatternExport(t, e.expression)
                        }, K.checkVariableExport = function(t, e) {
                            if (t)
                                for (var n = 0, i = e; n < i.length; n += 1) {
                                    var s = i[n];
                                    this.checkPatternExport(t, s.id)
                                }
                        }, K.shouldParseExportStatement = function() {
                            return "var" === this.type.keyword || "const" === this.type.keyword || "class" === this.type.keyword || "function" === this.type.keyword || this.isLet() || this.isAsyncFunction()
                        }, K.parseExportSpecifiers = function(t) {
                            var e = [],
                                n = !0;
                            for (this.expect(b.braceL); !this.eat(b.braceR);) {
                                if (n) n = !1;
                                else if (this.expect(b.comma), this.afterTrailingComma(b.braceR)) break;
                                var i = this.startNode();
                                i.local = this.parseIdent(!0), i.exported = this.eatContextual("as") ? this.parseIdent(!0) : i.local, this.checkExport(t, i.exported.name, i.exported.start), e.push(this.finishNode(i, "ExportSpecifier"))
                            }
                            return e
                        }, K.parseImport = function(t) {
                            return this.next(), this.type === b.string ? (t.specifiers = W, t.source = this.parseExprAtom()) : (t.specifiers = this.parseImportSpecifiers(), this.expectContextual("from"), t.source = this.type === b.string ? this.parseExprAtom() : this.unexpected()), this.semicolon(), this.finishNode(t, "ImportDeclaration")
                        }, K.parseImportSpecifiers = function() {
                            var t = [],
                                e = !0;
                            if (this.type === b.name) {
                                var n = this.startNode();
                                if (n.local = this.parseIdent(), this.checkLVal(n.local, 2), t.push(this.finishNode(n, "ImportDefaultSpecifier")), !this.eat(b.comma)) return t
                            }
                            if (this.type === b.star) {
                                var i = this.startNode();
                                return this.next(), this.expectContextual("as"), i.local = this.parseIdent(), this.checkLVal(i.local, 2), t.push(this.finishNode(i, "ImportNamespaceSpecifier")), t
                            }
                            for (this.expect(b.braceL); !this.eat(b.braceR);) {
                                if (e) e = !1;
                                else if (this.expect(b.comma), this.afterTrailingComma(b.braceR)) break;
                                var s = this.startNode();
                                s.imported = this.parseIdent(!0), this.eatContextual("as") ? s.local = this.parseIdent() : (this.checkUnreserved(s.imported), s.local = s.imported), this.checkLVal(s.local, 2), t.push(this.finishNode(s, "ImportSpecifier"))
                            }
                            return t
                        }, K.adaptDirectivePrologue = function(t) {
                            for (var e = 0; e < t.length && this.isDirectiveCandidate(t[e]); ++e) t[e].directive = t[e].expression.raw.slice(1, -1)
                        }, K.isDirectiveCandidate = function(t) {
                            return "ExpressionStatement" === t.type && "Literal" === t.expression.type && "string" == typeof t.expression.value && ('"' === this.input[t.start] || "'" === this.input[t.start])
                        };
                        var Z = U.prototype;
                        Z.toAssignable = function(t, e, n) {
                            if (this.options.ecmaVersion >= 6 && t) switch (t.type) {
                                case "Identifier":
                                    this.inAsync && "await" === t.name && this.raise(t.start, "Cannot use 'await' as identifier inside an async function");
                                    break;
                                case "ObjectPattern":
                                case "ArrayPattern":
                                case "RestElement":
                                    break;
                                case "ObjectExpression":
                                    t.type = "ObjectPattern", n && this.checkPatternErrors(n, !0);
                                    for (var i = 0, s = t.properties; i < s.length; i += 1) {
                                        var r = s[i];
                                        this.toAssignable(r, e), "RestElement" !== r.type || "ArrayPattern" !== r.argument.type && "ObjectPattern" !== r.argument.type || this.raise(r.argument.start, "Unexpected token")
                                    }
                                    break;
                                case "Property":
                                    "init" !== t.kind && this.raise(t.key.start, "Object pattern can't contain getter or setter"), this.toAssignable(t.value, e);
                                    break;
                                case "ArrayExpression":
                                    t.type = "ArrayPattern", n && this.checkPatternErrors(n, !0), this.toAssignableList(t.elements, e);
                                    break;
                                case "SpreadElement":
                                    t.type = "RestElement", this.toAssignable(t.argument, e), "AssignmentPattern" === t.argument.type && this.raise(t.argument.start, "Rest elements cannot have a default value");
                                    break;
                                case "AssignmentExpression":
                                    "=" !== t.operator && this.raise(t.left.end, "Only '=' operator can be used for specifying default value."), t.type = "AssignmentPattern", delete t.operator, this.toAssignable(t.left, e);
                                case "AssignmentPattern":
                                    break;
                                case "ParenthesizedExpression":
                                    this.toAssignable(t.expression, e, n);
                                    break;
                                case "MemberExpression":
                                    if (!e) break;
                                default:
                                    this.raise(t.start, "Assigning to rvalue")
                            } else n && this.checkPatternErrors(n, !0);
                            return t
                        }, Z.toAssignableList = function(t, e) {
                            for (var n = t.length, i = 0; i < n; i++) {
                                var s = t[i];
                                s && this.toAssignable(s, e)
                            }
                            if (n) {
                                var r = t[n - 1];
                                6 === this.options.ecmaVersion && e && r && "RestElement" === r.type && "Identifier" !== r.argument.type && this.unexpected(r.argument.start)
                            }
                            return t
                        }, Z.parseSpread = function(t) {
                            var e = this.startNode();
                            return this.next(), e.argument = this.parseMaybeAssign(!1, t), this.finishNode(e, "SpreadElement")
                        }, Z.parseRestBinding = function() {
                            var t = this.startNode();
                            return this.next(), 6 === this.options.ecmaVersion && this.type !== b.name && this.unexpected(), t.argument = this.parseBindingAtom(), this.finishNode(t, "RestElement")
                        }, Z.parseBindingAtom = function() {
                            if (this.options.ecmaVersion >= 6) switch (this.type) {
                                case b.bracketL:
                                    var t = this.startNode();
                                    return this.next(), t.elements = this.parseBindingList(b.bracketR, !0, !0), this.finishNode(t, "ArrayPattern");
                                case b.braceL:
                                    return this.parseObj(!0)
                            }
                            return this.parseIdent()
                        }, Z.parseBindingList = function(t, e, n) {
                            for (var i = [], s = !0; !this.eat(t);)
                                if (s ? s = !1 : this.expect(b.comma), e && this.type === b.comma) i.push(null);
                                else {
                                    if (n && this.afterTrailingComma(t)) break;
                                    if (this.type === b.ellipsis) {
                                        var r = this.parseRestBinding();
                                        this.parseBindingListItem(r), i.push(r), this.type === b.comma && this.raise(this.start, "Comma is not permitted after the rest element"), this.expect(t);
                                        break
                                    }
                                    var a = this.parseMaybeDefault(this.start, this.startLoc);
                                    this.parseBindingListItem(a), i.push(a)
                                } return i
                        }, Z.parseBindingListItem = function(t) {
                            return t
                        }, Z.parseMaybeDefault = function(t, e, n) {
                            if (n = n || this.parseBindingAtom(), this.options.ecmaVersion < 6 || !this.eat(b.eq)) return n;
                            var i = this.startNodeAt(t, e);
                            return i.left = n, i.right = this.parseMaybeAssign(), this.finishNode(i, "AssignmentPattern")
                        }, Z.checkLVal = function(t, e, n) {
                            switch (void 0 === e && (e = 0), t.type) {
                                case "Identifier":
                                    2 === e && "let" === t.name && this.raiseRecoverable(t.start, "let is disallowed as a lexically bound name"), this.strict && this.reservedWordsStrictBind.test(t.name) && this.raiseRecoverable(t.start, (e ? "Binding " : "Assigning to ") + t.name + " in strict mode"), n && (D(n, t.name) && this.raiseRecoverable(t.start, "Argument name clash"), n[t.name] = !0), 0 !== e && 5 !== e && this.declareName(t.name, e, t.start);
                                    break;
                                case "MemberExpression":
                                    e && this.raiseRecoverable(t.start, "Binding member expression");
                                    break;
                                case "ObjectPattern":
                                    for (var i = 0, s = t.properties; i < s.length; i += 1) {
                                        var r = s[i];
                                        this.checkLVal(r, e, n)
                                    }
                                    break;
                                case "Property":
                                    this.checkLVal(t.value, e, n);
                                    break;
                                case "ArrayPattern":
                                    for (var a = 0, o = t.elements; a < o.length; a += 1) {
                                        var u = o[a];
                                        u && this.checkLVal(u, e, n)
                                    }
                                    break;
                                case "AssignmentPattern":
                                    this.checkLVal(t.left, e, n);
                                    break;
                                case "RestElement":
                                    this.checkLVal(t.argument, e, n);
                                    break;
                                case "ParenthesizedExpression":
                                    this.checkLVal(t.expression, e, n);
                                    break;
                                default:
                                    this.raise(t.start, (e ? "Binding" : "Assigning to") + " rvalue")
                            }
                        };
                        var q = U.prototype;
                        q.checkPropClash = function(t, e, n) {
                            if (!(this.options.ecmaVersion >= 9 && "SpreadElement" === t.type || this.options.ecmaVersion >= 6 && (t.computed || t.method || t.shorthand))) {
                                var i, s = t.key;
                                switch (s.type) {
                                    case "Identifier":
                                        i = s.name;
                                        break;
                                    case "Literal":
                                        i = String(s.value);
                                        break;
                                    default:
                                        return
                                }
                                var r = t.kind;
                                if (this.options.ecmaVersion >= 6) "__proto__" === i && "init" === r && (e.proto && (n ? n.doubleProto < 0 && (n.doubleProto = s.start) : this.raiseRecoverable(s.start, "Redefinition of __proto__ property")), e.proto = !0);
                                else {
                                    var a = e[i = "$" + i];
                                    a ? ("init" === r ? this.strict && a.init || a.get || a.set : a.init || a[r]) && this.raiseRecoverable(s.start, "Redefinition of property") : a = e[i] = {
                                        init: !1,
                                        get: !1,
                                        set: !1
                                    }, a[r] = !0
                                }
                            }
                        }, q.parseExpression = function(t, e) {
                            var n = this.start,
                                i = this.startLoc,
                                s = this.parseMaybeAssign(t, e);
                            if (this.type === b.comma) {
                                var r = this.startNodeAt(n, i);
                                for (r.expressions = [s]; this.eat(b.comma);) r.expressions.push(this.parseMaybeAssign(t, e));
                                return this.finishNode(r, "SequenceExpression")
                            }
                            return s
                        }, q.parseMaybeAssign = function(t, e, n) {
                            if (this.isContextual("yield")) {
                                if (this.inGenerator) return this.parseYield(t);
                                this.exprAllowed = !1
                            }
                            var i = !1,
                                s = -1,
                                r = -1;
                            e ? (s = e.parenthesizedAssign, r = e.trailingComma, e.parenthesizedAssign = e.trailingComma = -1) : (e = new V, i = !0);
                            var a = this.start,
                                o = this.startLoc;
                            this.type !== b.parenL && this.type !== b.name || (this.potentialArrowAt = this.start);
                            var u = this.parseMaybeConditional(t, e);
                            if (n && (u = n.call(this, u, a, o)), this.type.isAssign) {
                                var h = this.startNodeAt(a, o);
                                return h.operator = this.value, h.left = this.type === b.eq ? this.toAssignable(u, !1, e) : u, i || (e.parenthesizedAssign = e.trailingComma = e.doubleProto = -1), e.shorthandAssign >= h.left.start && (e.shorthandAssign = -1), this.checkLVal(u), this.next(), h.right = this.parseMaybeAssign(t), this.finishNode(h, "AssignmentExpression")
                            }
                            return i && this.checkExpressionErrors(e, !0), s > -1 && (e.parenthesizedAssign = s), r > -1 && (e.trailingComma = r), u
                        }, q.parseMaybeConditional = function(t, e) {
                            var n = this.start,
                                i = this.startLoc,
                                s = this.parseExprOps(t, e);
                            if (this.checkExpressionErrors(e)) return s;
                            if (this.eat(b.question)) {
                                var r = this.startNodeAt(n, i);
                                return r.test = s, r.consequent = this.parseMaybeAssign(), this.expect(b.colon), r.alternate = this.parseMaybeAssign(t), this.finishNode(r, "ConditionalExpression")
                            }
                            return s
                        }, q.parseExprOps = function(t, e) {
                            var n = this.start,
                                i = this.startLoc,
                                s = this.parseMaybeUnary(e, !1);
                            return this.checkExpressionErrors(e) || s.start === n && "ArrowFunctionExpression" === s.type ? s : this.parseExprOp(s, n, i, -1, t)
                        }, q.parseExprOp = function(t, e, n, i, s) {
                            var r = this.type.binop;
                            if (null != r && (!s || this.type !== b._in) && r > i) {
                                var a = this.type === b.logicalOR || this.type === b.logicalAND,
                                    o = this.value;
                                this.next();
                                var u = this.start,
                                    h = this.startLoc,
                                    l = this.parseExprOp(this.parseMaybeUnary(null, !1), u, h, r, s),
                                    c = this.buildBinary(e, n, t, l, o, a);
                                return this.parseExprOp(c, e, n, i, s)
                            }
                            return t
                        }, q.buildBinary = function(t, e, n, i, s, r) {
                            var a = this.startNodeAt(t, e);
                            return a.left = n, a.operator = s, a.right = i, this.finishNode(a, r ? "LogicalExpression" : "BinaryExpression")
                        }, q.parseMaybeUnary = function(t, e) {
                            var n, i = this.start,
                                s = this.startLoc;
                            if (this.isContextual("await") && (this.inAsync || !this.inFunction && this.options.allowAwaitOutsideFunction)) n = this.parseAwait(), e = !0;
                            else if (this.type.prefix) {
                                var r = this.startNode(),
                                    a = this.type === b.incDec;
                                r.operator = this.value, r.prefix = !0, this.next(), r.argument = this.parseMaybeUnary(null, !0), this.checkExpressionErrors(t, !0), a ? this.checkLVal(r.argument) : this.strict && "delete" === r.operator && "Identifier" === r.argument.type ? this.raiseRecoverable(r.start, "Deleting local variable in strict mode") : e = !0, n = this.finishNode(r, a ? "UpdateExpression" : "UnaryExpression")
                            } else {
                                if (n = this.parseExprSubscripts(t), this.checkExpressionErrors(t)) return n;
                                for (; this.type.postfix && !this.canInsertSemicolon();) {
                                    var o = this.startNodeAt(i, s);
                                    o.operator = this.value, o.prefix = !1, o.argument = n, this.checkLVal(n), this.next(), n = this.finishNode(o, "UpdateExpression")
                                }
                            }
                            return !e && this.eat(b.starstar) ? this.buildBinary(i, s, n, this.parseMaybeUnary(null, !1), "**", !1) : n
                        }, q.parseExprSubscripts = function(t) {
                            var e = this.start,
                                n = this.startLoc,
                                i = this.parseExprAtom(t);
                            if ("ArrowFunctionExpression" === i.type && ")" !== this.input.slice(this.lastTokStart, this.lastTokEnd)) return i;
                            var s = this.parseSubscripts(i, e, n);
                            return t && "MemberExpression" === s.type && (t.parenthesizedAssign >= s.start && (t.parenthesizedAssign = -1), t.parenthesizedBind >= s.start && (t.parenthesizedBind = -1)), s
                        }, q.parseSubscripts = function(t, e, n, i) {
                            for (var s = this.options.ecmaVersion >= 8 && "Identifier" === t.type && "async" === t.name && this.lastTokEnd === t.end && !this.canInsertSemicolon() && "async" === this.input.slice(t.start, t.end);;) {
                                var r = this.parseSubscript(t, e, n, i, s);
                                if (r === t || "ArrowFunctionExpression" === r.type) return r;
                                t = r
                            }
                        }, q.parseSubscript = function(t, e, n, i, s) {
                            var r = this.eat(b.bracketL);
                            if (r || this.eat(b.dot)) {
                                var a = this.startNodeAt(e, n);
                                a.object = t, a.property = r ? this.parseExpression() : this.parseIdent("never" !== this.options.allowReserved), a.computed = !!r, r && this.expect(b.bracketR), t = this.finishNode(a, "MemberExpression")
                            } else if (!i && this.eat(b.parenL)) {
                                var o = new V,
                                    u = this.yieldPos,
                                    h = this.awaitPos,
                                    l = this.awaitIdentPos;
                                this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0;
                                var c = this.parseExprList(b.parenR, this.options.ecmaVersion >= 8, !1, o);
                                if (s && !this.canInsertSemicolon() && this.eat(b.arrow)) return this.checkPatternErrors(o, !1), this.checkYieldAwaitInDefaultParams(), this.awaitIdentPos > 0 && this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function"), this.yieldPos = u, this.awaitPos = h, this.awaitIdentPos = l, this.parseArrowExpression(this.startNodeAt(e, n), c, !0);
                                this.checkExpressionErrors(o, !0), this.yieldPos = u || this.yieldPos, this.awaitPos = h || this.awaitPos, this.awaitIdentPos = l || this.awaitIdentPos;
                                var p = this.startNodeAt(e, n);
                                p.callee = t, p.arguments = c, t = this.finishNode(p, "CallExpression")
                            } else if (this.type === b.backQuote) {
                                var d = this.startNodeAt(e, n);
                                d.tag = t, d.quasi = this.parseTemplate({
                                    isTagged: !0
                                }), t = this.finishNode(d, "TaggedTemplateExpression")
                            }
                            return t
                        }, q.parseExprAtom = function(t) {
                            this.type === b.slash && this.readRegexp();
                            var e, n = this.potentialArrowAt === this.start;
                            switch (this.type) {
                                case b._super:
                                    return this.allowSuper || this.raise(this.start, "'super' keyword outside a method"), e = this.startNode(), this.next(), this.type !== b.parenL || this.allowDirectSuper || this.raise(e.start, "super() call outside constructor of a subclass"), this.type !== b.dot && this.type !== b.bracketL && this.type !== b.parenL && this.unexpected(), this.finishNode(e, "Super");
                                case b._this:
                                    return e = this.startNode(), this.next(), this.finishNode(e, "ThisExpression");
                                case b.name:
                                    var i = this.start,
                                        s = this.startLoc,
                                        r = this.containsEsc,
                                        a = this.parseIdent(!1);
                                    if (this.options.ecmaVersion >= 8 && !r && "async" === a.name && !this.canInsertSemicolon() && this.eat(b._function)) return this.parseFunction(this.startNodeAt(i, s), 0, !1, !0);
                                    if (n && !this.canInsertSemicolon()) {
                                        if (this.eat(b.arrow)) return this.parseArrowExpression(this.startNodeAt(i, s), [a], !1);
                                        if (this.options.ecmaVersion >= 8 && "async" === a.name && this.type === b.name && !r) return a = this.parseIdent(!1), !this.canInsertSemicolon() && this.eat(b.arrow) || this.unexpected(), this.parseArrowExpression(this.startNodeAt(i, s), [a], !0)
                                    }
                                    return a;
                                case b.regexp:
                                    var o = this.value;
                                    return (e = this.parseLiteral(o.value)).regex = {
                                        pattern: o.pattern,
                                        flags: o.flags
                                    }, e;
                                case b.num:
                                case b.string:
                                    return this.parseLiteral(this.value);
                                case b._null:
                                case b._true:
                                case b._false:
                                    return (e = this.startNode()).value = this.type === b._null ? null : this.type === b._true, e.raw = this.type.keyword, this.next(), this.finishNode(e, "Literal");
                                case b.parenL:
                                    var u = this.start,
                                        h = this.parseParenAndDistinguishExpression(n);
                                    return t && (t.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(h) && (t.parenthesizedAssign = u), t.parenthesizedBind < 0 && (t.parenthesizedBind = u)), h;
                                case b.bracketL:
                                    return e = this.startNode(), this.next(), e.elements = this.parseExprList(b.bracketR, !0, !0, t), this.finishNode(e, "ArrayExpression");
                                case b.braceL:
                                    return this.parseObj(!1, t);
                                case b._function:
                                    return e = this.startNode(), this.next(), this.parseFunction(e, 0);
                                case b._class:
                                    return this.parseClass(this.startNode(), !1);
                                case b._new:
                                    return this.parseNew();
                                case b.backQuote:
                                    return this.parseTemplate();
                                case b._import:
                                    return this.options.ecmaVersion >= 11 ? this.parseExprImport() : this.unexpected();
                                default:
                                    this.unexpected()
                            }
                        }, q.parseExprImport = function() {
                            var t = this.startNode();
                            if (this.next(), this.type === b.parenL) return this.parseDynamicImport(t);
                            this.unexpected()
                        }, q.parseDynamicImport = function(t) {
                            if (this.next(), t.source = this.parseMaybeAssign(), !this.eat(b.parenR)) {
                                var e = this.start;
                                this.eat(b.comma) && this.eat(b.parenR) ? this.raiseRecoverable(e, "Trailing comma is not allowed in import()") : this.unexpected(e)
                            }
                            return this.finishNode(t, "ImportExpression")
                        }, q.parseLiteral = function(t) {
                            var e = this.startNode();
                            return e.value = t, e.raw = this.input.slice(this.start, this.end), 110 === e.raw.charCodeAt(e.raw.length - 1) && (e.bigint = e.raw.slice(0, -1)), this.next(), this.finishNode(e, "Literal")
                        }, q.parseParenExpression = function() {
                            this.expect(b.parenL);
                            var t = this.parseExpression();
                            return this.expect(b.parenR), t
                        }, q.parseParenAndDistinguishExpression = function(t) {
                            var e, n = this.start,
                                i = this.startLoc,
                                s = this.options.ecmaVersion >= 8;
                            if (this.options.ecmaVersion >= 6) {
                                this.next();
                                var r, a = this.start,
                                    o = this.startLoc,
                                    u = [],
                                    h = !0,
                                    l = !1,
                                    c = new V,
                                    p = this.yieldPos,
                                    d = this.awaitPos;
                                for (this.yieldPos = 0, this.awaitPos = 0; this.type !== b.parenR;) {
                                    if (h ? h = !1 : this.expect(b.comma), s && this.afterTrailingComma(b.parenR, !0)) {
                                        l = !0;
                                        break
                                    }
                                    if (this.type === b.ellipsis) {
                                        r = this.start, u.push(this.parseParenItem(this.parseRestBinding())), this.type === b.comma && this.raise(this.start, "Comma is not permitted after the rest element");
                                        break
                                    }
                                    u.push(this.parseMaybeAssign(!1, c, this.parseParenItem))
                                }
                                var m = this.start,
                                    g = this.startLoc;
                                if (this.expect(b.parenR), t && !this.canInsertSemicolon() && this.eat(b.arrow)) return this.checkPatternErrors(c, !1), this.checkYieldAwaitInDefaultParams(), this.yieldPos = p, this.awaitPos = d, this.parseParenArrowList(n, i, u);
                                u.length && !l || this.unexpected(this.lastTokStart), r && this.unexpected(r), this.checkExpressionErrors(c, !0), this.yieldPos = p || this.yieldPos, this.awaitPos = d || this.awaitPos, u.length > 1 ? ((e = this.startNodeAt(a, o)).expressions = u, this.finishNodeAt(e, "SequenceExpression", m, g)) : e = u[0]
                            } else e = this.parseParenExpression();
                            if (this.options.preserveParens) {
                                var f = this.startNodeAt(n, i);
                                return f.expression = e, this.finishNode(f, "ParenthesizedExpression")
                            }
                            return e
                        }, q.parseParenItem = function(t) {
                            return t
                        }, q.parseParenArrowList = function(t, e, n) {
                            return this.parseArrowExpression(this.startNodeAt(t, e), n)
                        };
                        var Y = [];
                        q.parseNew = function() {
                            this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword new");
                            var t = this.startNode(),
                                e = this.parseIdent(!0);
                            if (this.options.ecmaVersion >= 6 && this.eat(b.dot)) {
                                t.meta = e;
                                var n = this.containsEsc;
                                return t.property = this.parseIdent(!0), ("target" !== t.property.name || n) && this.raiseRecoverable(t.property.start, "The only valid meta property for new is new.target"), this.inNonArrowFunction() || this.raiseRecoverable(t.start, "new.target can only be used in functions"), this.finishNode(t, "MetaProperty")
                            }
                            var i = this.start,
                                s = this.startLoc,
                                r = this.type === b._import;
                            return t.callee = this.parseSubscripts(this.parseExprAtom(), i, s, !0), r && "ImportExpression" === t.callee.type && this.raise(i, "Cannot use new with import()"), this.eat(b.parenL) ? t.arguments = this.parseExprList(b.parenR, this.options.ecmaVersion >= 8, !1) : t.arguments = Y, this.finishNode(t, "NewExpression")
                        }, q.parseTemplateElement = function(t) {
                            var e = t.isTagged,
                                n = this.startNode();
                            return this.type === b.invalidTemplate ? (e || this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal"), n.value = {
                                raw: this.value,
                                cooked: null
                            }) : n.value = {
                                raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
                                cooked: this.value
                            }, this.next(), n.tail = this.type === b.backQuote, this.finishNode(n, "TemplateElement")
                        }, q.parseTemplate = function(t) {
                            void 0 === t && (t = {});
                            var e = t.isTagged;
                            void 0 === e && (e = !1);
                            var n = this.startNode();
                            this.next(), n.expressions = [];
                            var i = this.parseTemplateElement({
                                isTagged: e
                            });
                            for (n.quasis = [i]; !i.tail;) this.type === b.eof && this.raise(this.pos, "Unterminated template literal"), this.expect(b.dollarBraceL), n.expressions.push(this.parseExpression()), this.expect(b.braceR), n.quasis.push(i = this.parseTemplateElement({
                                isTagged: e
                            }));
                            return this.next(), this.finishNode(n, "TemplateLiteral")
                        }, q.isAsyncProp = function(t) {
                            return !t.computed && "Identifier" === t.key.type && "async" === t.key.name && (this.type === b.name || this.type === b.num || this.type === b.string || this.type === b.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === b.star) && !w.test(this.input.slice(this.lastTokEnd, this.start))
                        }, q.parseObj = function(t, e) {
                            var n = this.startNode(),
                                i = !0,
                                s = {};
                            for (n.properties = [], this.next(); !this.eat(b.braceR);) {
                                if (i) i = !1;
                                else if (this.expect(b.comma), this.options.ecmaVersion >= 5 && this.afterTrailingComma(b.braceR)) break;
                                var r = this.parseProperty(t, e);
                                t || this.checkPropClash(r, s, e), n.properties.push(r)
                            }
                            return this.finishNode(n, t ? "ObjectPattern" : "ObjectExpression")
                        }, q.parseProperty = function(t, e) {
                            var n, i, s, r, a = this.startNode();
                            if (this.options.ecmaVersion >= 9 && this.eat(b.ellipsis)) return t ? (a.argument = this.parseIdent(!1), this.type === b.comma && this.raise(this.start, "Comma is not permitted after the rest element"), this.finishNode(a, "RestElement")) : (this.type === b.parenL && e && (e.parenthesizedAssign < 0 && (e.parenthesizedAssign = this.start), e.parenthesizedBind < 0 && (e.parenthesizedBind = this.start)), a.argument = this.parseMaybeAssign(!1, e), this.type === b.comma && e && e.trailingComma < 0 && (e.trailingComma = this.start), this.finishNode(a, "SpreadElement"));
                            this.options.ecmaVersion >= 6 && (a.method = !1, a.shorthand = !1, (t || e) && (s = this.start, r = this.startLoc), t || (n = this.eat(b.star)));
                            var o = this.containsEsc;
                            return this.parsePropertyName(a), !t && !o && this.options.ecmaVersion >= 8 && !n && this.isAsyncProp(a) ? (i = !0, n = this.options.ecmaVersion >= 9 && this.eat(b.star), this.parsePropertyName(a, e)) : i = !1, this.parsePropertyValue(a, t, n, i, s, r, e, o), this.finishNode(a, "Property")
                        }, q.parsePropertyValue = function(t, e, n, i, s, r, a, o) {
                            if ((n || i) && this.type === b.colon && this.unexpected(), this.eat(b.colon)) t.value = e ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(!1, a), t.kind = "init";
                            else if (this.options.ecmaVersion >= 6 && this.type === b.parenL) e && this.unexpected(), t.kind = "init", t.method = !0, t.value = this.parseMethod(n, i);
                            else if (e || o || !(this.options.ecmaVersion >= 5) || t.computed || "Identifier" !== t.key.type || "get" !== t.key.name && "set" !== t.key.name || this.type === b.comma || this.type === b.braceR) this.options.ecmaVersion >= 6 && !t.computed && "Identifier" === t.key.type ? ((n || i) && this.unexpected(), this.checkUnreserved(t.key), "await" !== t.key.name || this.awaitIdentPos || (this.awaitIdentPos = s), t.kind = "init", e ? t.value = this.parseMaybeDefault(s, r, t.key) : this.type === b.eq && a ? (a.shorthandAssign < 0 && (a.shorthandAssign = this.start), t.value = this.parseMaybeDefault(s, r, t.key)) : t.value = t.key, t.shorthand = !0) : this.unexpected();
                            else {
                                (n || i) && this.unexpected(), t.kind = t.key.name, this.parsePropertyName(t), t.value = this.parseMethod(!1);
                                var u = "get" === t.kind ? 0 : 1;
                                if (t.value.params.length !== u) {
                                    var h = t.value.start;
                                    "get" === t.kind ? this.raiseRecoverable(h, "getter should have no params") : this.raiseRecoverable(h, "setter should have exactly one param")
                                } else "set" === t.kind && "RestElement" === t.value.params[0].type && this.raiseRecoverable(t.value.params[0].start, "Setter cannot use rest params")
                            }
                        }, q.parsePropertyName = function(t) {
                            if (this.options.ecmaVersion >= 6) {
                                if (this.eat(b.bracketL)) return t.computed = !0, t.key = this.parseMaybeAssign(), this.expect(b.bracketR), t.key;
                                t.computed = !1
                            }
                            return t.key = this.type === b.num || this.type === b.string ? this.parseExprAtom() : this.parseIdent("never" !== this.options.allowReserved)
                        }, q.initFunction = function(t) {
                            t.id = null, this.options.ecmaVersion >= 6 && (t.generator = t.expression = !1), this.options.ecmaVersion >= 8 && (t.async = !1)
                        }, q.parseMethod = function(t, e, n) {
                            var i = this.startNode(),
                                s = this.yieldPos,
                                r = this.awaitPos,
                                a = this.awaitIdentPos;
                            return this.initFunction(i), this.options.ecmaVersion >= 6 && (i.generator = t), this.options.ecmaVersion >= 8 && (i.async = !!e), this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(64 | $(e, i.generator) | (n ? 128 : 0)), this.expect(b.parenL), i.params = this.parseBindingList(b.parenR, !1, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams(), this.parseFunctionBody(i, !1, !0), this.yieldPos = s, this.awaitPos = r, this.awaitIdentPos = a, this.finishNode(i, "FunctionExpression")
                        }, q.parseArrowExpression = function(t, e, n) {
                            var i = this.yieldPos,
                                s = this.awaitPos,
                                r = this.awaitIdentPos;
                            return this.enterScope(16 | $(n, !1)), this.initFunction(t), this.options.ecmaVersion >= 8 && (t.async = !!n), this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, t.params = this.toAssignableList(e, !0), this.parseFunctionBody(t, !0, !1), this.yieldPos = i, this.awaitPos = s, this.awaitIdentPos = r, this.finishNode(t, "ArrowFunctionExpression")
                        }, q.parseFunctionBody = function(t, e, n) {
                            var i = e && this.type !== b.braceL,
                                s = this.strict,
                                r = !1;
                            if (i) t.body = this.parseMaybeAssign(), t.expression = !0, this.checkParams(t, !1);
                            else {
                                var a = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(t.params);
                                s && !a || (r = this.strictDirective(this.end)) && a && this.raiseRecoverable(t.start, "Illegal 'use strict' directive in function with non-simple parameter list");
                                var o = this.labels;
                                this.labels = [], r && (this.strict = !0), this.checkParams(t, !s && !r && !e && !n && this.isSimpleParamList(t.params)), t.body = this.parseBlock(!1), t.expression = !1, this.adaptDirectivePrologue(t.body.body), this.labels = o
                            }
                            this.exitScope(), this.strict && t.id && this.checkLVal(t.id, 5), this.strict = s
                        }, q.isSimpleParamList = function(t) {
                            for (var e = 0, n = t; e < n.length; e += 1)
                                if ("Identifier" !== n[e].type) return !1;
                            return !0
                        }, q.checkParams = function(t, e) {
                            for (var n = {}, i = 0, s = t.params; i < s.length; i += 1) {
                                var r = s[i];
                                this.checkLVal(r, 1, e ? null : n)
                            }
                        }, q.parseExprList = function(t, e, n, i) {
                            for (var s = [], r = !0; !this.eat(t);) {
                                if (r) r = !1;
                                else if (this.expect(b.comma), e && this.afterTrailingComma(t)) break;
                                var a = void 0;
                                n && this.type === b.comma ? a = null : this.type === b.ellipsis ? (a = this.parseSpread(i), i && this.type === b.comma && i.trailingComma < 0 && (i.trailingComma = this.start)) : a = this.parseMaybeAssign(!1, i), s.push(a)
                            }
                            return s
                        }, q.checkUnreserved = function(t) {
                            var e = t.start,
                                n = t.end,
                                i = t.name;
                            this.inGenerator && "yield" === i && this.raiseRecoverable(e, "Cannot use 'yield' as identifier inside a generator"), this.inAsync && "await" === i && this.raiseRecoverable(e, "Cannot use 'await' as identifier inside an async function"), this.keywords.test(i) && this.raise(e, "Unexpected keyword '" + i + "'"), this.options.ecmaVersion < 6 && -1 !== this.input.slice(e, n).indexOf("\\") || (this.strict ? this.reservedWordsStrict : this.reservedWords).test(i) && (this.inAsync || "await" !== i || this.raiseRecoverable(e, "Cannot use keyword 'await' outside an async function"), this.raiseRecoverable(e, "The keyword '" + i + "' is reserved"))
                        }, q.parseIdent = function(t, e) {
                            var n = this.startNode();
                            return this.type === b.name ? n.name = this.value : this.type.keyword ? (n.name = this.type.keyword, "class" !== n.name && "function" !== n.name || this.lastTokEnd === this.lastTokStart + 1 && 46 === this.input.charCodeAt(this.lastTokStart) || this.context.pop()) : this.unexpected(), this.next(!!t), this.finishNode(n, "Identifier"), t || (this.checkUnreserved(n), "await" !== n.name || this.awaitIdentPos || (this.awaitIdentPos = n.start)), n
                        }, q.parseYield = function(t) {
                            this.yieldPos || (this.yieldPos = this.start);
                            var e = this.startNode();
                            return this.next(), this.type === b.semi || this.canInsertSemicolon() || this.type !== b.star && !this.type.startsExpr ? (e.delegate = !1, e.argument = null) : (e.delegate = this.eat(b.star), e.argument = this.parseMaybeAssign(t)), this.finishNode(e, "YieldExpression")
                        }, q.parseAwait = function() {
                            this.awaitPos || (this.awaitPos = this.start);
                            var t = this.startNode();
                            return this.next(), t.argument = this.parseMaybeUnary(null, !1), this.finishNode(t, "AwaitExpression")
                        };
                        var J = U.prototype;
                        J.raise = function(t, e) {
                            var n = R(this.input, t);
                            e += " (" + n.line + ":" + n.column + ")";
                            var i = new SyntaxError(e);
                            throw i.pos = t, i.loc = n, i.raisedAt = this.pos, i
                        }, J.raiseRecoverable = J.raise, J.curPosition = function() {
                            if (this.options.locations) return new M(this.curLine, this.pos - this.lineStart)
                        };
                        var Q = U.prototype,
                            tt = function(t) {
                                this.flags = t, this.var = [], this.lexical = [], this.functions = []
                            };
                        Q.enterScope = function(t) {
                            this.scopeStack.push(new tt(t))
                        }, Q.exitScope = function() {
                            this.scopeStack.pop()
                        }, Q.treatFunctionsAsVarInScope = function(t) {
                            return 2 & t.flags || !this.inModule && 1 & t.flags
                        }, Q.declareName = function(t, e, n) {
                            var i = !1;
                            if (2 === e) {
                                var s = this.currentScope();
                                i = s.lexical.indexOf(t) > -1 || s.functions.indexOf(t) > -1 || s.var.indexOf(t) > -1, s.lexical.push(t), this.inModule && 1 & s.flags && delete this.undefinedExports[t]
                            } else if (4 === e) this.currentScope().lexical.push(t);
                            else if (3 === e) {
                                var r = this.currentScope();
                                i = this.treatFunctionsAsVar ? r.lexical.indexOf(t) > -1 : r.lexical.indexOf(t) > -1 || r.var.indexOf(t) > -1, r.functions.push(t)
                            } else
                                for (var a = this.scopeStack.length - 1; a >= 0; --a) {
                                    var o = this.scopeStack[a];
                                    if (o.lexical.indexOf(t) > -1 && !(32 & o.flags && o.lexical[0] === t) || !this.treatFunctionsAsVarInScope(o) && o.functions.indexOf(t) > -1) {
                                        i = !0;
                                        break
                                    }
                                    if (o.var.push(t), this.inModule && 1 & o.flags && delete this.undefinedExports[t], 3 & o.flags) break
                                }
                            i && this.raiseRecoverable(n, "Identifier '" + t + "' has already been declared")
                        }, Q.checkLocalExport = function(t) {
                            -1 === this.scopeStack[0].lexical.indexOf(t.name) && -1 === this.scopeStack[0].var.indexOf(t.name) && (this.undefinedExports[t.name] = t)
                        }, Q.currentScope = function() {
                            return this.scopeStack[this.scopeStack.length - 1]
                        }, Q.currentVarScope = function() {
                            for (var t = this.scopeStack.length - 1;; t--) {
                                var e = this.scopeStack[t];
                                if (3 & e.flags) return e
                            }
                        }, Q.currentThisScope = function() {
                            for (var t = this.scopeStack.length - 1;; t--) {
                                var e = this.scopeStack[t];
                                if (3 & e.flags && !(16 & e.flags)) return e
                            }
                        };
                        var et = function(t, e, n) {
                                this.type = "", this.start = e, this.end = 0, t.options.locations && (this.loc = new O(t, n)), t.options.directSourceFile && (this.sourceFile = t.options.directSourceFile), t.options.ranges && (this.range = [e, 0])
                            },
                            nt = U.prototype;

                        function it(t, e, n, i) {
                            return t.type = e, t.end = n, this.options.locations && (t.loc.end = i), this.options.ranges && (t.range[1] = n), t
                        }
                        nt.startNode = function() {
                            return new et(this, this.start, this.startLoc)
                        }, nt.startNodeAt = function(t, e) {
                            return new et(this, t, e)
                        }, nt.finishNode = function(t, e) {
                            return it.call(this, t, e, this.lastTokEnd, this.lastTokEndLoc)
                        }, nt.finishNodeAt = function(t, e, n, i) {
                            return it.call(this, t, e, n, i)
                        };
                        var st = function(t, e, n, i, s) {
                                this.token = t, this.isExpr = !!e, this.preserveSpace = !!n, this.override = i, this.generator = !!s
                            },
                            rt = {
                                b_stat: new st("{", !1),
                                b_expr: new st("{", !0),
                                b_tmpl: new st("${", !1),
                                p_stat: new st("(", !1),
                                p_expr: new st("(", !0),
                                q_tmpl: new st("`", !0, !0, (function(t) {
                                    return t.tryReadTemplateToken()
                                })),
                                f_stat: new st("function", !1),
                                f_expr: new st("function", !0),
                                f_expr_gen: new st("function", !0, !1, null, !0),
                                f_gen: new st("function", !1, !1, null, !0)
                            },
                            at = U.prototype;
                        at.initialContext = function() {
                            return [rt.b_stat]
                        }, at.braceIsBlock = function(t) {
                            var e = this.curContext();
                            return e === rt.f_expr || e === rt.f_stat || (t !== b.colon || e !== rt.b_stat && e !== rt.b_expr ? t === b._return || t === b.name && this.exprAllowed ? w.test(this.input.slice(this.lastTokEnd, this.start)) : t === b._else || t === b.semi || t === b.eof || t === b.parenR || t === b.arrow || (t === b.braceL ? e === rt.b_stat : t !== b._var && t !== b._const && t !== b.name && !this.exprAllowed) : !e.isExpr)
                        }, at.inGeneratorContext = function() {
                            for (var t = this.context.length - 1; t >= 1; t--) {
                                var e = this.context[t];
                                if ("function" === e.token) return e.generator
                            }
                            return !1
                        }, at.updateContext = function(t) {
                            var e, n = this.type;
                            n.keyword && t === b.dot ? this.exprAllowed = !1 : (e = n.updateContext) ? e.call(this, t) : this.exprAllowed = n.beforeExpr
                        }, b.parenR.updateContext = b.braceR.updateContext = function() {
                            if (1 !== this.context.length) {
                                var t = this.context.pop();
                                t === rt.b_stat && "function" === this.curContext().token && (t = this.context.pop()), this.exprAllowed = !t.isExpr
                            } else this.exprAllowed = !0
                        }, b.braceL.updateContext = function(t) {
                            this.context.push(this.braceIsBlock(t) ? rt.b_stat : rt.b_expr), this.exprAllowed = !0
                        }, b.dollarBraceL.updateContext = function() {
                            this.context.push(rt.b_tmpl), this.exprAllowed = !0
                        }, b.parenL.updateContext = function(t) {
                            var e = t === b._if || t === b._for || t === b._with || t === b._while;
                            this.context.push(e ? rt.p_stat : rt.p_expr), this.exprAllowed = !0
                        }, b.incDec.updateContext = function() {}, b._function.updateContext = b._class.updateContext = function(t) {
                            !t.beforeExpr || t === b.semi || t === b._else || t === b._return && w.test(this.input.slice(this.lastTokEnd, this.start)) || (t === b.colon || t === b.braceL) && this.curContext() === rt.b_stat ? this.context.push(rt.f_stat) : this.context.push(rt.f_expr), this.exprAllowed = !1
                        }, b.backQuote.updateContext = function() {
                            this.curContext() === rt.q_tmpl ? this.context.pop() : this.context.push(rt.q_tmpl), this.exprAllowed = !1
                        }, b.star.updateContext = function(t) {
                            if (t === b._function) {
                                var e = this.context.length - 1;
                                this.context[e] === rt.f_expr ? this.context[e] = rt.f_expr_gen : this.context[e] = rt.f_gen
                            }
                            this.exprAllowed = !0
                        }, b.name.updateContext = function(t) {
                            var e = !1;
                            this.options.ecmaVersion >= 6 && t !== b.dot && ("of" === this.value && !this.exprAllowed || "yield" === this.value && this.inGeneratorContext()) && (e = !0), this.exprAllowed = e
                        };
                        var ot = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS",
                            ut = ot + " Extended_Pictographic",
                            ht = {
                                9: ot,
                                10: ut,
                                11: ut
                            },
                            lt = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu",
                            ct = "Adlam Adlm Ahom Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb",
                            pt = ct + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd",
                            dt = {
                                9: ct,
                                10: pt,
                                11: pt + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho"
                            },
                            mt = {};

                        function gt(t) {
                            var e = mt[t] = {
                                binary: C(ht[t] + " " + lt),
                                nonBinary: {
                                    General_Category: C(lt),
                                    Script: C(dt[t])
                                }
                            };
                            e.nonBinary.Script_Extensions = e.nonBinary.Script, e.nonBinary.gc = e.nonBinary.General_Category, e.nonBinary.sc = e.nonBinary.Script, e.nonBinary.scx = e.nonBinary.Script_Extensions
                        }
                        gt(9), gt(10), gt(11);
                        var ft = U.prototype,
                            yt = function(t) {
                                this.parser = t, this.validFlags = "gim" + (t.options.ecmaVersion >= 6 ? "uy" : "") + (t.options.ecmaVersion >= 9 ? "s" : ""), this.unicodeProperties = mt[t.options.ecmaVersion >= 11 ? 11 : t.options.ecmaVersion], this.source = "", this.flags = "", this.start = 0, this.switchU = !1, this.switchN = !1, this.pos = 0, this.lastIntValue = 0, this.lastStringValue = "", this.lastAssertionIsQuantifiable = !1, this.numCapturingParens = 0, this.maxBackReference = 0, this.groupNames = [], this.backReferenceNames = []
                            };

                        function xt(t) {
                            return t <= 65535 ? String.fromCharCode(t) : (t -= 65536, String.fromCharCode(55296 + (t >> 10), 56320 + (1023 & t)))
                        }

                        function _t(t) {
                            return 36 === t || t >= 40 && t <= 43 || 46 === t || 63 === t || t >= 91 && t <= 94 || t >= 123 && t <= 125
                        }

                        function bt(t) {
                            return t >= 65 && t <= 90 || t >= 97 && t <= 122
                        }

                        function wt(t) {
                            return bt(t) || 95 === t
                        }

                        function Tt(t) {
                            return wt(t) || vt(t)
                        }

                        function vt(t) {
                            return t >= 48 && t <= 57
                        }

                        function Et(t) {
                            return t >= 48 && t <= 57 || t >= 65 && t <= 70 || t >= 97 && t <= 102
                        }

                        function At(t) {
                            return t >= 65 && t <= 70 ? t - 65 + 10 : t >= 97 && t <= 102 ? t - 97 + 10 : t - 48
                        }

                        function It(t) {
                            return t >= 48 && t <= 55
                        }
                        yt.prototype.reset = function(t, e, n) {
                            var i = -1 !== n.indexOf("u");
                            this.start = 0 | t, this.source = e + "", this.flags = n, this.switchU = i && this.parser.options.ecmaVersion >= 6, this.switchN = i && this.parser.options.ecmaVersion >= 9
                        }, yt.prototype.raise = function(t) {
                            this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + t)
                        }, yt.prototype.at = function(t) {
                            var e = this.source,
                                n = e.length;
                            if (t >= n) return -1;
                            var i = e.charCodeAt(t);
                            if (!this.switchU || i <= 55295 || i >= 57344 || t + 1 >= n) return i;
                            var s = e.charCodeAt(t + 1);
                            return s >= 56320 && s <= 57343 ? (i << 10) + s - 56613888 : i
                        }, yt.prototype.nextIndex = function(t) {
                            var e = this.source,
                                n = e.length;
                            if (t >= n) return n;
                            var i, s = e.charCodeAt(t);
                            return !this.switchU || s <= 55295 || s >= 57344 || t + 1 >= n || (i = e.charCodeAt(t + 1)) < 56320 || i > 57343 ? t + 1 : t + 2
                        }, yt.prototype.current = function() {
                            return this.at(this.pos)
                        }, yt.prototype.lookahead = function() {
                            return this.at(this.nextIndex(this.pos))
                        }, yt.prototype.advance = function() {
                            this.pos = this.nextIndex(this.pos)
                        }, yt.prototype.eat = function(t) {
                            return this.current() === t && (this.advance(), !0)
                        }, ft.validateRegExpFlags = function(t) {
                            for (var e = t.validFlags, n = t.flags, i = 0; i < n.length; i++) {
                                var s = n.charAt(i); - 1 === e.indexOf(s) && this.raise(t.start, "Invalid regular expression flag"), n.indexOf(s, i + 1) > -1 && this.raise(t.start, "Duplicate regular expression flag")
                            }
                        }, ft.validateRegExpPattern = function(t) {
                            this.regexp_pattern(t), !t.switchN && this.options.ecmaVersion >= 9 && t.groupNames.length > 0 && (t.switchN = !0, this.regexp_pattern(t))
                        }, ft.regexp_pattern = function(t) {
                            t.pos = 0, t.lastIntValue = 0, t.lastStringValue = "", t.lastAssertionIsQuantifiable = !1, t.numCapturingParens = 0, t.maxBackReference = 0, t.groupNames.length = 0, t.backReferenceNames.length = 0, this.regexp_disjunction(t), t.pos !== t.source.length && (t.eat(41) && t.raise("Unmatched ')'"), (t.eat(93) || t.eat(125)) && t.raise("Lone quantifier brackets")), t.maxBackReference > t.numCapturingParens && t.raise("Invalid escape");
                            for (var e = 0, n = t.backReferenceNames; e < n.length; e += 1) {
                                var i = n[e]; - 1 === t.groupNames.indexOf(i) && t.raise("Invalid named capture referenced")
                            }
                        }, ft.regexp_disjunction = function(t) {
                            for (this.regexp_alternative(t); t.eat(124);) this.regexp_alternative(t);
                            this.regexp_eatQuantifier(t, !0) && t.raise("Nothing to repeat"), t.eat(123) && t.raise("Lone quantifier brackets")
                        }, ft.regexp_alternative = function(t) {
                            for (; t.pos < t.source.length && this.regexp_eatTerm(t););
                        }, ft.regexp_eatTerm = function(t) {
                            return this.regexp_eatAssertion(t) ? (t.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(t) && t.switchU && t.raise("Invalid quantifier"), !0) : !!(t.switchU ? this.regexp_eatAtom(t) : this.regexp_eatExtendedAtom(t)) && (this.regexp_eatQuantifier(t), !0)
                        }, ft.regexp_eatAssertion = function(t) {
                            var e = t.pos;
                            if (t.lastAssertionIsQuantifiable = !1, t.eat(94) || t.eat(36)) return !0;
                            if (t.eat(92)) {
                                if (t.eat(66) || t.eat(98)) return !0;
                                t.pos = e
                            }
                            if (t.eat(40) && t.eat(63)) {
                                var n = !1;
                                if (this.options.ecmaVersion >= 9 && (n = t.eat(60)), t.eat(61) || t.eat(33)) return this.regexp_disjunction(t), t.eat(41) || t.raise("Unterminated group"), t.lastAssertionIsQuantifiable = !n, !0
                            }
                            return t.pos = e, !1
                        }, ft.regexp_eatQuantifier = function(t, e) {
                            return void 0 === e && (e = !1), !!this.regexp_eatQuantifierPrefix(t, e) && (t.eat(63), !0)
                        }, ft.regexp_eatQuantifierPrefix = function(t, e) {
                            return t.eat(42) || t.eat(43) || t.eat(63) || this.regexp_eatBracedQuantifier(t, e)
                        }, ft.regexp_eatBracedQuantifier = function(t, e) {
                            var n = t.pos;
                            if (t.eat(123)) {
                                var i = 0,
                                    s = -1;
                                if (this.regexp_eatDecimalDigits(t) && (i = t.lastIntValue, t.eat(44) && this.regexp_eatDecimalDigits(t) && (s = t.lastIntValue), t.eat(125))) return -1 !== s && s < i && !e && t.raise("numbers out of order in {} quantifier"), !0;
                                t.switchU && !e && t.raise("Incomplete quantifier"), t.pos = n
                            }
                            return !1
                        }, ft.regexp_eatAtom = function(t) {
                            return this.regexp_eatPatternCharacters(t) || t.eat(46) || this.regexp_eatReverseSolidusAtomEscape(t) || this.regexp_eatCharacterClass(t) || this.regexp_eatUncapturingGroup(t) || this.regexp_eatCapturingGroup(t)
                        }, ft.regexp_eatReverseSolidusAtomEscape = function(t) {
                            var e = t.pos;
                            if (t.eat(92)) {
                                if (this.regexp_eatAtomEscape(t)) return !0;
                                t.pos = e
                            }
                            return !1
                        }, ft.regexp_eatUncapturingGroup = function(t) {
                            var e = t.pos;
                            if (t.eat(40)) {
                                if (t.eat(63) && t.eat(58)) {
                                    if (this.regexp_disjunction(t), t.eat(41)) return !0;
                                    t.raise("Unterminated group")
                                }
                                t.pos = e
                            }
                            return !1
                        }, ft.regexp_eatCapturingGroup = function(t) {
                            if (t.eat(40)) {
                                if (this.options.ecmaVersion >= 9 ? this.regexp_groupSpecifier(t) : 63 === t.current() && t.raise("Invalid group"), this.regexp_disjunction(t), t.eat(41)) return t.numCapturingParens += 1, !0;
                                t.raise("Unterminated group")
                            }
                            return !1
                        }, ft.regexp_eatExtendedAtom = function(t) {
                            return t.eat(46) || this.regexp_eatReverseSolidusAtomEscape(t) || this.regexp_eatCharacterClass(t) || this.regexp_eatUncapturingGroup(t) || this.regexp_eatCapturingGroup(t) || this.regexp_eatInvalidBracedQuantifier(t) || this.regexp_eatExtendedPatternCharacter(t)
                        }, ft.regexp_eatInvalidBracedQuantifier = function(t) {
                            return this.regexp_eatBracedQuantifier(t, !0) && t.raise("Nothing to repeat"), !1
                        }, ft.regexp_eatSyntaxCharacter = function(t) {
                            var e = t.current();
                            return !!_t(e) && (t.lastIntValue = e, t.advance(), !0)
                        }, ft.regexp_eatPatternCharacters = function(t) {
                            for (var e = t.pos, n = 0; - 1 !== (n = t.current()) && !_t(n);) t.advance();
                            return t.pos !== e
                        }, ft.regexp_eatExtendedPatternCharacter = function(t) {
                            var e = t.current();
                            return !(-1 === e || 36 === e || e >= 40 && e <= 43 || 46 === e || 63 === e || 91 === e || 94 === e || 124 === e || (t.advance(), 0))
                        }, ft.regexp_groupSpecifier = function(t) {
                            if (t.eat(63)) {
                                if (this.regexp_eatGroupName(t)) return -1 !== t.groupNames.indexOf(t.lastStringValue) && t.raise("Duplicate capture group name"), void t.groupNames.push(t.lastStringValue);
                                t.raise("Invalid group")
                            }
                        }, ft.regexp_eatGroupName = function(t) {
                            if (t.lastStringValue = "", t.eat(60)) {
                                if (this.regexp_eatRegExpIdentifierName(t) && t.eat(62)) return !0;
                                t.raise("Invalid capture group name")
                            }
                            return !1
                        }, ft.regexp_eatRegExpIdentifierName = function(t) {
                            if (t.lastStringValue = "", this.regexp_eatRegExpIdentifierStart(t)) {
                                for (t.lastStringValue += xt(t.lastIntValue); this.regexp_eatRegExpIdentifierPart(t);) t.lastStringValue += xt(t.lastIntValue);
                                return !0
                            }
                            return !1
                        }, ft.regexp_eatRegExpIdentifierStart = function(t) {
                            var e = t.pos,
                                n = t.current();
                            return t.advance(), 92 === n && this.regexp_eatRegExpUnicodeEscapeSequence(t) && (n = t.lastIntValue),
                                function(t) {
                                    return p(t, !0) || 36 === t || 95 === t
                                }(n) ? (t.lastIntValue = n, !0) : (t.pos = e, !1)
                        }, ft.regexp_eatRegExpIdentifierPart = function(t) {
                            var e = t.pos,
                                n = t.current();
                            return t.advance(), 92 === n && this.regexp_eatRegExpUnicodeEscapeSequence(t) && (n = t.lastIntValue),
                                function(t) {
                                    return d(t, !0) || 36 === t || 95 === t || 8204 === t || 8205 === t
                                }(n) ? (t.lastIntValue = n, !0) : (t.pos = e, !1)
                        }, ft.regexp_eatAtomEscape = function(t) {
                            return !!(this.regexp_eatBackReference(t) || this.regexp_eatCharacterClassEscape(t) || this.regexp_eatCharacterEscape(t) || t.switchN && this.regexp_eatKGroupName(t)) || (t.switchU && (99 === t.current() && t.raise("Invalid unicode escape"), t.raise("Invalid escape")), !1)
                        }, ft.regexp_eatBackReference = function(t) {
                            var e = t.pos;
                            if (this.regexp_eatDecimalEscape(t)) {
                                var n = t.lastIntValue;
                                if (t.switchU) return n > t.maxBackReference && (t.maxBackReference = n), !0;
                                if (n <= t.numCapturingParens) return !0;
                                t.pos = e
                            }
                            return !1
                        }, ft.regexp_eatKGroupName = function(t) {
                            if (t.eat(107)) {
                                if (this.regexp_eatGroupName(t)) return t.backReferenceNames.push(t.lastStringValue), !0;
                                t.raise("Invalid named reference")
                            }
                            return !1
                        }, ft.regexp_eatCharacterEscape = function(t) {
                            return this.regexp_eatControlEscape(t) || this.regexp_eatCControlLetter(t) || this.regexp_eatZero(t) || this.regexp_eatHexEscapeSequence(t) || this.regexp_eatRegExpUnicodeEscapeSequence(t) || !t.switchU && this.regexp_eatLegacyOctalEscapeSequence(t) || this.regexp_eatIdentityEscape(t)
                        }, ft.regexp_eatCControlLetter = function(t) {
                            var e = t.pos;
                            if (t.eat(99)) {
                                if (this.regexp_eatControlLetter(t)) return !0;
                                t.pos = e
                            }
                            return !1
                        }, ft.regexp_eatZero = function(t) {
                            return 48 === t.current() && !vt(t.lookahead()) && (t.lastIntValue = 0, t.advance(), !0)
                        }, ft.regexp_eatControlEscape = function(t) {
                            var e = t.current();
                            return 116 === e ? (t.lastIntValue = 9, t.advance(), !0) : 110 === e ? (t.lastIntValue = 10, t.advance(), !0) : 118 === e ? (t.lastIntValue = 11, t.advance(), !0) : 102 === e ? (t.lastIntValue = 12, t.advance(), !0) : 114 === e && (t.lastIntValue = 13, t.advance(), !0)
                        }, ft.regexp_eatControlLetter = function(t) {
                            var e = t.current();
                            return !!bt(e) && (t.lastIntValue = e % 32, t.advance(), !0)
                        }, ft.regexp_eatRegExpUnicodeEscapeSequence = function(t) {
                            var e, n = t.pos;
                            if (t.eat(117)) {
                                if (this.regexp_eatFixedHexDigits(t, 4)) {
                                    var i = t.lastIntValue;
                                    if (t.switchU && i >= 55296 && i <= 56319) {
                                        var s = t.pos;
                                        if (t.eat(92) && t.eat(117) && this.regexp_eatFixedHexDigits(t, 4)) {
                                            var r = t.lastIntValue;
                                            if (r >= 56320 && r <= 57343) return t.lastIntValue = 1024 * (i - 55296) + (r - 56320) + 65536, !0
                                        }
                                        t.pos = s, t.lastIntValue = i
                                    }
                                    return !0
                                }
                                if (t.switchU && t.eat(123) && this.regexp_eatHexDigits(t) && t.eat(125) && ((e = t.lastIntValue) >= 0 && e <= 1114111)) return !0;
                                t.switchU && t.raise("Invalid unicode escape"), t.pos = n
                            }
                            return !1
                        }, ft.regexp_eatIdentityEscape = function(t) {
                            if (t.switchU) return !!this.regexp_eatSyntaxCharacter(t) || !!t.eat(47) && (t.lastIntValue = 47, !0);
                            var e = t.current();
                            return !(99 === e || t.switchN && 107 === e || (t.lastIntValue = e, t.advance(), 0))
                        }, ft.regexp_eatDecimalEscape = function(t) {
                            t.lastIntValue = 0;
                            var e = t.current();
                            if (e >= 49 && e <= 57) {
                                do {
                                    t.lastIntValue = 10 * t.lastIntValue + (e - 48), t.advance()
                                } while ((e = t.current()) >= 48 && e <= 57);
                                return !0
                            }
                            return !1
                        }, ft.regexp_eatCharacterClassEscape = function(t) {
                            var e = t.current();
                            if (function(t) {
                                    return 100 === t || 68 === t || 115 === t || 83 === t || 119 === t || 87 === t
                                }(e)) return t.lastIntValue = -1, t.advance(), !0;
                            if (t.switchU && this.options.ecmaVersion >= 9 && (80 === e || 112 === e)) {
                                if (t.lastIntValue = -1, t.advance(), t.eat(123) && this.regexp_eatUnicodePropertyValueExpression(t) && t.eat(125)) return !0;
                                t.raise("Invalid property name")
                            }
                            return !1
                        }, ft.regexp_eatUnicodePropertyValueExpression = function(t) {
                            var e = t.pos;
                            if (this.regexp_eatUnicodePropertyName(t) && t.eat(61)) {
                                var n = t.lastStringValue;
                                if (this.regexp_eatUnicodePropertyValue(t)) {
                                    var i = t.lastStringValue;
                                    return this.regexp_validateUnicodePropertyNameAndValue(t, n, i), !0
                                }
                            }
                            if (t.pos = e, this.regexp_eatLoneUnicodePropertyNameOrValue(t)) {
                                var s = t.lastStringValue;
                                return this.regexp_validateUnicodePropertyNameOrValue(t, s), !0
                            }
                            return !1
                        }, ft.regexp_validateUnicodePropertyNameAndValue = function(t, e, n) {
                            D(t.unicodeProperties.nonBinary, e) || t.raise("Invalid property name"), t.unicodeProperties.nonBinary[e].test(n) || t.raise("Invalid property value")
                        }, ft.regexp_validateUnicodePropertyNameOrValue = function(t, e) {
                            t.unicodeProperties.binary.test(e) || t.raise("Invalid property name")
                        }, ft.regexp_eatUnicodePropertyName = function(t) {
                            var e = 0;
                            for (t.lastStringValue = ""; wt(e = t.current());) t.lastStringValue += xt(e), t.advance();
                            return "" !== t.lastStringValue
                        }, ft.regexp_eatUnicodePropertyValue = function(t) {
                            var e = 0;
                            for (t.lastStringValue = ""; Tt(e = t.current());) t.lastStringValue += xt(e), t.advance();
                            return "" !== t.lastStringValue
                        }, ft.regexp_eatLoneUnicodePropertyNameOrValue = function(t) {
                            return this.regexp_eatUnicodePropertyValue(t)
                        }, ft.regexp_eatCharacterClass = function(t) {
                            if (t.eat(91)) {
                                if (t.eat(94), this.regexp_classRanges(t), t.eat(93)) return !0;
                                t.raise("Unterminated character class")
                            }
                            return !1
                        }, ft.regexp_classRanges = function(t) {
                            for (; this.regexp_eatClassAtom(t);) {
                                var e = t.lastIntValue;
                                if (t.eat(45) && this.regexp_eatClassAtom(t)) {
                                    var n = t.lastIntValue;
                                    !t.switchU || -1 !== e && -1 !== n || t.raise("Invalid character class"), -1 !== e && -1 !== n && e > n && t.raise("Range out of order in character class")
                                }
                            }
                        }, ft.regexp_eatClassAtom = function(t) {
                            var e = t.pos;
                            if (t.eat(92)) {
                                if (this.regexp_eatClassEscape(t)) return !0;
                                if (t.switchU) {
                                    var n = t.current();
                                    (99 === n || It(n)) && t.raise("Invalid class escape"), t.raise("Invalid escape")
                                }
                                t.pos = e
                            }
                            var i = t.current();
                            return 93 !== i && (t.lastIntValue = i, t.advance(), !0)
                        }, ft.regexp_eatClassEscape = function(t) {
                            var e = t.pos;
                            if (t.eat(98)) return t.lastIntValue = 8, !0;
                            if (t.switchU && t.eat(45)) return t.lastIntValue = 45, !0;
                            if (!t.switchU && t.eat(99)) {
                                if (this.regexp_eatClassControlLetter(t)) return !0;
                                t.pos = e
                            }
                            return this.regexp_eatCharacterClassEscape(t) || this.regexp_eatCharacterEscape(t)
                        }, ft.regexp_eatClassControlLetter = function(t) {
                            var e = t.current();
                            return !(!vt(e) && 95 !== e || (t.lastIntValue = e % 32, t.advance(), 0))
                        }, ft.regexp_eatHexEscapeSequence = function(t) {
                            var e = t.pos;
                            if (t.eat(120)) {
                                if (this.regexp_eatFixedHexDigits(t, 2)) return !0;
                                t.switchU && t.raise("Invalid escape"), t.pos = e
                            }
                            return !1
                        }, ft.regexp_eatDecimalDigits = function(t) {
                            var e = t.pos,
                                n = 0;
                            for (t.lastIntValue = 0; vt(n = t.current());) t.lastIntValue = 10 * t.lastIntValue + (n - 48), t.advance();
                            return t.pos !== e
                        }, ft.regexp_eatHexDigits = function(t) {
                            var e = t.pos,
                                n = 0;
                            for (t.lastIntValue = 0; Et(n = t.current());) t.lastIntValue = 16 * t.lastIntValue + At(n), t.advance();
                            return t.pos !== e
                        }, ft.regexp_eatLegacyOctalEscapeSequence = function(t) {
                            if (this.regexp_eatOctalDigit(t)) {
                                var e = t.lastIntValue;
                                if (this.regexp_eatOctalDigit(t)) {
                                    var n = t.lastIntValue;
                                    e <= 3 && this.regexp_eatOctalDigit(t) ? t.lastIntValue = 64 * e + 8 * n + t.lastIntValue : t.lastIntValue = 8 * e + n
                                } else t.lastIntValue = e;
                                return !0
                            }
                            return !1
                        }, ft.regexp_eatOctalDigit = function(t) {
                            var e = t.current();
                            return It(e) ? (t.lastIntValue = e - 48, t.advance(), !0) : (t.lastIntValue = 0, !1)
                        }, ft.regexp_eatFixedHexDigits = function(t, e) {
                            var n = t.pos;
                            t.lastIntValue = 0;
                            for (var i = 0; i < e; ++i) {
                                var s = t.current();
                                if (!Et(s)) return t.pos = n, !1;
                                t.lastIntValue = 16 * t.lastIntValue + At(s), t.advance()
                            }
                            return !0
                        };
                        var St = function(t) {
                                this.type = t.type, this.value = t.value, this.start = t.start, this.end = t.end, t.options.locations && (this.loc = new O(t, t.startLoc, t.endLoc)), t.options.ranges && (this.range = [t.start, t.end])
                            },
                            kt = U.prototype;

                        function Dt(t) {
                            return t <= 65535 ? String.fromCharCode(t) : (t -= 65536, String.fromCharCode(55296 + (t >> 10), 56320 + (1023 & t)))
                        }
                        kt.next = function(t) {
                            !t && this.type.keyword && this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword), this.options.onToken && this.options.onToken(new St(this)), this.lastTokEnd = this.end, this.lastTokStart = this.start, this.lastTokEndLoc = this.endLoc, this.lastTokStartLoc = this.startLoc, this.nextToken()
                        }, kt.getToken = function() {
                            return this.next(), new St(this)
                        }, "undefined" != typeof Symbol && (kt[Symbol.iterator] = function() {
                            var t = this;
                            return {
                                next: function() {
                                    var e = t.getToken();
                                    return {
                                        done: e.type === b.eof,
                                        value: e
                                    }
                                }
                            }
                        }), kt.curContext = function() {
                            return this.context[this.context.length - 1]
                        }, kt.nextToken = function() {
                            var t = this.curContext();
                            return t && t.preserveSpace || this.skipSpace(), this.start = this.pos, this.options.locations && (this.startLoc = this.curPosition()), this.pos >= this.input.length ? this.finishToken(b.eof) : t.override ? t.override(this) : void this.readToken(this.fullCharCodeAtPos())
                        }, kt.readToken = function(t) {
                            return p(t, this.options.ecmaVersion >= 6) || 92 === t ? this.readWord() : this.getTokenFromCode(t)
                        }, kt.fullCharCodeAtPos = function() {
                            var t = this.input.charCodeAt(this.pos);
                            return t <= 55295 || t >= 57344 ? t : (t << 10) + this.input.charCodeAt(this.pos + 1) - 56613888
                        }, kt.skipBlockComment = function() {
                            var t, e = this.options.onComment && this.curPosition(),
                                n = this.pos,
                                i = this.input.indexOf("*/", this.pos += 2);
                            if (-1 === i && this.raise(this.pos - 2, "Unterminated comment"), this.pos = i + 2, this.options.locations)
                                for (T.lastIndex = n;
                                    (t = T.exec(this.input)) && t.index < this.pos;) ++this.curLine, this.lineStart = t.index + t[0].length;
                            this.options.onComment && this.options.onComment(!0, this.input.slice(n + 2, i), n, this.pos, e, this.curPosition())
                        }, kt.skipLineComment = function(t) {
                            for (var e = this.pos, n = this.options.onComment && this.curPosition(), i = this.input.charCodeAt(this.pos += t); this.pos < this.input.length && !v(i);) i = this.input.charCodeAt(++this.pos);
                            this.options.onComment && this.options.onComment(!1, this.input.slice(e + t, this.pos), e, this.pos, n, this.curPosition())
                        }, kt.skipSpace = function() {
                            t: for (; this.pos < this.input.length;) {
                                var t = this.input.charCodeAt(this.pos);
                                switch (t) {
                                    case 32:
                                    case 160:
                                        ++this.pos;
                                        break;
                                    case 13:
                                        10 === this.input.charCodeAt(this.pos + 1) && ++this.pos;
                                    case 10:
                                    case 8232:
                                    case 8233:
                                        ++this.pos, this.options.locations && (++this.curLine, this.lineStart = this.pos);
                                        break;
                                    case 47:
                                        switch (this.input.charCodeAt(this.pos + 1)) {
                                            case 42:
                                                this.skipBlockComment();
                                                break;
                                            case 47:
                                                this.skipLineComment(2);
                                                break;
                                            default:
                                                break t
                                        }
                                        break;
                                    default:
                                        if (!(t > 8 && t < 14 || t >= 5760 && E.test(String.fromCharCode(t)))) break t;
                                        ++this.pos
                                }
                            }
                        }, kt.finishToken = function(t, e) {
                            this.end = this.pos, this.options.locations && (this.endLoc = this.curPosition());
                            var n = this.type;
                            this.type = t, this.value = e, this.updateContext(n)
                        }, kt.readToken_dot = function() {
                            var t = this.input.charCodeAt(this.pos + 1);
                            if (t >= 48 && t <= 57) return this.readNumber(!0);
                            var e = this.input.charCodeAt(this.pos + 2);
                            return this.options.ecmaVersion >= 6 && 46 === t && 46 === e ? (this.pos += 3, this.finishToken(b.ellipsis)) : (++this.pos, this.finishToken(b.dot))
                        }, kt.readToken_slash = function() {
                            var t = this.input.charCodeAt(this.pos + 1);
                            return this.exprAllowed ? (++this.pos, this.readRegexp()) : 61 === t ? this.finishOp(b.assign, 2) : this.finishOp(b.slash, 1)
                        }, kt.readToken_mult_modulo_exp = function(t) {
                            var e = this.input.charCodeAt(this.pos + 1),
                                n = 1,
                                i = 42 === t ? b.star : b.modulo;
                            return this.options.ecmaVersion >= 7 && 42 === t && 42 === e && (++n, i = b.starstar, e = this.input.charCodeAt(this.pos + 2)), 61 === e ? this.finishOp(b.assign, n + 1) : this.finishOp(i, n)
                        }, kt.readToken_pipe_amp = function(t) {
                            var e = this.input.charCodeAt(this.pos + 1);
                            return e === t ? this.finishOp(124 === t ? b.logicalOR : b.logicalAND, 2) : 61 === e ? this.finishOp(b.assign, 2) : this.finishOp(124 === t ? b.bitwiseOR : b.bitwiseAND, 1)
                        }, kt.readToken_caret = function() {
                            return 61 === this.input.charCodeAt(this.pos + 1) ? this.finishOp(b.assign, 2) : this.finishOp(b.bitwiseXOR, 1)
                        }, kt.readToken_plus_min = function(t) {
                            var e = this.input.charCodeAt(this.pos + 1);
                            return e === t ? 45 !== e || this.inModule || 62 !== this.input.charCodeAt(this.pos + 2) || 0 !== this.lastTokEnd && !w.test(this.input.slice(this.lastTokEnd, this.pos)) ? this.finishOp(b.incDec, 2) : (this.skipLineComment(3), this.skipSpace(), this.nextToken()) : 61 === e ? this.finishOp(b.assign, 2) : this.finishOp(b.plusMin, 1)
                        }, kt.readToken_lt_gt = function(t) {
                            var e = this.input.charCodeAt(this.pos + 1),
                                n = 1;
                            return e === t ? (n = 62 === t && 62 === this.input.charCodeAt(this.pos + 2) ? 3 : 2, 61 === this.input.charCodeAt(this.pos + n) ? this.finishOp(b.assign, n + 1) : this.finishOp(b.bitShift, n)) : 33 !== e || 60 !== t || this.inModule || 45 !== this.input.charCodeAt(this.pos + 2) || 45 !== this.input.charCodeAt(this.pos + 3) ? (61 === e && (n = 2), this.finishOp(b.relational, n)) : (this.skipLineComment(4), this.skipSpace(), this.nextToken())
                        }, kt.readToken_eq_excl = function(t) {
                            var e = this.input.charCodeAt(this.pos + 1);
                            return 61 === e ? this.finishOp(b.equality, 61 === this.input.charCodeAt(this.pos + 2) ? 3 : 2) : 61 === t && 62 === e && this.options.ecmaVersion >= 6 ? (this.pos += 2, this.finishToken(b.arrow)) : this.finishOp(61 === t ? b.eq : b.prefix, 1)
                        }, kt.getTokenFromCode = function(t) {
                            switch (t) {
                                case 46:
                                    return this.readToken_dot();
                                case 40:
                                    return ++this.pos, this.finishToken(b.parenL);
                                case 41:
                                    return ++this.pos, this.finishToken(b.parenR);
                                case 59:
                                    return ++this.pos, this.finishToken(b.semi);
                                case 44:
                                    return ++this.pos, this.finishToken(b.comma);
                                case 91:
                                    return ++this.pos, this.finishToken(b.bracketL);
                                case 93:
                                    return ++this.pos, this.finishToken(b.bracketR);
                                case 123:
                                    return ++this.pos, this.finishToken(b.braceL);
                                case 125:
                                    return ++this.pos, this.finishToken(b.braceR);
                                case 58:
                                    return ++this.pos, this.finishToken(b.colon);
                                case 63:
                                    return ++this.pos, this.finishToken(b.question);
                                case 96:
                                    if (this.options.ecmaVersion < 6) break;
                                    return ++this.pos, this.finishToken(b.backQuote);
                                case 48:
                                    var e = this.input.charCodeAt(this.pos + 1);
                                    if (120 === e || 88 === e) return this.readRadixNumber(16);
                                    if (this.options.ecmaVersion >= 6) {
                                        if (111 === e || 79 === e) return this.readRadixNumber(8);
                                        if (98 === e || 66 === e) return this.readRadixNumber(2)
                                    }
                                    case 49:
                                    case 50:
                                    case 51:
                                    case 52:
                                    case 53:
                                    case 54:
                                    case 55:
                                    case 56:
                                    case 57:
                                        return this.readNumber(!1);
                                    case 34:
                                    case 39:
                                        return this.readString(t);
                                    case 47:
                                        return this.readToken_slash();
                                    case 37:
                                    case 42:
                                        return this.readToken_mult_modulo_exp(t);
                                    case 124:
                                    case 38:
                                        return this.readToken_pipe_amp(t);
                                    case 94:
                                        return this.readToken_caret();
                                    case 43:
                                    case 45:
                                        return this.readToken_plus_min(t);
                                    case 60:
                                    case 62:
                                        return this.readToken_lt_gt(t);
                                    case 61:
                                    case 33:
                                        return this.readToken_eq_excl(t);
                                    case 126:
                                        return this.finishOp(b.prefix, 1)
                            }
                            this.raise(this.pos, "Unexpected character '" + Dt(t) + "'")
                        }, kt.finishOp = function(t, e) {
                            var n = this.input.slice(this.pos, this.pos + e);
                            return this.pos += e, this.finishToken(t, n)
                        }, kt.readRegexp = function() {
                            for (var t, e, n = this.pos;;) {
                                this.pos >= this.input.length && this.raise(n, "Unterminated regular expression");
                                var i = this.input.charAt(this.pos);
                                if (w.test(i) && this.raise(n, "Unterminated regular expression"), t) t = !1;
                                else {
                                    if ("[" === i) e = !0;
                                    else if ("]" === i && e) e = !1;
                                    else if ("/" === i && !e) break;
                                    t = "\\" === i
                                }++this.pos
                            }
                            var s = this.input.slice(n, this.pos);
                            ++this.pos;
                            var r = this.pos,
                                a = this.readWord1();
                            this.containsEsc && this.unexpected(r);
                            var o = this.regexpState || (this.regexpState = new yt(this));
                            o.reset(n, s, a), this.validateRegExpFlags(o), this.validateRegExpPattern(o);
                            var u = null;
                            try {
                                u = new RegExp(s, a)
                            } catch (t) {}
                            return this.finishToken(b.regexp, {
                                pattern: s,
                                flags: a,
                                value: u
                            })
                        }, kt.readInt = function(t, e) {
                            for (var n = this.pos, i = 0, s = 0, r = null == e ? 1 / 0 : e; s < r; ++s) {
                                var a, o = this.input.charCodeAt(this.pos);
                                if ((a = o >= 97 ? o - 97 + 10 : o >= 65 ? o - 65 + 10 : o >= 48 && o <= 57 ? o - 48 : 1 / 0) >= t) break;
                                ++this.pos, i = i * t + a
                            }
                            return this.pos === n || null != e && this.pos - n !== e ? null : i
                        }, kt.readRadixNumber = function(t) {
                            var e = this.pos;
                            this.pos += 2;
                            var n = this.readInt(t);
                            return null == n && this.raise(this.start + 2, "Expected number in radix " + t), this.options.ecmaVersion >= 11 && 110 === this.input.charCodeAt(this.pos) ? (n = "undefined" != typeof BigInt ? BigInt(this.input.slice(e, this.pos)) : null, ++this.pos) : p(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"), this.finishToken(b.num, n)
                        }, kt.readNumber = function(t) {
                            var e = this.pos;
                            t || null !== this.readInt(10) || this.raise(e, "Invalid number");
                            var n = this.pos - e >= 2 && 48 === this.input.charCodeAt(e);
                            n && this.strict && this.raise(e, "Invalid number");
                            var i = this.input.charCodeAt(this.pos);
                            if (!n && !t && this.options.ecmaVersion >= 11 && 110 === i) {
                                var s = this.input.slice(e, this.pos),
                                    r = "undefined" != typeof BigInt ? BigInt(s) : null;
                                return ++this.pos, p(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"), this.finishToken(b.num, r)
                            }
                            n && /[89]/.test(this.input.slice(e, this.pos)) && (n = !1), 46 !== i || n || (++this.pos, this.readInt(10), i = this.input.charCodeAt(this.pos)), 69 !== i && 101 !== i || n || (43 !== (i = this.input.charCodeAt(++this.pos)) && 45 !== i || ++this.pos, null === this.readInt(10) && this.raise(e, "Invalid number")), p(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number");
                            var a = this.input.slice(e, this.pos),
                                o = n ? parseInt(a, 8) : parseFloat(a);
                            return this.finishToken(b.num, o)
                        }, kt.readCodePoint = function() {
                            var t;
                            if (123 === this.input.charCodeAt(this.pos)) {
                                this.options.ecmaVersion < 6 && this.unexpected();
                                var e = ++this.pos;
                                t = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos), ++this.pos, t > 1114111 && this.invalidStringToken(e, "Code point out of bounds")
                            } else t = this.readHexChar(4);
                            return t
                        }, kt.readString = function(t) {
                            for (var e = "", n = ++this.pos;;) {
                                this.pos >= this.input.length && this.raise(this.start, "Unterminated string constant");
                                var i = this.input.charCodeAt(this.pos);
                                if (i === t) break;
                                92 === i ? (e += this.input.slice(n, this.pos), e += this.readEscapedChar(!1), n = this.pos) : (v(i, this.options.ecmaVersion >= 10) && this.raise(this.start, "Unterminated string constant"), ++this.pos)
                            }
                            return e += this.input.slice(n, this.pos++), this.finishToken(b.string, e)
                        };
                        var Lt = {};
                        kt.tryReadTemplateToken = function() {
                            this.inTemplateElement = !0;
                            try {
                                this.readTmplToken()
                            } catch (t) {
                                if (t !== Lt) throw t;
                                this.readInvalidTemplateToken()
                            }
                            this.inTemplateElement = !1
                        }, kt.invalidStringToken = function(t, e) {
                            if (this.inTemplateElement && this.options.ecmaVersion >= 9) throw Lt;
                            this.raise(t, e)
                        }, kt.readTmplToken = function() {
                            for (var t = "", e = this.pos;;) {
                                this.pos >= this.input.length && this.raise(this.start, "Unterminated template");
                                var n = this.input.charCodeAt(this.pos);
                                if (96 === n || 36 === n && 123 === this.input.charCodeAt(this.pos + 1)) return this.pos !== this.start || this.type !== b.template && this.type !== b.invalidTemplate ? (t += this.input.slice(e, this.pos), this.finishToken(b.template, t)) : 36 === n ? (this.pos += 2, this.finishToken(b.dollarBraceL)) : (++this.pos, this.finishToken(b.backQuote));
                                if (92 === n) t += this.input.slice(e, this.pos), t += this.readEscapedChar(!0), e = this.pos;
                                else if (v(n)) {
                                    switch (t += this.input.slice(e, this.pos), ++this.pos, n) {
                                        case 13:
                                            10 === this.input.charCodeAt(this.pos) && ++this.pos;
                                        case 10:
                                            t += "\n";
                                            break;
                                        default:
                                            t += String.fromCharCode(n)
                                    }
                                    this.options.locations && (++this.curLine, this.lineStart = this.pos), e = this.pos
                                } else ++this.pos
                            }
                        }, kt.readInvalidTemplateToken = function() {
                            for (; this.pos < this.input.length; this.pos++) switch (this.input[this.pos]) {
                                case "\\":
                                    ++this.pos;
                                    break;
                                case "$":
                                    if ("{" !== this.input[this.pos + 1]) break;
                                case "`":
                                    return this.finishToken(b.invalidTemplate, this.input.slice(this.start, this.pos))
                            }
                            this.raise(this.start, "Unterminated template")
                        }, kt.readEscapedChar = function(t) {
                            var e = this.input.charCodeAt(++this.pos);
                            switch (++this.pos, e) {
                                case 110:
                                    return "\n";
                                case 114:
                                    return "\r";
                                case 120:
                                    return String.fromCharCode(this.readHexChar(2));
                                case 117:
                                    return Dt(this.readCodePoint());
                                case 116:
                                    return "\t";
                                case 98:
                                    return "\b";
                                case 118:
                                    return "\v";
                                case 102:
                                    return "\f";
                                case 13:
                                    10 === this.input.charCodeAt(this.pos) && ++this.pos;
                                case 10:
                                    return this.options.locations && (this.lineStart = this.pos, ++this.curLine), "";
                                case 56:
                                case 57:
                                    if (t) {
                                        var n = this.pos - 1;
                                        return this.invalidStringToken(n, "Invalid escape sequence in template string"), null
                                    }
                                    default:
                                        if (e >= 48 && e <= 55) {
                                            var i = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0],
                                                s = parseInt(i, 8);
                                            return s > 255 && (i = i.slice(0, -1), s = parseInt(i, 8)), this.pos += i.length - 1, e = this.input.charCodeAt(this.pos), "0" === i && 56 !== e && 57 !== e || !this.strict && !t || this.invalidStringToken(this.pos - 1 - i.length, t ? "Octal literal in template string" : "Octal literal in strict mode"), String.fromCharCode(s)
                                        }
                                        return v(e) ? "" : String.fromCharCode(e)
                            }
                        }, kt.readHexChar = function(t) {
                            var e = this.pos,
                                n = this.readInt(16, t);
                            return null === n && this.invalidStringToken(e, "Bad character escape sequence"), n
                        }, kt.readWord1 = function() {
                            this.containsEsc = !1;
                            for (var t = "", e = !0, n = this.pos, i = this.options.ecmaVersion >= 6; this.pos < this.input.length;) {
                                var s = this.fullCharCodeAtPos();
                                if (d(s, i)) this.pos += s <= 65535 ? 1 : 2;
                                else {
                                    if (92 !== s) break;
                                    this.containsEsc = !0, t += this.input.slice(n, this.pos);
                                    var r = this.pos;
                                    117 !== this.input.charCodeAt(++this.pos) && this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX"), ++this.pos;
                                    var a = this.readCodePoint();
                                    (e ? p : d)(a, i) || this.invalidStringToken(r, "Invalid Unicode escape"), t += Dt(a), n = this.pos
                                }
                                e = !1
                            }
                            return t + this.input.slice(n, this.pos)
                        }, kt.readWord = function() {
                            var t = this.readWord1(),
                                e = b.name;
                            return this.keywords.test(t) && (e = x[t]), this.finishToken(e, t)
                        };
                        var Ct = "7.1.0";
                        U.acorn = {
                            Parser: U,
                            version: Ct,
                            defaultOptions: N,
                            Position: M,
                            SourceLocation: O,
                            getLineInfo: R,
                            Node: et,
                            TokenType: m,
                            tokTypes: b,
                            keywordTypes: x,
                            TokContext: st,
                            tokContexts: rt,
                            isIdentifierChar: d,
                            isIdentifierStart: p,
                            Token: St,
                            isNewLine: v,
                            lineBreak: w,
                            lineBreakG: T,
                            nonASCIIwhitespace: E
                        }, t.Node = et, t.Parser = U, t.Position = M, t.SourceLocation = O, t.TokContext = st, t.Token = St, t.TokenType = m, t.defaultOptions = N, t.getLineInfo = R, t.isIdentifierChar = d, t.isIdentifierStart = p, t.isNewLine = v, t.keywordTypes = x, t.lineBreak = w, t.lineBreakG = T, t.nonASCIIwhitespace = E, t.parse = function(t, e) {
                            return U.parse(t, e)
                        }, t.parseExpressionAt = function(t, e, n) {
                            return U.parseExpressionAt(t, e, n)
                        }, t.tokContexts = rt, t.tokTypes = b, t.tokenizer = function(t, e) {
                            return U.tokenizer(t, e)
                        }, t.version = Ct, Object.defineProperty(t, "__esModule", {
                            value: !0
                        })
                    }, s("object" == typeof n && void 0 !== e ? n : (i = i || self).acorn = {})
                }, {}],
                2: [function(t, e, n) {}, {}],
                3: [function(t, e, n) {
                    function i(t, e = {}) {
                        const {
                            contextName: n = "gl",
                            throwGetError: i,
                            useTrackablePrimitives: o,
                            readPixelsFile: u,
                            recording: h = [],
                            variables: l = {},
                            onReadPixels: c,
                            onUnrecognizedArgumentLookup: p
                        } = e, d = new Proxy(t, {
                            get: function(e, d) {
                                switch (d) {
                                    case "addComment":
                                        return I;
                                    case "checkThrowError":
                                        return S;
                                    case "getReadPixelsVariableName":
                                        return f;
                                    case "insertVariable":
                                        return w;
                                    case "reset":
                                        return b;
                                    case "setIndent":
                                        return v;
                                    case "toString":
                                        return _;
                                    case "getContextVariableName":
                                        return L
                                }
                                return "function" == typeof t[d] ? function() {
                                    switch (d) {
                                        case "getError":
                                            return i ? h.push(`${x}if (${n}.getError() !== ${n}.NONE) throw new Error('error');`) : h.push(`${x}${n}.getError();`), t.getError();
                                        case "getExtension": {
                                            const e = `${n}Variables${m.length}`;
                                            h.push(`${x}const ${e} = ${n}.getExtension('${arguments[0]}');`);
                                            const i = t.getExtension(arguments[0]);
                                            if (i && "object" == typeof i) {
                                                const t = s(i, {
                                                    getEntity: T,
                                                    useTrackablePrimitives: o,
                                                    recording: h,
                                                    contextName: e,
                                                    contextVariables: m,
                                                    variables: l,
                                                    indent: x,
                                                    onUnrecognizedArgumentLookup: p
                                                });
                                                return m.push(t), t
                                            }
                                            return m.push(null), i
                                        }
                                        case "readPixels":
                                            const e = m.indexOf(arguments[6]);
                                            let a;
                                            if (-1 === e) {
                                                const t = D(arguments[6]);
                                                t ? (a = t, h.push(`${x}${t}`)) : (a = `${n}Variable${m.length}`, m.push(arguments[6]), h.push(`${x}const ${a} = new ${arguments[6].constructor.name}(${arguments[6].length});`))
                                            } else a = `${n}Variable${e}`;
                                            f = a;
                                            const d = [arguments[0], arguments[1], arguments[2], arguments[3], T(arguments[4]), T(arguments[5]), a];
                                            return h.push(`${x}${n}.readPixels(${d.join(", ")});`), u && A(arguments[2], arguments[3]), c && c(a, d), t.readPixels.apply(t, arguments);
                                        case "drawBuffers":
                                            return h.push(`${x}${n}.drawBuffers([${r(arguments[0],{contextName:n,contextVariables:m,getEntity:T,addVariable:E,variables:l,onUnrecognizedArgumentLookup:p})}]);`), t.drawBuffers(arguments[0])
                                    }
                                    let e = t[d].apply(t, arguments);
                                    switch (typeof e) {
                                        case "undefined":
                                            return void h.push(`${x}${k(d,arguments)};`);
                                        case "number":
                                        case "boolean":
                                            if (o && -1 === m.indexOf(a(e))) {
                                                h.push(`${x}const ${n}Variable${m.length} = ${k(d,arguments)};`), m.push(e = a(e));
                                                break
                                            }
                                            default:
                                                null === e ? h.push(`${k(d,arguments)};`) : h.push(`${x}const ${n}Variable${m.length} = ${k(d,arguments)};`), m.push(e)
                                    }
                                    return e
                                } : (g[t[d]] = d, t[d])
                            }
                        }), m = [], g = {};
                        let f, y = 0,
                            x = "";
                        return d;

                        function _() {
                            return h.join("\n")
                        }

                        function b() {
                            for (; h.length > 0;) h.pop()
                        }

                        function w(t, e) {
                            l[t] = e
                        }

                        function T(t) {
                            const e = g[t];
                            return e ? n + "." + e : t
                        }

                        function v(t) {
                            x = " ".repeat(t)
                        }

                        function E(t, e) {
                            const i = `${n}Variable${m.length}`;
                            return h.push(`${x}const ${i} = ${e};`), m.push(t), i
                        }

                        function A(t, e) {
                            const i = `${n}Variable${m.length}`,
                                s = `imageDatum${y}`;
                            h.push(`${x}let ${s} = ["P3\\n# ${u}.ppm\\n", ${t}, ' ', ${e}, "\\n255\\n"].join("");`), h.push(`${x}for (let i = 0; i < ${s}.length; i += 4) {`), h.push(`${x}  ${s} += ${i}[i] + ' ' + ${i}[i + 1] + ' ' + ${i}[i + 2] + ' ';`), h.push(`${x}}`), h.push(`${x}if (typeof require !== "undefined") {`), h.push(`${x}  require('fs').writeFileSync('./${u}.ppm', ${s});`), h.push(`${x}}`), y++
                        }

                        function I(t) {
                            h.push(`${x}// ${t}`)
                        }

                        function S() {
                            h.push(`${x}(() => {\n${x}const error = ${n}.getError();\n${x}if (error !== ${n}.NONE) {\n${x}  const names = Object.getOwnPropertyNames(gl);\n${x}  for (let i = 0; i < names.length; i++) {\n${x}    const name = names[i];\n${x}    if (${n}[name] === error) {\n${x}      throw new Error('${n} threw ' + name);\n${x}    }\n${x}  }\n${x}}\n${x}})();`)
                        }

                        function k(t, e) {
                            return `${n}.${t}(${r(e,{contextName:n,contextVariables:m,getEntity:T,addVariable:E,variables:l,onUnrecognizedArgumentLookup:p})})`
                        }

                        function D(t) {
                            if (l)
                                for (const e in l)
                                    if (l[e] === t) return e;
                            return null
                        }

                        function L(t) {
                            const e = m.indexOf(t);
                            return -1 !== e ? `${n}Variable${e}` : null
                        }
                    }

                    function s(t, e) {
                        const n = new Proxy(t, {
                                get: function(e, n) {
                                    return "function" == typeof e[n] ? function() {
                                        if ("drawBuffersWEBGL" === n) return l.push(`${p}${s}.drawBuffersWEBGL([${r(arguments[0],{contextName:s,contextVariables:o,getEntity:m,addVariable:f,variables:c,onUnrecognizedArgumentLookup:d})}]);`), t.drawBuffersWEBGL(arguments[0]);
                                        let e = t[n].apply(t, arguments);
                                        switch (typeof e) {
                                            case "undefined":
                                                return void l.push(`${p}${g(n,arguments)};`);
                                            case "number":
                                            case "boolean":
                                                h && -1 === o.indexOf(a(e)) ? (l.push(`${p}const ${s}Variable${o.length} = ${g(n,arguments)};`), o.push(e = a(e))) : (l.push(`${p}const ${s}Variable${o.length} = ${g(n,arguments)};`), o.push(e));
                                                break;
                                            default:
                                                null === e ? l.push(`${g(n,arguments)};`) : l.push(`${p}const ${s}Variable${o.length} = ${g(n,arguments)};`), o.push(e)
                                        }
                                        return e
                                    } : (i[t[n]] = n, t[n])
                                }
                            }),
                            i = {},
                            {
                                contextName: s,
                                contextVariables: o,
                                getEntity: u,
                                useTrackablePrimitives: h,
                                recording: l,
                                variables: c,
                                indent: p,
                                onUnrecognizedArgumentLookup: d
                            } = e;
                        return n;

                        function m(t) {
                            return i.hasOwnProperty(t) ? `${s}.${i[t]}` : u(t)
                        }

                        function g(t, e) {
                            return `${s}.${t}(${r(e,{contextName:s,contextVariables:o,getEntity:m,addVariable:f,variables:c,onUnrecognizedArgumentLookup:d})})`
                        }

                        function f(t, e) {
                            const n = `${s}Variable${o.length}`;
                            return o.push(t), l.push(`${p}const ${n} = ${e};`), n
                        }
                    }

                    function r(t, e) {
                        const {
                            variables: n,
                            onUnrecognizedArgumentLookup: i
                        } = e;
                        return Array.from(t).map((t => function(t) {
                            if (n)
                                for (const e in n)
                                    if (n.hasOwnProperty(e) && n[e] === t) return e;
                            return i ? i(t) : null
                        }(t) || function(t, e) {
                            const {
                                contextName: n,
                                contextVariables: i,
                                getEntity: s,
                                addVariable: r,
                                onUnrecognizedArgumentLookup: a
                            } = e;
                            if (void 0 === t) return "undefined";
                            if (null === t) return "null";
                            const o = i.indexOf(t);
                            if (o > -1) return `${n}Variable${o}`;
                            switch (t.constructor.name) {
                                case "String":
                                    const e = /\n/.test(t),
                                        n = /'/.test(t),
                                        i = /"/.test(t);
                                    return e ? "`" + t + "`" : n && !i ? '"' + t + '"' : "'" + t + "'";
                                case "Number":
                                case "Boolean":
                                    return s(t);
                                case "Array":
                                    return r(t, `new ${t.constructor.name}([${Array.from(t).join(",")}])`);
                                case "Float32Array":
                                case "Uint8Array":
                                case "Uint16Array":
                                case "Int32Array":
                                    return r(t, `new ${t.constructor.name}(${JSON.stringify(Array.from(t))})`);
                                default:
                                    if (a) {
                                        const e = a(t);
                                        if (e) return e
                                    }
                                    throw new Error(`unrecognized argument type ${t.constructor.name}`)
                            }
                        }(t, e))).join(", ")
                    }

                    function a(t) {
                        return new t.constructor(t)
                    }
                    void 0 !== e && (e.exports = {
                        glWiretap: i,
                        glExtensionWiretap: s
                    }), "undefined" != typeof window && (i.glExtensionWiretap = s, window.glWiretap = i)
                }, {}],
                4: [function(t, e, n) {
                    function i(t) {
                        const e = new Array(t.length);
                        for (let n = 0; n < t.length; n++) {
                            const i = t[n];
                            i.toArray ? e[n] = i.toArray() : e[n] = i
                        }
                        return e
                    }

                    function s() {
                        const t = i(arguments),
                            e = new Float32Array(this.output.x);
                        for (let n = 0; n < this.output.x; n++) this.thread.x = n, this.thread.y = 0, this.thread.z = 0, e[n] = this._fn.apply(this, t);
                        return e
                    }

                    function r() {
                        const t = i(arguments),
                            e = new Array(this.output.y);
                        for (let n = 0; n < this.output.y; n++) {
                            const i = new Float32Array(this.output.x);
                            for (let e = 0; e < this.output.x; e++) this.thread.x = e, this.thread.y = n, this.thread.z = 0, i[e] = this._fn.apply(this, t);
                            e[n] = i
                        }
                        return e
                    }

                    function a() {
                        const t = i(arguments);
                        for (let e = 0; e < this.output.y; e++)
                            for (let n = 0; n < this.output.x; n++) this.thread.x = n, this.thread.y = e, this.thread.z = 0, this._fn.apply(this, t)
                    }

                    function o() {
                        const t = i(arguments),
                            e = new Array(this.output.z);
                        for (let n = 0; n < this.output.z; n++) {
                            const i = new Array(this.output.y);
                            for (let e = 0; e < this.output.y; e++) {
                                const s = new Float32Array(this.output.x);
                                for (let i = 0; i < this.output.x; i++) this.thread.x = i, this.thread.y = e, this.thread.z = n, s[i] = this._fn.apply(this, t);
                                i[e] = s
                            }
                            e[n] = i
                        }
                        return e
                    }

                    function u(t) {
                        t.setOutput = e => {
                            t.output = l(e), t.graphical && h(t)
                        }, t.toJSON = () => {
                            throw new Error("Not usable with gpuMock")
                        }, t.setConstants = e => (t.constants = e, t), t.setGraphical = e => (t.graphical = e, t), t.setCanvas = e => (t.canvas = e, t), t.setContext = e => (t.context = e, t), t.destroy = () => {}, t.validateSettings = () => {}, t.graphical && t.output && h(t), t.exec = function() {
                            return new Promise(((e, n) => {
                                try {
                                    e(t.apply(t, arguments))
                                } catch (t) {
                                    n(t)
                                }
                            }))
                        }, t.getPixels = e => {
                            const {
                                x: n,
                                y: i
                            } = t.output;
                            return e ? function(t, e, n) {
                                const i = n / 2 | 0,
                                    s = 4 * e,
                                    r = new Uint8ClampedArray(4 * e),
                                    a = t.slice(0);
                                for (let t = 0; t < i; ++t) {
                                    const e = t * s,
                                        i = (n - t - 1) * s;
                                    r.set(a.subarray(e, e + s)), a.copyWithin(e, i, i + s), a.set(r, i)
                                }
                                return a
                            }(t._imageData.data, n, i) : t._imageData.data.slice(0)
                        }, t.color = function(e, n, i, s) {
                            void 0 === s && (s = 1), e = Math.floor(255 * e), n = Math.floor(255 * n), i = Math.floor(255 * i), s = Math.floor(255 * s);
                            const r = t.output.x,
                                a = t.output.y,
                                o = t.thread.x + (a - t.thread.y - 1) * r;
                            t._colorData[4 * o + 0] = e, t._colorData[4 * o + 1] = n, t._colorData[4 * o + 2] = i, t._colorData[4 * o + 3] = s
                        };
                        const e = () => t,
                            n = ["setWarnVarUsage", "setArgumentTypes", "setTactic", "setOptimizeFloatMemory", "setDebug", "setLoopMaxIterations", "setConstantTypes", "setFunctions", "setNativeFunctions", "setInjectedNative", "setPipeline", "setPrecision", "setOutputToTexture", "setImmutable", "setStrictIntegers", "setDynamicOutput", "setHardcodeConstants", "setDynamicArguments", "setUseLegacyEncoder", "setWarnVarUsage", "addSubKernel"];
                        for (let i = 0; i < n.length; i++) t[n[i]] = e;
                        return t
                    }

                    function h(t) {
                        const {
                            x: e,
                            y: n
                        } = t.output;
                        if (t.context && t.context.createImageData) {
                            const i = new Uint8ClampedArray(e * n * 4);
                            t._imageData = t.context.createImageData(e, n), t._colorData = i
                        } else {
                            const i = new Uint8ClampedArray(e * n * 4);
                            t._imageData = {
                                data: i
                            }, t._colorData = i
                        }
                    }

                    function l(t) {
                        let e = null;
                        if (t.length)
                            if (3 === t.length) {
                                const [n, i, s] = t;
                                e = {
                                    x: n,
                                    y: i,
                                    z: s
                                }
                            } else if (2 === t.length) {
                            const [n, i] = t;
                            e = {
                                x: n,
                                y: i
                            }
                        } else {
                            const [n] = t;
                            e = {
                                x: n
                            }
                        } else e = t;
                        return e
                    }
                    e.exports = {
                        gpuMock: function(t, e = {}) {
                            const n = e.output ? l(e.output) : null;

                            function i() {
                                return i.output.z ? o.apply(i, arguments) : i.output.y ? i.graphical ? a.apply(i, arguments) : r.apply(i, arguments) : s.apply(i, arguments)
                            }
                            return i._fn = t, i.constants = e.constants || null, i.context = e.context || null, i.canvas = e.canvas || null, i.graphical = e.graphical || !1, i._imageData = null, i._colorData = null, i.output = n, i.thread = {
                                x: 0,
                                y: 0,
                                z: 0
                            }, u(i)
                        }
                    }
                }, {}],
                5: [function(t, e, n) {
                    const {
                        utils: i
                    } = t("./utils");
                    e.exports = {
                        alias: function(t, e) {
                            const n = e.toString();
                            return new Function(`return function ${t} (${i.getArgumentNamesFromString(n).join(", ")}) {\n  ${i.getFunctionBodyFromString(n)}\n}`)()
                        }
                    }
                }, {
                    "./utils": 114
                }],
                6: [function(t, e, n) {
                    const {
                        FunctionNode: i
                    } = t("../function-node");
                    e.exports = {
                        CPUFunctionNode: class extends i {
                            astFunction(t, e) {
                                if (!this.isRootKernel) {
                                    e.push("function"), e.push(" "), e.push(this.name), e.push("(");
                                    for (let t = 0; t < this.argumentNames.length; ++t) {
                                        const n = this.argumentNames[t];
                                        t > 0 && e.push(", "), e.push("user_"), e.push(n)
                                    }
                                    e.push(") {\n")
                                }
                                for (let n = 0; n < t.body.body.length; ++n) this.astGeneric(t.body.body[n], e), e.push("\n");
                                return this.isRootKernel || e.push("}\n"), e
                            }
                            astReturnStatement(t, e) {
                                const n = this.returnType || this.getType(t.argument);
                                return this.returnType || (this.returnType = n), this.isRootKernel ? (e.push(this.leadingReturnStatement), this.astGeneric(t.argument, e), e.push(";\n"), e.push(this.followingReturnStatement), e.push("continue;\n")) : this.isSubKernel ? (e.push(`subKernelResult_${this.name} = `), this.astGeneric(t.argument, e), e.push(";"), e.push(`return subKernelResult_${this.name};`)) : (e.push("return "), this.astGeneric(t.argument, e), e.push(";")), e
                            }
                            astLiteral(t, e) {
                                if (isNaN(t.value)) throw this.astErrorOutput("Non-numeric literal not supported : " + t.value, t);
                                return e.push(t.value), e
                            }
                            astBinaryExpression(t, e) {
                                return e.push("("), this.astGeneric(t.left, e), e.push(t.operator), this.astGeneric(t.right, e), e.push(")"), e
                            }
                            astIdentifierExpression(t, e) {
                                if ("Identifier" !== t.type) throw this.astErrorOutput("IdentifierExpression - not an Identifier", t);
                                return "Infinity" === t.name ? e.push("Infinity") : this.constants && this.constants.hasOwnProperty(t.name) ? e.push("constants_" + t.name) : e.push("user_" + t.name), e
                            }
                            astForStatement(t, e) {
                                if ("ForStatement" !== t.type) throw this.astErrorOutput("Invalid for statement", t);
                                const n = [],
                                    i = [],
                                    s = [],
                                    r = [];
                                let a = null;
                                if (t.init) {
                                    this.pushState("in-for-loop-init"), this.astGeneric(t.init, n);
                                    for (let t = 0; t < n.length; t++) n[t].includes && n[t].includes(",") && (a = !1);
                                    this.popState("in-for-loop-init")
                                } else a = !1;
                                if (t.test ? this.astGeneric(t.test, i) : a = !1, t.update ? this.astGeneric(t.update, s) : a = !1, t.body && (this.pushState("loop-body"), this.astGeneric(t.body, r), this.popState("loop-body")), null === a && (a = this.isSafe(t.init) && this.isSafe(t.test)), a) e.push(`for (${n.join("")};${i.join("")};${s.join("")}){\n`), e.push(r.join("")), e.push("}\n");
                                else {
                                    const t = this.getInternalVariableName("safeI");
                                    n.length > 0 && e.push(n.join(""), ";\n"), e.push(`for (let ${t}=0;${t}<LOOP_MAX;${t}++){\n`), i.length > 0 && e.push(`if (!${i.join("")}) break;\n`), e.push(r.join("")), e.push(`\n${s.join("")};`), e.push("}\n")
                                }
                                return e
                            }
                            astWhileStatement(t, e) {
                                if ("WhileStatement" !== t.type) throw this.astErrorOutput("Invalid while statement", t);
                                return e.push("for (let i = 0; i < LOOP_MAX; i++) {"), e.push("if ("), this.astGeneric(t.test, e), e.push(") {\n"), this.astGeneric(t.body, e), e.push("} else {\n"), e.push("break;\n"), e.push("}\n"), e.push("}\n"), e
                            }
                            astDoWhileStatement(t, e) {
                                if ("DoWhileStatement" !== t.type) throw this.astErrorOutput("Invalid while statement", t);
                                return e.push("for (let i = 0; i < LOOP_MAX; i++) {"), this.astGeneric(t.body, e), e.push("if (!"), this.astGeneric(t.test, e), e.push(") {\n"), e.push("break;\n"), e.push("}\n"), e.push("}\n"), e
                            }
                            astAssignmentExpression(t, e) {
                                const n = this.getDeclaration(t.left);
                                if (n && !n.assignable) throw this.astErrorOutput(`Variable ${t.left.name} is not assignable here`, t);
                                return this.astGeneric(t.left, e), e.push(t.operator), this.astGeneric(t.right, e), e
                            }
                            astBlockStatement(t, e) {
                                if (this.isState("loop-body")) {
                                    this.pushState("block-body");
                                    for (let n = 0; n < t.body.length; n++) this.astGeneric(t.body[n], e);
                                    this.popState("block-body")
                                } else {
                                    e.push("{\n");
                                    for (let n = 0; n < t.body.length; n++) this.astGeneric(t.body[n], e);
                                    e.push("}\n")
                                }
                                return e
                            }
                            astVariableDeclaration(t, e) {
                                e.push(`${t.kind} `);
                                const {
                                    declarations: n
                                } = t;
                                for (let t = 0; t < n.length; t++) {
                                    t > 0 && e.push(",");
                                    const i = n[t],
                                        s = this.getDeclaration(i.id);
                                    s.valueType || (s.valueType = this.getType(i.init)), this.astGeneric(i, e)
                                }
                                return this.isState("in-for-loop-init") || e.push(";"), e
                            }
                            astIfStatement(t, e) {
                                return e.push("if ("), this.astGeneric(t.test, e), e.push(")"), "BlockStatement" === t.consequent.type ? this.astGeneric(t.consequent, e) : (e.push(" {\n"), this.astGeneric(t.consequent, e), e.push("\n}\n")), t.alternate && (e.push("else "), "BlockStatement" === t.alternate.type || "IfStatement" === t.alternate.type ? this.astGeneric(t.alternate, e) : (e.push(" {\n"), this.astGeneric(t.alternate, e), e.push("\n}\n"))), e
                            }
                            astSwitchStatement(t, e) {
                                const {
                                    discriminant: n,
                                    cases: i
                                } = t;
                                e.push("switch ("), this.astGeneric(n, e), e.push(") {\n");
                                for (let t = 0; t < i.length; t++) null !== i[t].test ? (e.push("case "), this.astGeneric(i[t].test, e), e.push(":\n"), i[t].consequent && i[t].consequent.length > 0 && (this.astGeneric(i[t].consequent, e), e.push("break;\n"))) : (e.push("default:\n"), this.astGeneric(i[t].consequent, e), i[t].consequent && i[t].consequent.length > 0 && e.push("break;\n"));
                                e.push("\n}")
                            }
                            astThisExpression(t, e) {
                                return e.push("_this"), e
                            }
                            astMemberExpression(t, e) {
                                const {
                                    signature: n,
                                    type: i,
                                    property: s,
                                    xProperty: r,
                                    yProperty: a,
                                    zProperty: o,
                                    name: u,
                                    origin: h
                                } = this.getMemberExpressionDetails(t);
                                switch (n) {
                                    case "this.thread.value":
                                        return e.push(`_this.thread.${u}`), e;
                                    case "this.output.value":
                                        switch (u) {
                                            case "x":
                                                e.push("outputX");
                                                break;
                                            case "y":
                                                e.push("outputY");
                                                break;
                                            case "z":
                                                e.push("outputZ");
                                                break;
                                            default:
                                                throw this.astErrorOutput("Unexpected expression", t)
                                        }
                                        return e;
                                    case "value":
                                    default:
                                        throw this.astErrorOutput("Unexpected expression", t);
                                    case "value[]":
                                    case "value[][]":
                                    case "value[][][]":
                                    case "value.value":
                                        if ("Math" === h) return e.push(Math[u]), e;
                                        switch (s) {
                                            case "r":
                                                return e.push(`user_${u}[0]`), e;
                                            case "g":
                                                return e.push(`user_${u}[1]`), e;
                                            case "b":
                                                return e.push(`user_${u}[2]`), e;
                                            case "a":
                                                return e.push(`user_${u}[3]`), e
                                        }
                                        break;
                                    case "this.constants.value":
                                    case "this.constants.value[]":
                                    case "this.constants.value[][]":
                                    case "this.constants.value[][][]":
                                        break;
                                    case "fn()[]":
                                        return this.astGeneric(t.object, e), e.push("["), this.astGeneric(t.property, e), e.push("]"), e;
                                    case "fn()[][]":
                                        return this.astGeneric(t.object.object, e), e.push("["), this.astGeneric(t.object.property, e), e.push("]"), e.push("["), this.astGeneric(t.property, e), e.push("]"), e
                                }
                                if (!t.computed) switch (i) {
                                    case "Number":
                                    case "Integer":
                                    case "Float":
                                    case "Boolean":
                                        return e.push(`${h}_${u}`), e
                                }
                                const l = `${h}_${u}`; {
                                    let t, n;
                                    if ("constants" === h) {
                                        const e = this.constants[u];
                                        n = "Input" === this.constantTypes[u], t = n ? e.size : null
                                    } else n = this.isInput(u), t = n ? this.argumentSizes[this.argumentNames.indexOf(u)] : null;
                                    e.push(`${l}`), o && a ? n ? (e.push("[("), this.astGeneric(o, e), e.push(`*${this.dynamicArguments?"(outputY * outputX)":t[1]*t[0]})+(`), this.astGeneric(a, e), e.push(`*${this.dynamicArguments?"outputX":t[0]})+`), this.astGeneric(r, e), e.push("]")) : (e.push("["), this.astGeneric(o, e), e.push("]"), e.push("["), this.astGeneric(a, e), e.push("]"), e.push("["), this.astGeneric(r, e), e.push("]")) : a ? n ? (e.push("[("), this.astGeneric(a, e), e.push(`*${this.dynamicArguments?"outputX":t[0]})+`), this.astGeneric(r, e), e.push("]")) : (e.push("["), this.astGeneric(a, e), e.push("]"), e.push("["), this.astGeneric(r, e), e.push("]")) : void 0 !== r && (e.push("["), this.astGeneric(r, e), e.push("]"))
                                }
                                return e
                            }
                            astCallExpression(t, e) {
                                if ("CallExpression" !== t.type) throw this.astErrorOutput("Unknown CallExpression", t);
                                let n = this.astMemberExpressionUnroll(t.callee);
                                this.calledFunctions.indexOf(n) < 0 && this.calledFunctions.push(n), this.isAstMathFunction(t), this.onFunctionCall && this.onFunctionCall(this.name, n, t.arguments), e.push(n), e.push("(");
                                const i = this.lookupFunctionArgumentTypes(n) || [];
                                for (let s = 0; s < t.arguments.length; ++s) {
                                    const r = t.arguments[s];
                                    let a = this.getType(r);
                                    i[s] || this.triggerImplyArgumentType(n, s, a, this), s > 0 && e.push(", "), this.astGeneric(r, e)
                                }
                                return e.push(")"), e
                            }
                            astArrayExpression(t, e) {
                                const n = this.getType(t),
                                    i = t.elements.length,
                                    s = [];
                                for (let e = 0; e < i; ++e) {
                                    const n = [];
                                    this.astGeneric(t.elements[e], n), s.push(n.join(""))
                                }
                                switch (n) {
                                    case "Matrix(2)":
                                    case "Matrix(3)":
                                    case "Matrix(4)":
                                        e.push(`[${s.join(", ")}]`);
                                        break;
                                    default:
                                        e.push(`new Float32Array([${s.join(", ")}])`)
                                }
                                return e
                            }
                            astDebuggerStatement(t, e) {
                                return e.push("debugger;"), e
                            }
                        }
                    }
                }, {
                    "../function-node": 10
                }],
                7: [function(t, e, n) {
                    const {
                        utils: i
                    } = t("../../utils");
                    e.exports = {
                        cpuKernelString: function(t, e) {
                            const n = [],
                                s = [],
                                r = [],
                                a = !/^function/.test(t.color.toString());
                            if (n.push("  const { context, canvas, constants: incomingConstants } = settings;", `  const output = new Int32Array(${JSON.stringify(Array.from(t.output))});`, `  const _constantTypes = ${JSON.stringify(t.constantTypes)};`, `  const _constants = ${function(t,e){const n=[];for(const i in e){if(!e.hasOwnProperty(i))continue;const s=e[i],r=t[i];switch(s){case"Number":case"Integer":case"Float":case"Boolean":n.push(`${i}:${r}`);break;case"Array(2)":case"Array(3)":case"Array(4)":case"Matrix(2)":case"Matrix(3)":case"Matrix(4)":n.push(`${i}:new ${r.constructor.name}(${JSON.stringify(Array.from(r))})`)}}return` {
                                        $ {
                                            n.join()
                                        }
                                    }
                                    `}(t.constants,t.constantTypes)};`), s.push("    constants: _constants,", "    context,", "    output,", "    thread: {x: 0, y: 0, z: 0},"), t.graphical) {
                                n.push(`  const _imageData = context.createImageData(${t.output[0]}, ${t.output[1]});`), n.push(`  const _colorData = new Uint8ClampedArray(${t.output[0]} * ${t.output[1]} * 4);`);
                                const e = i.flattenFunctionToString((a ? "function " : "") + t.color.toString(), {
                                        thisLookup: e => {
                                            switch (e) {
                                                case "_colorData":
                                                    return "_colorData";
                                                case "_imageData":
                                                    return "_imageData";
                                                case "output":
                                                    return "output";
                                                case "thread":
                                                    return "this.thread"
                                            }
                                            return JSON.stringify(t[e])
                                        },
                                        findDependency: (t, e) => null
                                    }),
                                    o = i.flattenFunctionToString((a ? "function " : "") + t.getPixels.toString(), {
                                        thisLookup: e => {
                                            switch (e) {
                                                case "_colorData":
                                                    return "_colorData";
                                                case "_imageData":
                                                    return "_imageData";
                                                case "output":
                                                    return "output";
                                                case "thread":
                                                    return "this.thread"
                                            }
                                            return JSON.stringify(t[e])
                                        },
                                        findDependency: () => null
                                    });
                                s.push("    _imageData,", "    _colorData,", `    color: ${e},`), r.push(`  kernel.getPixels = ${o};`)
                            }
                            const o = [],
                                u = Object.keys(t.constantTypes);
                            for (let e = 0; e < u.length; e++) o.push(t.constantTypes[u]);
                            if (-1 !== t.argumentTypes.indexOf("HTMLImageArray") || -1 !== o.indexOf("HTMLImageArray")) {
                                const e = i.flattenFunctionToString((a ? "function " : "") + t._imageTo3DArray.toString(), {
                                    doNotDefine: ["canvas"],
                                    findDependency: (e, n) => "this" === e ? (a ? "function " : "") + t[n].toString() : null,
                                    thisLookup: t => {
                                        switch (t) {
                                            case "canvas":
                                                return;
                                            case "context":
                                                return "context"
                                        }
                                    }
                                });
                                r.push(e), s.push("    _mediaTo2DArray,"), s.push("    _imageTo3DArray,")
                            } else if (-1 !== t.argumentTypes.indexOf("HTMLImage") || -1 !== o.indexOf("HTMLImage")) {
                                const e = i.flattenFunctionToString((a ? "function " : "") + t._mediaTo2DArray.toString(), {
                                    findDependency: (t, e) => null,
                                    thisLookup: t => {
                                        switch (t) {
                                            case "canvas":
                                                return "settings.canvas";
                                            case "context":
                                                return "settings.context"
                                        }
                                        throw new Error("unhandled thisLookup")
                                    }
                                });
                                r.push(e), s.push("    _mediaTo2DArray,")
                            }
                            return `function(settings) {\n${n.join("\n")}\n  for (const p in _constantTypes) {\n    if (!_constantTypes.hasOwnProperty(p)) continue;\n    const type = _constantTypes[p];\n    switch (type) {\n      case 'Number':\n      case 'Integer':\n      case 'Float':\n      case 'Boolean':\n      case 'Array(2)':\n      case 'Array(3)':\n      case 'Array(4)':\n      case 'Matrix(2)':\n      case 'Matrix(3)':\n      case 'Matrix(4)':\n        if (incomingConstants.hasOwnProperty(p)) {\n          console.warn('constant ' + p + ' of type ' + type + ' cannot be resigned');\n        }\n        continue;\n    }\n    if (!incomingConstants.hasOwnProperty(p)) {\n      throw new Error('constant ' + p + ' not found');\n    }\n    _constants[p] = incomingConstants[p];\n  }\n  const kernel = (function() {\n${t._kernelString}\n  })\n    .apply({ ${s.join("\n")} });\n  ${r.join("\n")}\n  return kernel;\n}`
                        }
                    }
                }, {
                    "../../utils": 114
                }],
                8: [function(t, e, n) {
                    const {
                        Kernel: i
                    } = t("../kernel"), {
                        FunctionBuilder: s
                    } = t("../function-builder"), {
                        CPUFunctionNode: r
                    } = t("./function-node"), {
                        utils: a
                    } = t("../../utils"), {
                        cpuKernelString: o
                    } = t("./kernel-string");
                    e.exports = {
                        CPUKernel: class extends i {
                            static getFeatures() {
                                return this.features
                            }
                            static get features() {
                                return Object.freeze({
                                    kernelMap: !0,
                                    isIntegerDivisionAccurate: !0
                                })
                            }
                            static get isSupported() {
                                return !0
                            }
                            static isContextMatch(t) {
                                return !1
                            }
                            static get mode() {
                                return "cpu"
                            }
                            static nativeFunctionArguments() {
                                return null
                            }
                            static nativeFunctionReturnType() {
                                throw new Error(`Looking up native function return type not supported on ${this.name}`)
                            }
                            static combineKernels(t) {
                                return t
                            }
                            static getSignature(t, e) {
                                return "cpu" + (e.length > 0 ? ":" + e.join(",") : "")
                            }
                            constructor(t, e) {
                                super(t, e), this.mergeSettings(t.settings || e), this._imageData = null, this._colorData = null, this._kernelString = null, this._prependedString = [], this.thread = {
                                    x: 0,
                                    y: 0,
                                    z: 0
                                }, this.translatedSources = null
                            }
                            initCanvas() {
                                return "undefined" != typeof document ? document.createElement("canvas") : "undefined" != typeof OffscreenCanvas ? new OffscreenCanvas(0, 0) : void 0
                            }
                            initContext() {
                                return this.canvas ? this.canvas.getContext("2d") : null
                            }
                            initPlugins(t) {
                                return []
                            }
                            validateSettings(t) {
                                if (!this.output || 0 === this.output.length) {
                                    if (1 !== t.length) throw new Error("Auto output only supported for kernels with only one input");
                                    const e = a.getVariableType(t[0], this.strictIntegers);
                                    if ("Array" === e) this.output = a.getDimensions(e);
                                    else {
                                        if ("NumberTexture" !== e && "ArrayTexture(4)" !== e) throw new Error("Auto output not supported for input type: " + e);
                                        this.output = t[0].output
                                    }
                                }
                                if (this.graphical && 2 !== this.output.length) throw new Error("Output must have 2 dimensions on graphical mode");
                                this.checkOutput()
                            }
                            translateSource() {
                                if (this.leadingReturnStatement = this.output.length > 1 ? "resultX[x] = " : "result[x] = ", this.subKernels) {
                                    const t = [];
                                    for (let e = 0; e < this.subKernels.length; e++) {
                                        const {
                                            name: n
                                        } = this.subKernels[e];
                                        t.push(this.output.length > 1 ? `resultX_${n}[x] = subKernelResult_${n};\n` : `result_${n}[x] = subKernelResult_${n};\n`)
                                    }
                                    this.followingReturnStatement = t.join("")
                                }
                                const t = s.fromKernel(this, r);
                                this.translatedSources = t.getPrototypes("kernel"), this.graphical || this.returnType || (this.returnType = t.getKernelResultType())
                            }
                            build() {
                                if (this.built) return;
                                if (this.setupConstants(), this.setupArguments(arguments), this.validateSettings(arguments), this.translateSource(), this.graphical) {
                                    const {
                                        canvas: t,
                                        output: e
                                    } = this;
                                    if (!t) throw new Error("no canvas available for using graphical output");
                                    const n = e[0],
                                        i = e[1] || 1;
                                    t.width = n, t.height = i, this._imageData = this.context.createImageData(n, i), this._colorData = new Uint8ClampedArray(n * i * 4)
                                }
                                const t = this.getKernelString();
                                this.kernelString = t, this.debug && (console.log("Function output:"), console.log(t));
                                try {
                                    this.run = new Function([], t).bind(this)()
                                } catch (t) {
                                    console.error("An error occurred compiling the javascript: ", t)
                                }
                                this.buildSignature(arguments), this.built = !0
                            }
                            color(t, e, n, i) {
                                void 0 === i && (i = 1), t = Math.floor(255 * t), e = Math.floor(255 * e), n = Math.floor(255 * n), i = Math.floor(255 * i);
                                const s = this.output[0],
                                    r = this.output[1],
                                    a = this.thread.x + (r - this.thread.y - 1) * s;
                                this._colorData[4 * a + 0] = t, this._colorData[4 * a + 1] = e, this._colorData[4 * a + 2] = n, this._colorData[4 * a + 3] = i
                            }
                            getKernelString() {
                                if (null !== this._kernelString) return this._kernelString;
                                let t = null,
                                    {
                                        translatedSources: e
                                    } = this;
                                return e.length > 1 ? e = e.filter((e => /^function/.test(e) ? e : (t = e, !1))) : t = e.shift(), this._kernelString = `  const LOOP_MAX = ${this._getLoopMaxString()};\n  ${this.injectedNative||""}\n  const _this = this;\n  ${this._resultKernelHeader()}\n  ${this._processConstants()}\n  return (${this.argumentNames.map((t=>"user_"+t)).join(", ")}) => {\n    ${this._prependedString.join("")}\n    ${this._earlyThrows()}\n    ${this._processArguments()}\n    ${this.graphical?this._graphicalKernelBody(t):this._resultKernelBody(t)}\n    ${e.length>0?e.join("\n"):""}\n  };`
                            }
                            toString() {
                                return o(this)
                            }
                            _getLoopMaxString() {
                                return this.loopMaxIterations ? ` ${parseInt(this.loopMaxIterations)};` : " 1000;"
                            }
                            _processConstants() {
                                if (!this.constants) return "";
                                const t = [];
                                for (let e in this.constants) switch (this.constantTypes[e]) {
                                    case "HTMLCanvas":
                                    case "OffscreenCanvas":
                                    case "HTMLImage":
                                    case "ImageBitmap":
                                    case "ImageData":
                                    case "HTMLVideo":
                                        t.push(`    const constants_${e} = this._mediaTo2DArray(this.constants.${e});\n`);
                                        break;
                                    case "HTMLImageArray":
                                        t.push(`    const constants_${e} = this._imageTo3DArray(this.constants.${e});\n`);
                                        break;
                                    case "Input":
                                        t.push(`    const constants_${e} = this.constants.${e}.value;\n`);
                                        break;
                                    default:
                                        t.push(`    const constants_${e} = this.constants.${e};\n`)
                                }
                                return t.join("")
                            }
                            _earlyThrows() {
                                if (this.graphical) return "";
                                if (this.immutable) return "";
                                if (!this.pipeline) return "";
                                const t = [];
                                for (let e = 0; e < this.argumentTypes.length; e++) "Array" === this.argumentTypes[e] && t.push(this.argumentNames[e]);
                                if (0 === t.length) return "";
                                const e = [];
                                for (let n = 0; n < t.length; n++) {
                                    const i = t[n],
                                        s = this._mapSubKernels((t => `user_${i} === result_${t.name}`)).join(" || ");
                                    e.push(`user_${i} === result${s?` || ${s}`:""}`)
                                }
                                return `if (${e.join(" || ")}) throw new Error('Source and destination arrays are the same.  Use immutable = true');`
                            }
                            _processArguments() {
                                const t = [];
                                for (let e = 0; e < this.argumentTypes.length; e++) {
                                    const n = `user_${this.argumentNames[e]}`;
                                    switch (this.argumentTypes[e]) {
                                        case "HTMLCanvas":
                                        case "OffscreenCanvas":
                                        case "HTMLImage":
                                        case "ImageBitmap":
                                        case "ImageData":
                                        case "HTMLVideo":
                                            t.push(`    ${n} = this._mediaTo2DArray(${n});\n`);
                                            break;
                                        case "HTMLImageArray":
                                            t.push(`    ${n} = this._imageTo3DArray(${n});\n`);
                                            break;
                                        case "Input":
                                            t.push(`    ${n} = ${n}.value;\n`);
                                            break;
                                        case "ArrayTexture(1)":
                                        case "ArrayTexture(2)":
                                        case "ArrayTexture(3)":
                                        case "ArrayTexture(4)":
                                        case "NumberTexture":
                                        case "MemoryOptimizedNumberTexture":
                                            t.push(`\n    if (${n}.toArray) {\n      if (!_this.textureCache) {\n        _this.textureCache = [];\n        _this.arrayCache = [];\n      }\n      const textureIndex = _this.textureCache.indexOf(${n});\n      if (textureIndex !== -1) {\n        ${n} = _this.arrayCache[textureIndex];\n      } else {\n        _this.textureCache.push(${n});\n        ${n} = ${n}.toArray();\n        _this.arrayCache.push(${n});\n      }\n    }`)
                                    }
                                }
                                return t.join("")
                            }
                            _mediaTo2DArray(t) {
                                const e = this.canvas,
                                    n = t.width > 0 ? t.width : t.videoWidth,
                                    i = t.height > 0 ? t.height : t.videoHeight;
                                e.width < n && (e.width = n), e.height < i && (e.height = i);
                                const s = this.context;
                                let r;
                                t.constructor === ImageData ? r = t.data : (s.drawImage(t, 0, 0, n, i), r = s.getImageData(0, 0, n, i).data);
                                const a = new Array(i);
                                let o = 0;
                                for (let t = i - 1; t >= 0; t--) {
                                    const e = a[t] = new Array(n);
                                    for (let t = 0; t < n; t++) {
                                        const n = new Float32Array(4);
                                        n[0] = r[o++] / 255, n[1] = r[o++] / 255, n[2] = r[o++] / 255, n[3] = r[o++] / 255, e[t] = n
                                    }
                                }
                                return a
                            }
                            getPixels(t) {
                                const [e, n] = this.output;
                                return t ? a.flipPixels(this._imageData.data, e, n) : this._imageData.data.slice(0)
                            }
                            _imageTo3DArray(t) {
                                const e = new Array(t.length);
                                for (let n = 0; n < t.length; n++) e[n] = this._mediaTo2DArray(t[n]);
                                return e
                            }
                            _resultKernelHeader() {
                                if (this.graphical) return "";
                                if (this.immutable) return "";
                                if (!this.pipeline) return "";
                                switch (this.output.length) {
                                    case 1:
                                        return this._mutableKernel1DResults();
                                    case 2:
                                        return this._mutableKernel2DResults();
                                    case 3:
                                        return this._mutableKernel3DResults()
                                }
                            }
                            _resultKernelBody(t) {
                                switch (this.output.length) {
                                    case 1:
                                        return (!this.immutable && this.pipeline ? this._resultMutableKernel1DLoop(t) : this._resultImmutableKernel1DLoop(t)) + this._kernelOutput();
                                    case 2:
                                        return (!this.immutable && this.pipeline ? this._resultMutableKernel2DLoop(t) : this._resultImmutableKernel2DLoop(t)) + this._kernelOutput();
                                    case 3:
                                        return (!this.immutable && this.pipeline ? this._resultMutableKernel3DLoop(t) : this._resultImmutableKernel3DLoop(t)) + this._kernelOutput();
                                    default:
                                        throw new Error("unsupported size kernel")
                                }
                            }
                            _graphicalKernelBody(t) {
                                if (2 === this.output.length) return this._graphicalKernel2DLoop(t) + this._graphicalOutput();
                                throw new Error("unsupported size kernel")
                            }
                            _graphicalOutput() {
                                return "\n    this._imageData.data.set(this._colorData);\n    this.context.putImageData(this._imageData, 0, 0);\n    return;"
                            }
                            _getKernelResultTypeConstructorString() {
                                switch (this.returnType) {
                                    case "LiteralInteger":
                                    case "Number":
                                    case "Integer":
                                    case "Float":
                                        return "Float32Array";
                                    case "Array(2)":
                                    case "Array(3)":
                                    case "Array(4)":
                                        return "Array";
                                    default:
                                        if (this.graphical) return "Float32Array";
                                        throw new Error(`unhandled returnType ${this.returnType}`)
                                }
                            }
                            _resultImmutableKernel1DLoop(t) {
                                const e = this._getKernelResultTypeConstructorString();
                                return `  const outputX = _this.output[0];\n    const result = new ${e}(outputX);\n    ${this._mapSubKernels((t=>`const result_${t.name} = new ${e}(outputX);\n`)).join("    ")}\n    ${this._mapSubKernels((t=>`let subKernelResult_${t.name};\n`)).join("    ")}\n    for (let x = 0; x < outputX; x++) {\n      this.thread.x = x;\n      this.thread.y = 0;\n      this.thread.z = 0;\n      ${t}\n    }`
                            }
                            _mutableKernel1DResults() {
                                const t = this._getKernelResultTypeConstructorString();
                                return `  const outputX = _this.output[0];\n    const result = new ${t}(outputX);\n    ${this._mapSubKernels((e=>`const result_${e.name} = new ${t}(outputX);\n`)).join("    ")}\n    ${this._mapSubKernels((t=>`let subKernelResult_${t.name};\n`)).join("    ")}`
                            }
                            _resultMutableKernel1DLoop(t) {
                                return `  const outputX = _this.output[0];\n    for (let x = 0; x < outputX; x++) {\n      this.thread.x = x;\n      this.thread.y = 0;\n      this.thread.z = 0;\n      ${t}\n    }`
                            }
                            _resultImmutableKernel2DLoop(t) {
                                const e = this._getKernelResultTypeConstructorString();
                                return `  const outputX = _this.output[0];\n    const outputY = _this.output[1];\n    const result = new Array(outputY);\n    ${this._mapSubKernels((t=>`const result_${t.name} = new Array(outputY);\n`)).join("    ")}\n    ${this._mapSubKernels((t=>`let subKernelResult_${t.name};\n`)).join("    ")}\n    for (let y = 0; y < outputY; y++) {\n      this.thread.z = 0;\n      this.thread.y = y;\n      const resultX = result[y] = new ${e}(outputX);\n      ${this._mapSubKernels((t=>`const resultX_${t.name} = result_${t.name}[y] = new ${e}(outputX);\n`)).join("")}\n      for (let x = 0; x < outputX; x++) {\n        this.thread.x = x;\n        ${t}\n      }\n    }`
                            }
                            _mutableKernel2DResults() {
                                const t = this._getKernelResultTypeConstructorString();
                                return `  const outputX = _this.output[0];\n    const outputY = _this.output[1];\n    const result = new Array(outputY);\n    ${this._mapSubKernels((t=>`const result_${t.name} = new Array(outputY);\n`)).join("    ")}\n    ${this._mapSubKernels((t=>`let subKernelResult_${t.name};\n`)).join("    ")}\n    for (let y = 0; y < outputY; y++) {\n      const resultX = result[y] = new ${t}(outputX);\n      ${this._mapSubKernels((e=>`const resultX_${e.name} = result_${e.name}[y] = new ${t}(outputX);\n`)).join("")}\n    }`
                            }
                            _resultMutableKernel2DLoop(t) {
                                const e = this._getKernelResultTypeConstructorString();
                                return `  const outputX = _this.output[0];\n    const outputY = _this.output[1];\n    for (let y = 0; y < outputY; y++) {\n      this.thread.z = 0;\n      this.thread.y = y;\n      const resultX = result[y];\n      ${this._mapSubKernels((t=>`const resultX_${t.name} = result_${t.name}[y] = new ${e}(outputX);\n`)).join("")}\n      for (let x = 0; x < outputX; x++) {\n        this.thread.x = x;\n        ${t}\n      }\n    }`
                            }
                            _graphicalKernel2DLoop(t) {
                                return `  const outputX = _this.output[0];\n    const outputY = _this.output[1];\n    for (let y = 0; y < outputY; y++) {\n      this.thread.z = 0;\n      this.thread.y = y;\n      for (let x = 0; x < outputX; x++) {\n        this.thread.x = x;\n        ${t}\n      }\n    }`
                            }
                            _resultImmutableKernel3DLoop(t) {
                                const e = this._getKernelResultTypeConstructorString();
                                return `  const outputX = _this.output[0];\n    const outputY = _this.output[1];\n    const outputZ = _this.output[2];\n    const result = new Array(outputZ);\n    ${this._mapSubKernels((t=>`const result_${t.name} = new Array(outputZ);\n`)).join("    ")}\n    ${this._mapSubKernels((t=>`let subKernelResult_${t.name};\n`)).join("    ")}\n    for (let z = 0; z < outputZ; z++) {\n      this.thread.z = z;\n      const resultY = result[z] = new Array(outputY);\n      ${this._mapSubKernels((t=>`const resultY_${t.name} = result_${t.name}[z] = new Array(outputY);\n`)).join("      ")}\n      for (let y = 0; y < outputY; y++) {\n        this.thread.y = y;\n        const resultX = resultY[y] = new ${e}(outputX);\n        ${this._mapSubKernels((t=>`const resultX_${t.name} = resultY_${t.name}[y] = new ${e}(outputX);\n`)).join("        ")}\n        for (let x = 0; x < outputX; x++) {\n          this.thread.x = x;\n          ${t}\n        }\n      }\n    }`
                            }
                            _mutableKernel3DResults() {
                                const t = this._getKernelResultTypeConstructorString();
                                return `  const outputX = _this.output[0];\n    const outputY = _this.output[1];\n    const outputZ = _this.output[2];\n    const result = new Array(outputZ);\n    ${this._mapSubKernels((t=>`const result_${t.name} = new Array(outputZ);\n`)).join("    ")}\n    ${this._mapSubKernels((t=>`let subKernelResult_${t.name};\n`)).join("    ")}\n    for (let z = 0; z < outputZ; z++) {\n      const resultY = result[z] = new Array(outputY);\n      ${this._mapSubKernels((t=>`const resultY_${t.name} = result_${t.name}[z] = new Array(outputY);\n`)).join("      ")}\n      for (let y = 0; y < outputY; y++) {\n        const resultX = resultY[y] = new ${t}(outputX);\n        ${this._mapSubKernels((e=>`const resultX_${e.name} = resultY_${e.name}[y] = new ${t}(outputX);\n`)).join("        ")}\n      }\n    }`
                            }
                            _resultMutableKernel3DLoop(t) {
                                return `  const outputX = _this.output[0];\n    const outputY = _this.output[1];\n    const outputZ = _this.output[2];\n    for (let z = 0; z < outputZ; z++) {\n      this.thread.z = z;\n      const resultY = result[z];\n      for (let y = 0; y < outputY; y++) {\n        this.thread.y = y;\n        const resultX = resultY[y];\n        for (let x = 0; x < outputX; x++) {\n          this.thread.x = x;\n          ${t}\n        }\n      }\n    }`
                            }
                            _kernelOutput() {
                                return this.subKernels ? `\n    return {\n      result: result,\n      ${this.subKernels.map((t=>`${t.property}: result_${t.name}`)).join(",\n      ")}\n    };` : "\n    return result;"
                            }
                            _mapSubKernels(t) {
                                return null === this.subKernels ? [""] : this.subKernels.map(t)
                            }
                            destroy(t) {
                                t && delete this.canvas
                            }
                            static destroyContext(t) {}
                            toJSON() {
                                const t = super.toJSON();
                                return t.functionNodes = s.fromKernel(this, r).toJSON(), t
                            }
                            setOutput(t) {
                                super.setOutput(t);
                                const [e, n] = this.output;
                                this.graphical && (this._imageData = this.context.createImageData(e, n), this._colorData = new Uint8ClampedArray(e * n * 4))
                            }
                            prependString(t) {
                                if (this._kernelString) throw new Error("Kernel already built");
                                this._prependedString.push(t)
                            }
                            hasPrependString(t) {
                                return this._prependedString.indexOf(t) > -1
                            }
                        }
                    }
                }, {
                    "../../utils": 114,
                    "../function-builder": 9,
                    "../kernel": 36,
                    "./function-node": 6,
                    "./kernel-string": 7
                }],
                9: [function(t, e, n) {
                    class i {
                        static fromKernel(t, e, n) {
                            const {
                                kernelArguments: s,
                                kernelConstants: r,
                                argumentNames: a,
                                argumentSizes: o,
                                argumentBitRatios: u,
                                constants: h,
                                constantBitRatios: l,
                                debug: c,
                                loopMaxIterations: p,
                                nativeFunctions: d,
                                output: m,
                                optimizeFloatMemory: g,
                                precision: f,
                                plugins: y,
                                source: x,
                                subKernels: _,
                                functions: b,
                                leadingReturnStatement: w,
                                followingReturnStatement: T,
                                dynamicArguments: v,
                                dynamicOutput: E
                            } = t, A = new Array(s.length), I = {};
                            for (let t = 0; t < s.length; t++) A[t] = s[t].type;
                            for (let t = 0; t < r.length; t++) {
                                const e = r[t];
                                I[e.name] = e.type
                            }
                            const S = (t, e) => V.needsArgumentType(t, e),
                                k = (t, e, n) => {
                                    V.assignArgumentType(t, e, n)
                                },
                                D = (t, e, n) => V.lookupReturnType(t, e, n),
                                L = t => V.lookupFunctionArgumentTypes(t),
                                C = (t, e) => V.lookupFunctionArgumentName(t, e),
                                M = (t, e) => V.lookupFunctionArgumentBitRatio(t, e),
                                O = (t, e, n, i) => {
                                    V.assignArgumentType(t, e, n, i)
                                },
                                R = (t, e, n, i) => {
                                    V.assignArgumentBitRatio(t, e, n, i)
                                },
                                N = (t, e, n) => {
                                    V.trackFunctionCall(t, e, n)
                                },
                                P = (t, n) => {
                                    const i = [];
                                    for (let e = 0; e < t.params.length; e++) i.push(t.params[e].name);
                                    const s = new e(n, Object.assign({}, $, {
                                        returnType: null,
                                        ast: t,
                                        name: t.id.name,
                                        argumentNames: i,
                                        lookupReturnType: D,
                                        lookupFunctionArgumentTypes: L,
                                        lookupFunctionArgumentName: C,
                                        lookupFunctionArgumentBitRatio: M,
                                        needsArgumentType: S,
                                        assignArgumentType: k,
                                        triggerImplyArgumentType: O,
                                        triggerImplyArgumentBitRatio: R,
                                        onFunctionCall: N
                                    }));
                                    s.traceFunctionAST(t), V.addFunctionNode(s)
                                },
                                $ = Object.assign({
                                    isRootKernel: !1,
                                    onNestedFunction: P,
                                    lookupReturnType: D,
                                    lookupFunctionArgumentTypes: L,
                                    lookupFunctionArgumentName: C,
                                    lookupFunctionArgumentBitRatio: M,
                                    needsArgumentType: S,
                                    assignArgumentType: k,
                                    triggerImplyArgumentType: O,
                                    triggerImplyArgumentBitRatio: R,
                                    onFunctionCall: N,
                                    optimizeFloatMemory: g,
                                    precision: f,
                                    constants: h,
                                    constantTypes: I,
                                    constantBitRatios: l,
                                    debug: c,
                                    loopMaxIterations: p,
                                    output: m,
                                    plugins: y,
                                    dynamicArguments: v,
                                    dynamicOutput: E
                                }, n || {}),
                                U = Object.assign({}, $, {
                                    isRootKernel: !0,
                                    name: "kernel",
                                    argumentNames: a,
                                    argumentTypes: A,
                                    argumentSizes: o,
                                    argumentBitRatios: u,
                                    leadingReturnStatement: w,
                                    followingReturnStatement: T
                                });
                            if ("object" == typeof x && x.functionNodes) return (new i).fromJSON(x.functionNodes, e);
                            const F = new e(x, U);
                            let B = null;
                            b && (B = b.map((t => new e(t.source, {
                                returnType: t.returnType,
                                argumentTypes: t.argumentTypes,
                                output: m,
                                plugins: y,
                                constants: h,
                                constantTypes: I,
                                constantBitRatios: l,
                                optimizeFloatMemory: g,
                                precision: f,
                                lookupReturnType: D,
                                lookupFunctionArgumentTypes: L,
                                lookupFunctionArgumentName: C,
                                lookupFunctionArgumentBitRatio: M,
                                needsArgumentType: S,
                                assignArgumentType: k,
                                triggerImplyArgumentType: O,
                                triggerImplyArgumentBitRatio: R,
                                onFunctionCall: N,
                                onNestedFunction: P
                            }))));
                            let z = null;
                            _ && (z = _.map((t => {
                                const {
                                    name: n,
                                    source: i
                                } = t;
                                return new e(i, Object.assign({}, $, {
                                    name: n,
                                    isSubKernel: !0,
                                    isRootKernel: !1
                                }))
                            })));
                            const V = new i({
                                kernel: t,
                                rootNode: F,
                                functionNodes: B,
                                nativeFunctions: d,
                                subKernelNodes: z
                            });
                            return V
                        }
                        constructor(t) {
                            if (t = t || {}, this.kernel = t.kernel, this.rootNode = t.rootNode, this.functionNodes = t.functionNodes || [], this.subKernelNodes = t.subKernelNodes || [], this.nativeFunctions = t.nativeFunctions || [], this.functionMap = {}, this.nativeFunctionNames = [], this.lookupChain = [], this.functionNodeDependencies = {}, this.functionCalls = {}, this.rootNode && (this.functionMap.kernel = this.rootNode), this.functionNodes)
                                for (let t = 0; t < this.functionNodes.length; t++) this.functionMap[this.functionNodes[t].name] = this.functionNodes[t];
                            if (this.subKernelNodes)
                                for (let t = 0; t < this.subKernelNodes.length; t++) this.functionMap[this.subKernelNodes[t].name] = this.subKernelNodes[t];
                            if (this.nativeFunctions)
                                for (let t = 0; t < this.nativeFunctions.length; t++) {
                                    const e = this.nativeFunctions[t];
                                    this.nativeFunctionNames.push(e.name)
                                }
                        }
                        addFunctionNode(t) {
                            if (!t.name) throw new Error("functionNode.name needs set");
                            this.functionMap[t.name] = t, t.isRootKernel && (this.rootNode = t)
                        }
                        traceFunctionCalls(t, e) {
                            if (t = t || "kernel", e = e || [], this.nativeFunctionNames.indexOf(t) > -1) {
                                const n = e.indexOf(t);
                                if (-1 === n) e.push(t);
                                else {
                                    const t = e.splice(n, 1)[0];
                                    e.push(t)
                                }
                                return e
                            }
                            const n = this.functionMap[t];
                            if (n) {
                                const i = e.indexOf(t);
                                if (-1 === i) {
                                    e.push(t), n.toString();
                                    for (let t = 0; t < n.calledFunctions.length; ++t) this.traceFunctionCalls(n.calledFunctions[t], e)
                                } else {
                                    const t = e.splice(i, 1)[0];
                                    e.push(t)
                                }
                            }
                            return e
                        }
                        getPrototypeString(t) {
                            return this.getPrototypes(t).join("\n")
                        }
                        getPrototypes(t) {
                            return this.rootNode && this.rootNode.toString(), t ? this.getPrototypesFromFunctionNames(this.traceFunctionCalls(t, []).reverse()) : this.getPrototypesFromFunctionNames(Object.keys(this.functionMap))
                        }
                        getStringFromFunctionNames(t) {
                            const e = [];
                            for (let n = 0; n < t.length; ++n) this.functionMap[t[n]] && e.push(this.functionMap[t[n]].toString());
                            return e.join("\n")
                        }
                        getPrototypesFromFunctionNames(t) {
                            const e = [];
                            for (let n = 0; n < t.length; ++n) {
                                const i = t[n],
                                    s = this.nativeFunctionNames.indexOf(i);
                                if (s > -1) {
                                    e.push(this.nativeFunctions[s].source);
                                    continue
                                }
                                const r = this.functionMap[i];
                                r && e.push(r.toString())
                            }
                            return e
                        }
                        toJSON() {
                            return this.traceFunctionCalls(this.rootNode.name).reverse().map((t => {
                                const e = this.nativeFunctions.indexOf(t);
                                if (e > -1) return {
                                    name: t,
                                    source: this.nativeFunctions[e].source
                                };
                                if (this.functionMap[t]) return this.functionMap[t].toJSON();
                                throw new Error(`function ${t} not found`)
                            }))
                        }
                        fromJSON(t, e) {
                            this.functionMap = {};
                            for (let n = 0; n < t.length; n++) {
                                const i = t[n];
                                this.functionMap[i.settings.name] = new e(i.ast, i.settings)
                            }
                            return this
                        }
                        getString(t) {
                            return t ? this.getStringFromFunctionNames(this.traceFunctionCalls(t).reverse()) : this.getStringFromFunctionNames(Object.keys(this.functionMap))
                        }
                        lookupReturnType(t, e, n) {
                            if ("CallExpression" !== e.type) throw new Error(`expected ast type of "CallExpression", but is ${e.type}`);
                            if (this._isNativeFunction(t)) return this._lookupNativeFunctionReturnType(t);
                            if (this._isFunction(t)) {
                                const i = this._getFunction(t);
                                if (i.returnType) return i.returnType; {
                                    for (let t = 0; t < this.lookupChain.length; t++)
                                        if (this.lookupChain[t].ast === e) {
                                            if (0 === i.argumentTypes.length && e.arguments.length > 0) {
                                                const s = e.arguments;
                                                for (let e = 0; e < s.length; e++) this.lookupChain.push({
                                                    name: n.name,
                                                    ast: s[t],
                                                    requestingNode: n
                                                }), i.argumentTypes[e] = n.getType(s[e]), this.lookupChain.pop();
                                                return i.returnType = i.getType(i.getJsAST())
                                            }
                                            throw new Error("circlical logic detected!")
                                        } this.lookupChain.push({
                                        name: n.name,
                                        ast: e,
                                        requestingNode: n
                                    });
                                    const t = i.getType(i.getJsAST());
                                    return this.lookupChain.pop(), i.returnType = t
                                }
                            }
                            return null
                        }
                        _getFunction(t) {
                            return this._isFunction(t) || new Error(`Function ${t} not found`), this.functionMap[t]
                        }
                        _isFunction(t) {
                            return Boolean(this.functionMap[t])
                        }
                        _getNativeFunction(t) {
                            for (let e = 0; e < this.nativeFunctions.length; e++)
                                if (this.nativeFunctions[e].name === t) return this.nativeFunctions[e];
                            return null
                        }
                        _isNativeFunction(t) {
                            return Boolean(this._getNativeFunction(t))
                        }
                        _lookupNativeFunctionReturnType(t) {
                            let e = this._getNativeFunction(t);
                            if (e) return e.returnType;
                            throw new Error(`Native function ${t} not found`)
                        }
                        lookupFunctionArgumentTypes(t) {
                            return this._isNativeFunction(t) ? this._getNativeFunction(t).argumentTypes : this._isFunction(t) ? this._getFunction(t).argumentTypes : null
                        }
                        lookupFunctionArgumentName(t, e) {
                            return this._getFunction(t).argumentNames[e]
                        }
                        lookupFunctionArgumentBitRatio(t, e) {
                            if (!this._isFunction(t)) throw new Error("function not found");
                            if (this.rootNode.name === t) {
                                const t = this.rootNode.argumentNames.indexOf(e);
                                if (-1 !== t) return this.rootNode.argumentBitRatios[t]
                            }
                            const n = this._getFunction(t),
                                i = n.argumentNames.indexOf(e);
                            if (-1 === i) throw new Error("argument not found");
                            const s = n.argumentBitRatios[i];
                            if ("number" != typeof s) throw new Error("argument bit ratio not found");
                            return s
                        }
                        needsArgumentType(t, e) {
                            return !!this._isFunction(t) && !this._getFunction(t).argumentTypes[e]
                        }
                        assignArgumentType(t, e, n, i) {
                            if (!this._isFunction(t)) return;
                            const s = this._getFunction(t);
                            s.argumentTypes[e] || (s.argumentTypes[e] = n)
                        }
                        assignArgumentBitRatio(t, e, n, i) {
                            const s = this._getFunction(t);
                            if (this._isNativeFunction(n)) return null;
                            const r = this._getFunction(n),
                                a = s.argumentNames.indexOf(e);
                            if (-1 === a) throw new Error(`Argument ${e} not found in arguments from function ${t}`);
                            const o = s.argumentBitRatios[a];
                            if ("number" != typeof o) throw new Error(`Bit ratio for argument ${e} not found in function ${t}`);
                            r.argumentBitRatios || (r.argumentBitRatios = new Array(r.argumentNames.length));
                            const u = r.argumentBitRatios[a];
                            if ("number" == typeof u) {
                                if (u !== o) throw new Error(`Incompatible bit ratio found at function ${t} at argument ${e}`);
                                return u
                            }
                            return r.argumentBitRatios[a] = o, o
                        }
                        trackFunctionCall(t, e, n) {
                            this.functionNodeDependencies[t] || (this.functionNodeDependencies[t] = new Set, this.functionCalls[t] = []), this.functionNodeDependencies[t].add(e), this.functionCalls[t].push(n)
                        }
                        getKernelResultType() {
                            return this.rootNode.returnType || this.rootNode.getType(this.rootNode.ast)
                        }
                        getSubKernelResultType(t) {
                            const e = this.subKernelNodes[t];
                            let n = !1;
                            for (let t = 0; t < this.rootNode.functionCalls.length; t++) this.rootNode.functionCalls[t].ast.callee.name === e.name && (n = !0);
                            if (!n) throw new Error(`SubKernel ${e.name} never called by kernel`);
                            return e.returnType || e.getType(e.getJsAST())
                        }
                        getReturnTypes() {
                            const t = {
                                    [this.rootNode.name]: this.rootNode.getType(this.rootNode.ast)
                                },
                                e = this.traceFunctionCalls(this.rootNode.name);
                            for (let n = 0; n < e.length; n++) {
                                const i = e[n],
                                    s = this.functionMap[i];
                                t[i] = s.getType(s.ast)
                            }
                            return t
                        }
                    }
                    e.exports = {
                        FunctionBuilder: i
                    }
                }, {}],
                10: [function(t, e, n) {
                    const i = t("acorn"),
                        {
                            utils: s
                        } = t("../utils"),
                        {
                            FunctionTracer: r
                        } = t("./function-tracer");
                    const a = {
                        Number: "Number",
                        Float: "Float",
                        Integer: "Integer",
                        Array: "Number",
                        "Array(2)": "Number",
                        "Array(3)": "Number",
                        "Array(4)": "Number",
                        "Matrix(2)": "Number",
                        "Matrix(3)": "Number",
                        "Matrix(4)": "Number",
                        Array2D: "Number",
                        Array3D: "Number",
                        Input: "Number",
                        HTMLCanvas: "Array(4)",
                        OffscreenCanvas: "Array(4)",
                        HTMLImage: "Array(4)",
                        ImageBitmap: "Array(4)",
                        ImageData: "Array(4)",
                        HTMLVideo: "Array(4)",
                        HTMLImageArray: "Array(4)",
                        NumberTexture: "Number",
                        MemoryOptimizedNumberTexture: "Number",
                        "Array1D(2)": "Array(2)",
                        "Array1D(3)": "Array(3)",
                        "Array1D(4)": "Array(4)",
                        "Array2D(2)": "Array(2)",
                        "Array2D(3)": "Array(3)",
                        "Array2D(4)": "Array(4)",
                        "Array3D(2)": "Array(2)",
                        "Array3D(3)": "Array(3)",
                        "Array3D(4)": "Array(4)",
                        "ArrayTexture(1)": "Number",
                        "ArrayTexture(2)": "Array(2)",
                        "ArrayTexture(3)": "Array(3)",
                        "ArrayTexture(4)": "Array(4)"
                    };
                    e.exports = {
                        FunctionNode: class {
                            constructor(t, e) {
                                if (!t && !e.ast) throw new Error("source parameter is missing");
                                if (e = e || {}, this.source = t, this.ast = null, this.name = "string" == typeof t ? e.isRootKernel ? "kernel" : e.name || s.getFunctionNameFromString(t) : null, this.calledFunctions = [], this.constants = {}, this.constantTypes = {}, this.constantBitRatios = {}, this.isRootKernel = !1, this.isSubKernel = !1, this.debug = null, this.functions = null, this.identifiers = null, this.contexts = null, this.functionCalls = null, this.states = [], this.needsArgumentType = null, this.assignArgumentType = null, this.lookupReturnType = null, this.lookupFunctionArgumentTypes = null, this.lookupFunctionArgumentBitRatio = null, this.triggerImplyArgumentType = null, this.triggerImplyArgumentBitRatio = null, this.onNestedFunction = null, this.onFunctionCall = null, this.optimizeFloatMemory = null, this.precision = null, this.loopMaxIterations = null, this.argumentNames = "string" == typeof this.source ? s.getArgumentNamesFromString(this.source) : null, this.argumentTypes = [], this.argumentSizes = [], this.argumentBitRatios = null, this.returnType = null, this.output = [], this.plugins = null, this.leadingReturnStatement = null, this.followingReturnStatement = null, this.dynamicOutput = null, this.dynamicArguments = null, this.strictTypingChecking = !1, this.fixIntegerDivisionAccuracy = null, e)
                                    for (const t in e) e.hasOwnProperty(t) && this.hasOwnProperty(t) && (this[t] = e[t]);
                                this.literalTypes = {}, this.validate(), this._string = null, this._internalVariableNames = {}
                            }
                            validate() {
                                if ("string" != typeof this.source && !this.ast) throw new Error("this.source not a string");
                                if (!this.ast && !s.isFunctionString(this.source)) throw new Error("this.source not a function string");
                                if (!this.name) throw new Error("this.name could not be set");
                                if (this.argumentTypes.length > 0 && this.argumentTypes.length !== this.argumentNames.length) throw new Error(`argumentTypes count of ${this.argumentTypes.length} exceeds ${this.argumentNames.length}`);
                                if (this.output.length < 1) throw new Error("this.output is not big enough")
                            }
                            isIdentifierConstant(t) {
                                return !!this.constants && this.constants.hasOwnProperty(t)
                            }
                            isInput(t) {
                                return "Input" === this.argumentTypes[this.argumentNames.indexOf(t)]
                            }
                            pushState(t) {
                                this.states.push(t)
                            }
                            popState(t) {
                                if (this.state !== t) throw new Error(`Cannot popState ${t} when in ${this.state}`);
                                this.states.pop()
                            }
                            isState(t) {
                                return this.state === t
                            }
                            get state() {
                                return this.states[this.states.length - 1]
                            }
                            astMemberExpressionUnroll(t) {
                                if ("Identifier" === t.type) return t.name;
                                if ("ThisExpression" === t.type) return "this";
                                if ("MemberExpression" === t.type && t.object && t.property) return t.object.hasOwnProperty("name") && "Math" !== t.object.name ? this.astMemberExpressionUnroll(t.property) : this.astMemberExpressionUnroll(t.object) + "." + this.astMemberExpressionUnroll(t.property);
                                if (t.hasOwnProperty("expressions")) {
                                    const e = t.expressions[0];
                                    if ("Literal" === e.type && 0 === e.value && 2 === t.expressions.length) return this.astMemberExpressionUnroll(t.expressions[1])
                                }
                                throw this.astErrorOutput("Unknown astMemberExpressionUnroll", t)
                            }
                            getJsAST(t) {
                                if (this.ast) return this.ast;
                                if ("object" == typeof this.source) return this.traceFunctionAST(this.source), this.ast = this.source;
                                if (null === (t = t || i)) throw new Error("Missing JS to AST parser");
                                const e = Object.freeze(t.parse(`const parser_${this.name} = ${this.source};`, {
                                        locations: !0
                                    })),
                                    n = e.body[0].declarations[0].init;
                                if (this.traceFunctionAST(n), !e) throw new Error("Failed to parse JS code");
                                return this.ast = n
                            }
                            traceFunctionAST(t) {
                                const {
                                    contexts: e,
                                    declarations: n,
                                    functions: i,
                                    identifiers: s,
                                    functionCalls: a
                                } = new r(t);
                                this.contexts = e, this.identifiers = s, this.functionCalls = a, this.functions = i;
                                for (let t = 0; t < n.length; t++) {
                                    const e = n[t],
                                        {
                                            ast: i,
                                            inForLoopInit: s,
                                            inForLoopTest: r
                                        } = e,
                                        {
                                            init: a
                                        } = i,
                                        o = this.getDependencies(a);
                                    let u = null;
                                    if (s && r) u = "Integer";
                                    else if (a) {
                                        const t = this.getType(a);
                                        switch (t) {
                                            case "Integer":
                                            case "Float":
                                            case "Number":
                                                u = "MemberExpression" === a.type ? t : "Number";
                                                break;
                                            case "LiteralInteger":
                                                u = "Number";
                                                break;
                                            default:
                                                u = t
                                        }
                                    }
                                    e.valueType = u, e.dependencies = o, e.isSafe = this.isSafeDependencies(o)
                                }
                                for (let t = 0; t < i.length; t++) this.onNestedFunction(i[t], this.source)
                            }
                            getDeclaration(t) {
                                for (let e = 0; e < this.identifiers.length; e++) {
                                    const n = this.identifiers[e];
                                    if (t === n.ast) return n.declaration
                                }
                                return null
                            }
                            getVariableType(t) {
                                if ("Identifier" !== t.type) throw new Error(`ast of ${t.type} not "Identifier"`);
                                let e = null;
                                const n = this.argumentNames.indexOf(t.name);
                                if (-1 === n) {
                                    const e = this.getDeclaration(t);
                                    if (e) return e.valueType
                                } else {
                                    const t = this.argumentTypes[n];
                                    t && (e = t)
                                }
                                if (!e && this.strictTypingChecking) throw new Error(`Declaration of ${name} not found`);
                                return e
                            }
                            getLookupType(t) {
                                if (!a.hasOwnProperty(t)) throw new Error(`unknown typeLookupMap ${t}`);
                                return a[t]
                            }
                            getConstantType(t) {
                                if (this.constantTypes[t]) {
                                    const e = this.constantTypes[t];
                                    return "Float" === e ? "Number" : e
                                }
                                throw new Error(`Type for constant "${t}" not declared`)
                            }
                            toString() {
                                return this._string ? this._string : this._string = this.astGeneric(this.getJsAST(), []).join("").trim()
                            }
                            toJSON() {
                                const t = {
                                    source: this.source,
                                    name: this.name,
                                    constants: this.constants,
                                    constantTypes: this.constantTypes,
                                    isRootKernel: this.isRootKernel,
                                    isSubKernel: this.isSubKernel,
                                    debug: this.debug,
                                    output: this.output,
                                    loopMaxIterations: this.loopMaxIterations,
                                    argumentNames: this.argumentNames,
                                    argumentTypes: this.argumentTypes,
                                    argumentSizes: this.argumentSizes,
                                    returnType: this.returnType,
                                    leadingReturnStatement: this.leadingReturnStatement,
                                    followingReturnStatement: this.followingReturnStatement
                                };
                                return {
                                    ast: this.ast,
                                    settings: t
                                }
                            }
                            getType(t) {
                                if (Array.isArray(t)) return this.getType(t[t.length - 1]);
                                switch (t.type) {
                                    case "BlockStatement":
                                        return this.getType(t.body);
                                    case "ArrayExpression":
                                        switch (this.getType(t.elements[0])) {
                                            case "Array(2)":
                                            case "Array(3)":
                                            case "Array(4)":
                                                return `Matrix(${t.elements.length})`
                                        }
                                        return `Array(${t.elements.length})`;
                                    case "Literal":
                                        const e = this.astKey(t);
                                        return this.literalTypes[e] ? this.literalTypes[e] : Number.isInteger(t.value) ? "LiteralInteger" : !0 === t.value || !1 === t.value ? "Boolean" : "Number";
                                    case "AssignmentExpression":
                                        return this.getType(t.left);
                                    case "CallExpression":
                                        if (this.isAstMathFunction(t)) return "Number";
                                        if (!t.callee || !t.callee.name) {
                                            if ("SequenceExpression" === t.callee.type && t.callee.expressions[t.callee.expressions.length - 1].property.name) {
                                                const e = t.callee.expressions[t.callee.expressions.length - 1].property.name;
                                                return this.inferArgumentTypesIfNeeded(e, t.arguments), this.lookupReturnType(e, t, this)
                                            }
                                            if ("this.color" === this.getVariableSignature(t.callee, !0)) return null;
                                            if ("MemberExpression" === t.callee.type && t.callee.object && t.callee.property && t.callee.property.name && t.arguments) {
                                                const e = t.callee.property.name;
                                                return this.inferArgumentTypesIfNeeded(e, t.arguments), this.lookupReturnType(e, t, this)
                                            }
                                            throw this.astErrorOutput("Unknown call expression", t)
                                        }
                                        if (t.callee && t.callee.name) {
                                            const e = t.callee.name;
                                            return this.inferArgumentTypesIfNeeded(e, t.arguments), this.lookupReturnType(e, t, this)
                                        }
                                        throw this.astErrorOutput(`Unhandled getType Type "${t.type}"`, t);
                                    case "LogicalExpression":
                                        return "Boolean";
                                    case "BinaryExpression":
                                        switch (t.operator) {
                                            case "%":
                                            case "/":
                                                if (this.fixIntegerDivisionAccuracy) return "Number";
                                                break;
                                            case ">":
                                            case "<":
                                                return "Boolean";
                                            case "&":
                                            case "|":
                                            case "^":
                                            case "<<":
                                            case ">>":
                                            case ">>>":
                                                return "Integer"
                                        }
                                        const n = this.getType(t.left);
                                        if (this.isState("skip-literal-correction")) return n;
                                        if ("LiteralInteger" === n) {
                                            const e = this.getType(t.right);
                                            return "LiteralInteger" === e ? t.left.value % 1 == 0 ? "Integer" : "Float" : e
                                        }
                                        return a[n] || n;
                                    case "UpdateExpression":
                                    case "ReturnStatement":
                                        return this.getType(t.argument);
                                    case "UnaryExpression":
                                        return "~" === t.operator ? "Integer" : this.getType(t.argument);
                                    case "VariableDeclaration": {
                                        const e = t.declarations;
                                        let n;
                                        for (let t = 0; t < e.length; t++) {
                                            const i = e[t];
                                            n = this.getType(i)
                                        }
                                        if (!n) throw this.astErrorOutput("Unable to find type for declaration", t);
                                        return n
                                    }
                                    case "VariableDeclarator":
                                        const i = this.getDeclaration(t.id);
                                        if (!i) throw this.astErrorOutput("Unable to find declarator", t);
                                        if (!i.valueType) throw this.astErrorOutput("Unable to find declarator valueType", t);
                                        return i.valueType;
                                    case "Identifier":
                                        if ("Infinity" === t.name) return "Number";
                                        if (this.isAstVariable(t) && "value" === this.getVariableSignature(t)) return this.getCheckVariableType(t);
                                        const s = this.findIdentifierOrigin(t);
                                        return s && s.init ? this.getType(s.init) : null;
                                    case "MemberExpression":
                                        if (this.isAstMathFunction(t)) {
                                            switch (t.property.name) {
                                                case "ceil":
                                                case "floor":
                                                case "round":
                                                    return "Integer"
                                            }
                                            return "Number"
                                        }
                                        if (this.isAstVariable(t)) {
                                            switch (this.getVariableSignature(t)) {
                                                case "value[]":
                                                    return this.getLookupType(this.getCheckVariableType(t.object));
                                                case "value[][]":
                                                    return this.getLookupType(this.getCheckVariableType(t.object.object));
                                                case "value[][][]":
                                                    return this.getLookupType(this.getCheckVariableType(t.object.object.object));
                                                case "value[][][][]":
                                                    return this.getLookupType(this.getCheckVariableType(t.object.object.object.object));
                                                case "value.thread.value":
                                                case "this.thread.value":
                                                    return "Integer";
                                                case "this.output.value":
                                                    return this.dynamicOutput ? "Integer" : "LiteralInteger";
                                                case "this.constants.value":
                                                    return this.getConstantType(t.property.name);
                                                case "this.constants.value[]":
                                                    return this.getLookupType(this.getConstantType(t.object.property.name));
                                                case "this.constants.value[][]":
                                                    return this.getLookupType(this.getConstantType(t.object.object.property.name));
                                                case "this.constants.value[][][]":
                                                    return this.getLookupType(this.getConstantType(t.object.object.object.property.name));
                                                case "this.constants.value[][][][]":
                                                    return this.getLookupType(this.getConstantType(t.object.object.object.object.property.name));
                                                case "fn()[]":
                                                case "fn()[][]":
                                                case "fn()[][][]":
                                                    return this.getLookupType(this.getType(t.object));
                                                case "value.value":
                                                    if (this.isAstMathVariable(t)) return "Number";
                                                    switch (t.property.name) {
                                                        case "r":
                                                        case "g":
                                                        case "b":
                                                        case "a":
                                                            return this.getLookupType(this.getCheckVariableType(t.object))
                                                    }
                                                    case "[][]":
                                                        return "Number"
                                            }
                                            throw this.astErrorOutput("Unhandled getType MemberExpression", t)
                                        }
                                        throw this.astErrorOutput("Unhandled getType MemberExpression", t);
                                    case "ConditionalExpression":
                                    case "IfStatement":
                                        return this.getType(t.consequent);
                                    case "FunctionDeclaration":
                                    case "FunctionExpression":
                                        const r = this.findLastReturn(t.body);
                                        return r ? this.getType(r) : null;
                                    case "SequenceExpression":
                                        return this.getType(t.expressions[t.expressions.length - 1]);
                                    default:
                                        throw this.astErrorOutput(`Unhandled getType Type "${t.type}"`, t)
                                }
                            }
                            getCheckVariableType(t) {
                                const e = this.getVariableType(t);
                                if (!e) throw this.astErrorOutput(`${t.type} is not defined`, t);
                                return e
                            }
                            inferArgumentTypesIfNeeded(t, e) {
                                for (let n = 0; n < e.length; n++) {
                                    if (!this.needsArgumentType(t, n)) continue;
                                    const i = this.getType(e[n]);
                                    if (!i) throw this.astErrorOutput(`Unable to infer argument ${n}`, e[n]);
                                    this.assignArgumentType(t, n, i)
                                }
                            }
                            isAstMathVariable(t) {
                                return "MemberExpression" === t.type && t.object && "Identifier" === t.object.type && "Math" === t.object.name && t.property && "Identifier" === t.property.type && ["E", "PI", "SQRT2", "SQRT1_2", "LN2", "LN10", "LOG2E", "LOG10E"].indexOf(t.property.name) > -1
                            }
                            isAstMathFunction(t) {
                                return "CallExpression" === t.type && t.callee && "MemberExpression" === t.callee.type && t.callee.object && "Identifier" === t.callee.object.type && "Math" === t.callee.object.name && t.callee.property && "Identifier" === t.callee.property.type && ["abs", "acos", "acosh", "asin", "asinh", "atan", "atan2", "atanh", "cbrt", "ceil", "clz32", "cos", "cosh", "expm1", "exp", "floor", "fround", "imul", "log", "log2", "log10", "log1p", "max", "min", "pow", "random", "round", "sign", "sin", "sinh", "sqrt", "tan", "tanh", "trunc"].indexOf(t.callee.property.name) > -1
                            }
                            isAstVariable(t) {
                                return "Identifier" === t.type || "MemberExpression" === t.type
                            }
                            isSafe(t) {
                                return this.isSafeDependencies(this.getDependencies(t))
                            }
                            isSafeDependencies(t) {
                                return !t || !t.every || t.every((t => t.isSafe))
                            }
                            getDependencies(t, e, n) {
                                if (e || (e = []), !t) return null;
                                if (Array.isArray(t)) {
                                    for (let i = 0; i < t.length; i++) this.getDependencies(t[i], e, n);
                                    return e
                                }
                                switch (t.type) {
                                    case "AssignmentExpression":
                                        return this.getDependencies(t.left, e, n), this.getDependencies(t.right, e, n), e;
                                    case "ConditionalExpression":
                                        return this.getDependencies(t.test, e, n), this.getDependencies(t.alternate, e, n), this.getDependencies(t.consequent, e, n), e;
                                    case "Literal":
                                        e.push({
                                            origin: "literal",
                                            value: t.value,
                                            isSafe: !0 !== n && t.value > -1 / 0 && t.value < 1 / 0 && !isNaN(t.value)
                                        });
                                        break;
                                    case "VariableDeclarator":
                                        return this.getDependencies(t.init, e, n);
                                    case "Identifier":
                                        const i = this.getDeclaration(t);
                                        if (i) e.push({
                                            name: t.name,
                                            origin: "declaration",
                                            isSafe: !n && this.isSafeDependencies(i.dependencies)
                                        });
                                        else if (this.argumentNames.indexOf(t.name) > -1) e.push({
                                            name: t.name,
                                            origin: "argument",
                                            isSafe: !1
                                        });
                                        else if (this.strictTypingChecking) throw new Error(`Cannot find identifier origin "${t.name}"`);
                                        break;
                                    case "FunctionDeclaration":
                                        return this.getDependencies(t.body.body[t.body.body.length - 1], e, n);
                                    case "ReturnStatement":
                                        return this.getDependencies(t.argument, e);
                                    case "BinaryExpression":
                                    case "LogicalExpression":
                                        return n = "/" === t.operator || "*" === t.operator, this.getDependencies(t.left, e, n), this.getDependencies(t.right, e, n), e;
                                    case "UnaryExpression":
                                    case "UpdateExpression":
                                        return this.getDependencies(t.argument, e, n);
                                    case "VariableDeclaration":
                                        return this.getDependencies(t.declarations, e, n);
                                    case "ArrayExpression":
                                        return e.push({
                                            origin: "declaration",
                                            isSafe: !0
                                        }), e;
                                    case "CallExpression":
                                        return e.push({
                                            origin: "function",
                                            isSafe: !0
                                        }), e;
                                    case "MemberExpression":
                                        const s = this.getMemberExpressionDetails(t);
                                        switch (s.signature) {
                                            case "value[]":
                                                this.getDependencies(t.object, e, n);
                                                break;
                                            case "value[][]":
                                                this.getDependencies(t.object.object, e, n);
                                                break;
                                            case "value[][][]":
                                                this.getDependencies(t.object.object.object, e, n);
                                                break;
                                            case "this.output.value":
                                                this.dynamicOutput && e.push({
                                                    name: s.name,
                                                    origin: "output",
                                                    isSafe: !1
                                                })
                                        }
                                        if (s) return s.property && this.getDependencies(s.property, e, n), s.xProperty && this.getDependencies(s.xProperty, e, n), s.yProperty && this.getDependencies(s.yProperty, e, n), s.zProperty && this.getDependencies(s.zProperty, e, n), e;
                                    case "SequenceExpression":
                                        return this.getDependencies(t.expressions, e, n);
                                    default:
                                        throw this.astErrorOutput(`Unhandled type ${t.type} in getDependencies`, t)
                                }
                                return e
                            }
                            getVariableSignature(t, e) {
                                if (!this.isAstVariable(t)) throw new Error(`ast of type "${t.type}" is not a variable signature`);
                                if ("Identifier" === t.type) return "value";
                                const n = [];
                                for (; t;) t.computed ? n.push("[]") : "ThisExpression" === t.type ? n.unshift("this") : t.property && t.property.name ? "x" === t.property.name || "y" === t.property.name || "z" === t.property.name ? n.unshift(e ? "." + t.property.name : ".value") : "constants" === t.property.name || "thread" === t.property.name || "output" === t.property.name ? n.unshift("." + t.property.name) : n.unshift(e ? "." + t.property.name : ".value") : t.name ? n.unshift(e ? t.name : "value") : t.callee && t.callee.name ? n.unshift(e ? t.callee.name + "()" : "fn()") : t.elements ? n.unshift("[]") : n.unshift("unknown"), t = t.object;
                                const i = n.join("");
                                return e || ["value", "value[]", "value[][]", "value[][][]", "value[][][][]", "value.value", "value.thread.value", "this.thread.value", "this.output.value", "this.constants.value", "this.constants.value[]", "this.constants.value[][]", "this.constants.value[][][]", "this.constants.value[][][][]", "fn()[]", "fn()[][]", "fn()[][][]", "[][]"].indexOf(i) > -1 ? i : null
                            }
                            build() {
                                return this.toString().length > 0
                            }
                            astGeneric(t, e) {
                                if (null === t) throw this.astErrorOutput("NULL ast", t);
                                if (Array.isArray(t)) {
                                    for (let n = 0; n < t.length; n++) this.astGeneric(t[n], e);
                                    return e
                                }
                                switch (t.type) {
                                    case "FunctionDeclaration":
                                        return this.astFunctionDeclaration(t, e);
                                    case "FunctionExpression":
                                        return this.astFunctionExpression(t, e);
                                    case "ReturnStatement":
                                        return this.astReturnStatement(t, e);
                                    case "Literal":
                                        return this.astLiteral(t, e);
                                    case "BinaryExpression":
                                        return this.astBinaryExpression(t, e);
                                    case "Identifier":
                                        return this.astIdentifierExpression(t, e);
                                    case "AssignmentExpression":
                                        return this.astAssignmentExpression(t, e);
                                    case "ExpressionStatement":
                                        return this.astExpressionStatement(t, e);
                                    case "EmptyStatement":
                                        return this.astEmptyStatement(t, e);
                                    case "BlockStatement":
                                        return this.astBlockStatement(t, e);
                                    case "IfStatement":
                                        return this.astIfStatement(t, e);
                                    case "SwitchStatement":
                                        return this.astSwitchStatement(t, e);
                                    case "BreakStatement":
                                        return this.astBreakStatement(t, e);
                                    case "ContinueStatement":
                                        return this.astContinueStatement(t, e);
                                    case "ForStatement":
                                        return this.astForStatement(t, e);
                                    case "WhileStatement":
                                        return this.astWhileStatement(t, e);
                                    case "DoWhileStatement":
                                        return this.astDoWhileStatement(t, e);
                                    case "VariableDeclaration":
                                        return this.astVariableDeclaration(t, e);
                                    case "VariableDeclarator":
                                        return this.astVariableDeclarator(t, e);
                                    case "ThisExpression":
                                        return this.astThisExpression(t, e);
                                    case "SequenceExpression":
                                        return this.astSequenceExpression(t, e);
                                    case "UnaryExpression":
                                        return this.astUnaryExpression(t, e);
                                    case "UpdateExpression":
                                        return this.astUpdateExpression(t, e);
                                    case "LogicalExpression":
                                        return this.astLogicalExpression(t, e);
                                    case "MemberExpression":
                                        return this.astMemberExpression(t, e);
                                    case "CallExpression":
                                        return this.astCallExpression(t, e);
                                    case "ArrayExpression":
                                        return this.astArrayExpression(t, e);
                                    case "DebuggerStatement":
                                        return this.astDebuggerStatement(t, e);
                                    case "ConditionalExpression":
                                        return this.astConditionalExpression(t, e)
                                }
                                throw this.astErrorOutput("Unknown ast type : " + t.type, t)
                            }
                            astErrorOutput(t, e) {
                                if ("string" != typeof this.source) return new Error(t);
                                const n = s.getAstString(this.source, e),
                                    i = this.source.substr(e.start).split(/\n/),
                                    r = i.length > 0 ? i[i.length - 1] : 0;
                                return new Error(`${t} on line ${i.length}, position ${r.length}:\n ${n}`)
                            }
                            astDebuggerStatement(t, e) {
                                return e
                            }
                            astConditionalExpression(t, e) {
                                if ("ConditionalExpression" !== t.type) throw this.astErrorOutput("Not a conditional expression", t);
                                return e.push("("), this.astGeneric(t.test, e), e.push("?"), this.astGeneric(t.consequent, e), e.push(":"), this.astGeneric(t.alternate, e), e.push(")"), e
                            }
                            astFunction(t, e) {
                                throw new Error(`"astFunction" not defined on ${this.constructor.name}`)
                            }
                            astFunctionDeclaration(t, e) {
                                return this.isChildFunction(t) ? e : this.astFunction(t, e)
                            }
                            astFunctionExpression(t, e) {
                                return this.isChildFunction(t) ? e : this.astFunction(t, e)
                            }
                            isChildFunction(t) {
                                for (let e = 0; e < this.functions.length; e++)
                                    if (this.functions[e] === t) return !0;
                                return !1
                            }
                            astReturnStatement(t, e) {
                                return e
                            }
                            astLiteral(t, e) {
                                return this.literalTypes[this.astKey(t)] = "Number", e
                            }
                            astBinaryExpression(t, e) {
                                return e
                            }
                            astIdentifierExpression(t, e) {
                                return e
                            }
                            astAssignmentExpression(t, e) {
                                return e
                            }
                            astExpressionStatement(t, e) {
                                return this.astGeneric(t.expression, e), e.push(";"), e
                            }
                            astEmptyStatement(t, e) {
                                return e
                            }
                            astBlockStatement(t, e) {
                                return e
                            }
                            astIfStatement(t, e) {
                                return e
                            }
                            astSwitchStatement(t, e) {
                                return e
                            }
                            astBreakStatement(t, e) {
                                return e.push("break;"), e
                            }
                            astContinueStatement(t, e) {
                                return e.push("continue;\n"), e
                            }
                            astForStatement(t, e) {
                                return e
                            }
                            astWhileStatement(t, e) {
                                return e
                            }
                            astDoWhileStatement(t, e) {
                                return e
                            }
                            astVariableDeclarator(t, e) {
                                return this.astGeneric(t.id, e), null !== t.init && (e.push("="), this.astGeneric(t.init, e)), e
                            }
                            astThisExpression(t, e) {
                                return e
                            }
                            astSequenceExpression(t, e) {
                                const {
                                    expressions: n
                                } = t, i = [];
                                for (let t = 0; t < n.length; t++) {
                                    const e = n[t],
                                        s = [];
                                    this.astGeneric(e, s), i.push(s.join(""))
                                }
                                return i.length > 1 ? e.push("(", i.join(","), ")") : e.push(i[0]), e
                            }
                            astUnaryExpression(t, e) {
                                return this.checkAndUpconvertBitwiseUnary(t, e) || (t.prefix ? (e.push(t.operator), this.astGeneric(t.argument, e)) : (this.astGeneric(t.argument, e), e.push(t.operator))), e
                            }
                            checkAndUpconvertBitwiseUnary(t, e) {}
                            astUpdateExpression(t, e) {
                                return t.prefix ? (e.push(t.operator), this.astGeneric(t.argument, e)) : (this.astGeneric(t.argument, e), e.push(t.operator)), e
                            }
                            astLogicalExpression(t, e) {
                                return e.push("("), this.astGeneric(t.left, e), e.push(t.operator), this.astGeneric(t.right, e), e.push(")"), e
                            }
                            astMemberExpression(t, e) {
                                return e
                            }
                            astCallExpression(t, e) {
                                return e
                            }
                            astArrayExpression(t, e) {
                                return e
                            }
                            getMemberExpressionDetails(t) {
                                if ("MemberExpression" !== t.type) throw this.astErrorOutput(`Expression ${t.type} not a MemberExpression`, t);
                                let e = null,
                                    n = null;
                                const i = this.getVariableSignature(t);
                                switch (i) {
                                    case "value":
                                        return null;
                                    case "value.thread.value":
                                    case "this.thread.value":
                                    case "this.output.value":
                                        return {
                                            signature: i, type: "Integer", name: t.property.name
                                        };
                                    case "value[]":
                                        if ("string" != typeof t.object.name) throw this.astErrorOutput("Unexpected expression", t);
                                        return e = t.object.name, {
                                            name: e,
                                            origin: "user",
                                            signature: i,
                                            type: this.getVariableType(t.object),
                                            xProperty: t.property
                                        };
                                    case "value[][]":
                                        if ("string" != typeof t.object.object.name) throw this.astErrorOutput("Unexpected expression", t);
                                        return e = t.object.object.name, {
                                            name: e,
                                            origin: "user",
                                            signature: i,
                                            type: this.getVariableType(t.object.object),
                                            yProperty: t.object.property,
                                            xProperty: t.property
                                        };
                                    case "value[][][]":
                                        if ("string" != typeof t.object.object.object.name) throw this.astErrorOutput("Unexpected expression", t);
                                        return e = t.object.object.object.name, {
                                            name: e,
                                            origin: "user",
                                            signature: i,
                                            type: this.getVariableType(t.object.object.object),
                                            zProperty: t.object.object.property,
                                            yProperty: t.object.property,
                                            xProperty: t.property
                                        };
                                    case "value[][][][]":
                                        if ("string" != typeof t.object.object.object.object.name) throw this.astErrorOutput("Unexpected expression", t);
                                        return e = t.object.object.object.object.name, {
                                            name: e,
                                            origin: "user",
                                            signature: i,
                                            type: this.getVariableType(t.object.object.object.object),
                                            zProperty: t.object.object.property,
                                            yProperty: t.object.property,
                                            xProperty: t.property
                                        };
                                    case "value.value":
                                        if ("string" != typeof t.property.name) throw this.astErrorOutput("Unexpected expression", t);
                                        if (this.isAstMathVariable(t)) return e = t.property.name, {
                                            name: e,
                                            origin: "Math",
                                            type: "Number",
                                            signature: i
                                        };
                                        switch (t.property.name) {
                                            case "r":
                                            case "g":
                                            case "b":
                                            case "a":
                                                return e = t.object.name, {
                                                    name: e,
                                                    property: t.property.name,
                                                    origin: "user",
                                                    signature: i,
                                                    type: "Number"
                                                };
                                            default:
                                                throw this.astErrorOutput("Unexpected expression", t)
                                        }
                                        case "this.constants.value":
                                            if ("string" != typeof t.property.name) throw this.astErrorOutput("Unexpected expression", t);
                                            if (e = t.property.name, n = this.getConstantType(e), !n) throw this.astErrorOutput("Constant has no type", t);
                                            return {
                                                name: e, type: n, origin: "constants", signature: i
                                            };
                                        case "this.constants.value[]":
                                            if ("string" != typeof t.object.property.name) throw this.astErrorOutput("Unexpected expression", t);
                                            if (e = t.object.property.name, n = this.getConstantType(e), !n) throw this.astErrorOutput("Constant has no type", t);
                                            return {
                                                name: e, type: n, origin: "constants", signature: i, xProperty: t.property
                                            };
                                        case "this.constants.value[][]":
                                            if ("string" != typeof t.object.object.property.name) throw this.astErrorOutput("Unexpected expression", t);
                                            if (e = t.object.object.property.name, n = this.getConstantType(e), !n) throw this.astErrorOutput("Constant has no type", t);
                                            return {
                                                name: e, type: n, origin: "constants", signature: i, yProperty: t.object.property, xProperty: t.property
                                            };
                                        case "this.constants.value[][][]":
                                            if ("string" != typeof t.object.object.object.property.name) throw this.astErrorOutput("Unexpected expression", t);
                                            if (e = t.object.object.object.property.name, n = this.getConstantType(e), !n) throw this.astErrorOutput("Constant has no type", t);
                                            return {
                                                name: e, type: n, origin: "constants", signature: i, zProperty: t.object.object.property, yProperty: t.object.property, xProperty: t.property
                                            };
                                        case "fn()[]":
                                        case "fn()[][]":
                                        case "[][]":
                                            return {
                                                signature: i, property: t.property
                                            };
                                        default:
                                            throw this.astErrorOutput("Unexpected expression", t)
                                }
                            }
                            findIdentifierOrigin(t) {
                                const e = [this.ast];
                                for (; e.length > 0;) {
                                    const n = e[0];
                                    if ("VariableDeclarator" === n.type && n.id && n.id.name && n.id.name === t.name) return n;
                                    if (e.shift(), n.argument) e.push(n.argument);
                                    else if (n.body) e.push(n.body);
                                    else if (n.declarations) e.push(n.declarations);
                                    else if (Array.isArray(n))
                                        for (let t = 0; t < n.length; t++) e.push(n[t])
                                }
                                return null
                            }
                            findLastReturn(t) {
                                const e = [t || this.ast];
                                for (; e.length > 0;) {
                                    const t = e.pop();
                                    if ("ReturnStatement" === t.type) return t;
                                    if ("FunctionDeclaration" !== t.type)
                                        if (t.argument) e.push(t.argument);
                                        else if (t.body) e.push(t.body);
                                    else if (t.declarations) e.push(t.declarations);
                                    else if (Array.isArray(t))
                                        for (let n = 0; n < t.length; n++) e.push(t[n]);
                                    else t.consequent ? e.push(t.consequent) : t.cases && e.push(t.cases)
                                }
                                return null
                            }
                            getInternalVariableName(t) {
                                return this._internalVariableNames.hasOwnProperty(t) || (this._internalVariableNames[t] = 0), this._internalVariableNames[t]++, 1 === this._internalVariableNames[t] ? t : t + this._internalVariableNames[t]
                            }
                            astKey(t, e = ",") {
                                if (!t.start || !t.end) throw new Error("AST start and end needed");
                                return `${t.start}${e}${t.end}`
                            }
                        }
                    }
                }, {
                    "../utils": 114,
                    "./function-tracer": 11,
                    acorn: 1
                }],
                11: [function(t, e, n) {
                    const {
                        utils: i
                    } = t("../utils");

                    function s(t) {
                        return t.length > 0 ? t[t.length - 1] : null
                    }
                    const r = "trackIdentifiers",
                        a = "memberExpression",
                        o = "inForLoopInit";
                    e.exports = {
                        FunctionTracer: class {
                            constructor(t) {
                                this.runningContexts = [], this.functionContexts = [], this.contexts = [], this.functionCalls = [], this.declarations = [], this.identifiers = [], this.functions = [], this.returnStatements = [], this.trackedIdentifiers = null, this.states = [], this.newFunctionContext(), this.scan(t)
                            }
                            isState(t) {
                                return this.states[this.states.length - 1] === t
                            }
                            hasState(t) {
                                return this.states.indexOf(t) > -1
                            }
                            pushState(t) {
                                this.states.push(t)
                            }
                            popState(t) {
                                if (!this.isState(t)) throw new Error(`Cannot pop the non-active state "${t}"`);
                                this.states.pop()
                            }
                            get currentFunctionContext() {
                                return s(this.functionContexts)
                            }
                            get currentContext() {
                                return s(this.runningContexts)
                            }
                            newFunctionContext() {
                                const t = {
                                    "@contextType": "function"
                                };
                                this.contexts.push(t), this.functionContexts.push(t)
                            }
                            newContext(t) {
                                const e = Object.assign({
                                    "@contextType": "const/let"
                                }, this.currentContext);
                                this.contexts.push(e), this.runningContexts.push(e), t();
                                const {
                                    currentFunctionContext: n
                                } = this;
                                for (const t in n) n.hasOwnProperty(t) && !e.hasOwnProperty(t) && (e[t] = n[t]);
                                return this.runningContexts.pop(), e
                            }
                            useFunctionContext(t) {
                                const e = s(this.functionContexts);
                                this.runningContexts.push(e), t(), this.runningContexts.pop()
                            }
                            getIdentifiers(t) {
                                const e = this.trackedIdentifiers = [];
                                return this.pushState(r), t(), this.trackedIdentifiers = null, this.popState(r), e
                            }
                            getDeclaration(t) {
                                const {
                                    currentContext: e,
                                    currentFunctionContext: n,
                                    runningContexts: i
                                } = this, s = e[t] || n[t] || null;
                                if (!s && e === n && i.length > 0) {
                                    const e = i[i.length - 2];
                                    if (e[t]) return e[t]
                                }
                                return s
                            }
                            scan(t) {
                                if (t)
                                    if (Array.isArray(t))
                                        for (let e = 0; e < t.length; e++) this.scan(t[e]);
                                    else switch (t.type) {
                                        case "Program":
                                            this.useFunctionContext((() => {
                                                this.scan(t.body)
                                            }));
                                            break;
                                        case "BlockStatement":
                                            this.newContext((() => {
                                                this.scan(t.body)
                                            }));
                                            break;
                                        case "AssignmentExpression":
                                        case "LogicalExpression":
                                        case "BinaryExpression":
                                            this.scan(t.left), this.scan(t.right);
                                            break;
                                        case "UpdateExpression":
                                            if ("++" === t.operator) {
                                                const e = this.getDeclaration(t.argument.name);
                                                e && (e.suggestedType = "Integer")
                                            }
                                            this.scan(t.argument);
                                            break;
                                        case "UnaryExpression":
                                            this.scan(t.argument);
                                            break;
                                        case "VariableDeclaration":
                                            "var" === t.kind ? this.useFunctionContext((() => {
                                                t.declarations = i.normalizeDeclarations(t), this.scan(t.declarations)
                                            })) : (t.declarations = i.normalizeDeclarations(t), this.scan(t.declarations));
                                            break;
                                        case "VariableDeclarator": {
                                            const {
                                                currentContext: e
                                            } = this, n = this.hasState(o), i = {
                                                ast: t,
                                                context: e,
                                                name: t.id.name,
                                                origin: "declaration",
                                                inForLoopInit: n,
                                                inForLoopTest: null,
                                                assignable: e === this.currentFunctionContext || !n && !e.hasOwnProperty(t.id.name),
                                                suggestedType: null,
                                                valueType: null,
                                                dependencies: null,
                                                isSafe: null
                                            };
                                            e[t.id.name] || (e[t.id.name] = i), this.declarations.push(i), this.scan(t.id), this.scan(t.init);
                                            break
                                        }
                                        case "FunctionExpression":
                                        case "FunctionDeclaration":
                                            0 === this.runningContexts.length ? this.scan(t.body) : this.functions.push(t);
                                            break;
                                        case "IfStatement":
                                            this.scan(t.test), this.scan(t.consequent), t.alternate && this.scan(t.alternate);
                                            break;
                                        case "ForStatement": {
                                            let e;
                                            const n = this.newContext((() => {
                                                this.pushState(o), this.scan(t.init), this.popState(o), e = this.getIdentifiers((() => {
                                                    this.scan(t.test)
                                                })), this.scan(t.update), this.newContext((() => {
                                                    this.scan(t.body)
                                                }))
                                            }));
                                            if (e)
                                                for (const t in n) "@contextType" !== t && e.indexOf(t) > -1 && (n[t].inForLoopTest = !0);
                                            break
                                        }
                                        case "DoWhileStatement":
                                        case "WhileStatement":
                                            this.newContext((() => {
                                                this.scan(t.body), this.scan(t.test)
                                            }));
                                            break;
                                        case "Identifier":
                                            this.isState(r) && this.trackedIdentifiers.push(t.name), this.identifiers.push({
                                                context: this.currentContext,
                                                declaration: this.getDeclaration(t.name),
                                                ast: t
                                            });
                                            break;
                                        case "ReturnStatement":
                                            this.returnStatements.push(t), this.scan(t.argument);
                                            break;
                                        case "MemberExpression":
                                            this.pushState(a), this.scan(t.object), this.scan(t.property), this.popState(a);
                                            break;
                                        case "ExpressionStatement":
                                            this.scan(t.expression);
                                            break;
                                        case "SequenceExpression":
                                            this.scan(t.expressions);
                                            break;
                                        case "CallExpression":
                                            this.functionCalls.push({
                                                context: this.currentContext,
                                                ast: t
                                            }), this.scan(t.arguments);
                                            break;
                                        case "ArrayExpression":
                                            this.scan(t.elements);
                                            break;
                                        case "ConditionalExpression":
                                            this.scan(t.test), this.scan(t.alternate), this.scan(t.consequent);
                                            break;
                                        case "SwitchStatement":
                                            this.scan(t.discriminant), this.scan(t.cases);
                                            break;
                                        case "SwitchCase":
                                            this.scan(t.test), this.scan(t.consequent);
                                            break;
                                        case "ThisExpression":
                                        case "Literal":
                                        case "DebuggerStatement":
                                        case "EmptyStatement":
                                        case "BreakStatement":
                                        case "ContinueStatement":
                                            break;
                                        default:
                                            throw new Error(`unhandled type "${t.type}"`)
                                    }
                            }
                        }
                    }
                }, {
                    "../utils": 114
                }],
                12: [function(t, e, n) {
                    const {
                        glWiretap: i
                    } = t("gl-wiretap"), {
                        utils: s
                    } = t("../../utils");

                    function r(t) {
                        return t.toString().replace("=>", "").replace(/^function /, "").replace(/utils[.]/g, "/*utils.*/")
                    }

                    function a(t, e) {
                        const n = "single" === e.precision ? t : `new Float32Array(${t}.buffer)`;
                        return e.output[2] ? `renderOutput(${n}, ${e.output[0]}, ${e.output[1]}, ${e.output[2]})` : e.output[1] ? `renderOutput(${n}, ${e.output[0]}, ${e.output[1]})` : `renderOutput(${n}, ${e.output[0]})`
                    }

                    function o(t, e, n) {
                        const i = t.toArray.toString(),
                            r = !/^function/.test(i);
                        return `() => {\n  function framebuffer() { return ${n}; };\n  ${s.flattenFunctionToString(`${r?"function ":""}${i}`,{findDependency:(e,n)=>{if("utils"===e)return`const ${n} = ${s[n].toString()};`;if("this"===e)return"framebuffer"===n?"":`${r?"function ":""}${t[n].toString()}`;throw new Error("unhandled fromObject")},thisLookup:(n,i)=>{if("texture"===n)return e;if("context"===n)return i?null:"gl";if(t.hasOwnProperty(n))return JSON.stringify(t[n]);throw new Error(`
                        unhandled thisLookup $ {
                            n
                        }
                        `)}})}\n  return toArray();\n  }`
                    }

                    function u(t, e, n, i, s) {
                        if (null === t) return null;
                        if (null === e) return null;
                        switch (typeof t) {
                            case "boolean":
                            case "number":
                                return null
                        }
                        if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement)
                            for (let s = 0; s < e.length; s++) {
                                const r = e[s];
                                if ("HTMLImageArray" !== r.type && r) continue;
                                if (r.uploadValue !== t) continue;
                                const a = n[s].indexOf(t);
                                if (-1 === a) continue;
                                const o = `uploadValue_${r.name}[${a}]`;
                                return i.insertVariable(o, t), o
                            }
                        for (let n = 0; n < e.length; n++) {
                            const s = e[n];
                            if (t !== s.uploadValue) continue;
                            const r = `uploadValue_${s.name}`;
                            return i.insertVariable(r, s), r
                        }
                        return null
                    }
                    e.exports = {
                        glKernelString: function(t, e, n, h, l) {
                            n.built || n.build.apply(n, e), e = e ? Array.from(e).map((t => {
                                switch (typeof t) {
                                    case "boolean":
                                        return new Boolean(t);
                                    case "number":
                                        return new Number(t);
                                    default:
                                        return t
                                }
                            })) : null;
                            const c = [],
                                p = i(n.context, {
                                    useTrackablePrimitives: !0,
                                    onReadPixels: t => {
                                        if (R.subKernels) {
                                            if (d) {
                                                const e = R.subKernels[m++].property;
                                                c.push(`    result${isNaN(e)?"."+e:`[${e}]`} = ${a(t,R)};`)
                                            } else c.push(`    const result = { result: ${a(t,R)} };`), d = !0;
                                            m === R.subKernels.length && c.push("    return result;")
                                        } else t ? c.push(`    return ${a(t,R)};`) : c.push("    return null;")
                                    },
                                    onUnrecognizedArgumentLookup: t => {
                                        const e = u(t, R.kernelArguments, [], p);
                                        if (e) return e;
                                        return u(t, R.kernelConstants, w ? Object.keys(w).map((t => w[t])) : [], p) || null
                                    }
                                });
                            let d = !1,
                                m = 0;
                            const {
                                source: g,
                                canvas: f,
                                output: y,
                                pipeline: x,
                                graphical: _,
                                loopMaxIterations: b,
                                constants: w,
                                optimizeFloatMemory: T,
                                precision: v,
                                fixIntegerDivisionAccuracy: E,
                                functions: A,
                                nativeFunctions: I,
                                subKernels: S,
                                immutable: k,
                                argumentTypes: D,
                                constantTypes: L,
                                kernelArguments: C,
                                kernelConstants: M,
                                tactic: O
                            } = n, R = new t(g, {
                                canvas: f,
                                context: p,
                                checkContext: !1,
                                output: y,
                                pipeline: x,
                                graphical: _,
                                loopMaxIterations: b,
                                constants: w,
                                optimizeFloatMemory: T,
                                precision: v,
                                fixIntegerDivisionAccuracy: E,
                                functions: A,
                                nativeFunctions: I,
                                subKernels: S,
                                immutable: k,
                                argumentTypes: D,
                                constantTypes: L,
                                tactic: O
                            });
                            let N = [];
                            if (p.setIndent(2), R.build.apply(R, e), N.push(p.toString()), p.reset(), R.kernelArguments.forEach(((t, n) => {
                                    switch (t.type) {
                                        case "Integer":
                                        case "Boolean":
                                        case "Number":
                                        case "Float":
                                        case "Array":
                                        case "Array(2)":
                                        case "Array(3)":
                                        case "Array(4)":
                                        case "HTMLCanvas":
                                        case "HTMLImage":
                                        case "HTMLVideo":
                                        case "Input":
                                            p.insertVariable(`uploadValue_${t.name}`, t.uploadValue);
                                            break;
                                        case "HTMLImageArray":
                                            for (let i = 0; i < e[n].length; i++) {
                                                const s = e[n];
                                                p.insertVariable(`uploadValue_${t.name}[${i}]`, s[i])
                                            }
                                            break;
                                        case "MemoryOptimizedNumberTexture":
                                        case "NumberTexture":
                                        case "Array1D(2)":
                                        case "Array1D(3)":
                                        case "Array1D(4)":
                                        case "Array2D(2)":
                                        case "Array2D(3)":
                                        case "Array2D(4)":
                                        case "Array3D(2)":
                                        case "Array3D(3)":
                                        case "Array3D(4)":
                                        case "ArrayTexture(1)":
                                        case "ArrayTexture(2)":
                                        case "ArrayTexture(3)":
                                        case "ArrayTexture(4)":
                                            p.insertVariable(`uploadValue_${t.name}`, e[n].texture);
                                            break;
                                        default:
                                            throw new Error(`unhandled kernelArgumentType insertion for glWiretap of type ${t.type}`)
                                    }
                                })), N.push("/** start of injected functions **/"), N.push(`function ${r(s.flattenTo)}`), N.push(`function ${r(s.flatten2dArrayTo)}`), N.push(`function ${r(s.flatten3dArrayTo)}`), N.push(`function ${r(s.flatten4dArrayTo)}`), N.push(`function ${r(s.isArray)}`), R.renderOutput !== R.renderTexture && R.formatValues && N.push(`  const renderOutput = function ${r(R.formatValues)};`), N.push("/** end of injected functions **/"), N.push(`  const innerKernel = function (${R.kernelArguments.map((t=>t.varName)).join(", ")}) {`), p.setIndent(4), R.run.apply(R, e), R.renderKernels ? R.renderKernels() : R.renderOutput && R.renderOutput(), N.push("    /** start setup uploads for kernel values **/"), R.kernelArguments.forEach((t => {
                                    N.push("    " + t.getStringValueHandler().split("\n").join("\n    "))
                                })), N.push("    /** end setup uploads for kernel values **/"), N.push(p.toString()), R.renderOutput === R.renderTexture) {
                                p.reset();
                                const t = p.getContextVariableName(R.framebuffer);
                                if (R.renderKernels) {
                                    const e = R.renderKernels(),
                                        n = p.getContextVariableName(R.texture.texture);
                                    N.push(`    return {\n      result: {\n        texture: ${n},\n        type: '${e.result.type}',\n        toArray: ${o(e.result,n,t)}\n      },`);
                                    const {
                                        subKernels: i,
                                        mappedTextures: s
                                    } = R;
                                    for (let n = 0; n < i.length; n++) {
                                        const r = s[n],
                                            a = i[n],
                                            u = e[a.property],
                                            h = p.getContextVariableName(r.texture);
                                        N.push(`\n      ${a.property}: {\n        texture: ${h},\n        type: '${u.type}',\n        toArray: ${o(u,h,t)}\n      },`)
                                    }
                                    N.push("    };")
                                } else {
                                    const e = R.renderOutput(),
                                        n = p.getContextVariableName(R.texture.texture);
                                    N.push(`    return {\n        texture: ${n},\n        type: '${e.type}',\n        toArray: ${o(e,n,t)}\n      };`)
                                }
                            }
                            N.push("    " + (l ? "\n" + l + "    " : "")), N.push(c.join("\n")), N.push("  };"), R.graphical && (N.push(function(t) {
                                const e = t.getPixels.toString(),
                                    n = !/^function/.test(e);
                                return s.flattenFunctionToString(`${n?"function ":""}${e}`, {
                                    findDependency: (t, e) => "utils" === t ? `const ${e} = ${s[e].toString()};` : null,
                                    thisLookup: e => {
                                        if ("context" === e) return null;
                                        if (t.hasOwnProperty(e)) return JSON.stringify(t[e]);
                                        throw new Error(`unhandled thisLookup ${e}`)
                                    }
                                })
                            }(R)), N.push("  innerKernel.getPixels = getPixels;")), N.push("  return innerKernel;");
                            let P = [];
                            return M.forEach((t => {
                                P.push(`${t.getStringValueHandler()}`)
                            })), `function kernel(settings) {\n  const { context, constants } = settings;\n  ${P.join("")}\n  ${h||""}\n${N.join("\n")}\n}`
                        }
                    }
                }, {
                    "../../utils": 114,
                    "gl-wiretap": 3
                }],
                13: [function(t, e, n) {
                    const {
                        Kernel: i
                    } = t("../kernel"), {
                        utils: s
                    } = t("../../utils"), {
                        GLTextureArray2Float: r
                    } = t("./texture/array-2-float"), {
                        GLTextureArray2Float2D: a
                    } = t("./texture/array-2-float-2d"), {
                        GLTextureArray2Float3D: o
                    } = t("./texture/array-2-float-3d"), {
                        GLTextureArray3Float: u
                    } = t("./texture/array-3-float"), {
                        GLTextureArray3Float2D: h
                    } = t("./texture/array-3-float-2d"), {
                        GLTextureArray3Float3D: l
                    } = t("./texture/array-3-float-3d"), {
                        GLTextureArray4Float: c
                    } = t("./texture/array-4-float"), {
                        GLTextureArray4Float2D: p
                    } = t("./texture/array-4-float-2d"), {
                        GLTextureArray4Float3D: d
                    } = t("./texture/array-4-float-3d"), {
                        GLTextureFloat: m
                    } = t("./texture/float"), {
                        GLTextureFloat2D: g
                    } = t("./texture/float-2d"), {
                        GLTextureFloat3D: f
                    } = t("./texture/float-3d"), {
                        GLTextureMemoryOptimized: y
                    } = t("./texture/memory-optimized"), {
                        GLTextureMemoryOptimized2D: x
                    } = t("./texture/memory-optimized-2d"), {
                        GLTextureMemoryOptimized3D: _
                    } = t("./texture/memory-optimized-3d"), {
                        GLTextureUnsigned: b
                    } = t("./texture/unsigned"), {
                        GLTextureUnsigned2D: w
                    } = t("./texture/unsigned-2d"), {
                        GLTextureUnsigned3D: T
                    } = t("./texture/unsigned-3d"), {
                        GLTextureGraphical: v
                    } = t("./texture/graphical");
                    const E = {
                        int: "Integer",
                        float: "Number",
                        vec2: "Array(2)",
                        vec3: "Array(3)",
                        vec4: "Array(4)"
                    };
                    e.exports = {
                        GLKernel: class extends i {
                            static get mode() {
                                return "gpu"
                            }
                            static getIsFloatRead() {
                                const t = new this("function kernelFunction() {\n      return 1;\n    }", {
                                    context: this.testContext,
                                    canvas: this.testCanvas,
                                    validate: !1,
                                    output: [1],
                                    precision: "single",
                                    returnType: "Number",
                                    tactic: "speed"
                                });
                                t.build(), t.run();
                                const e = t.renderOutput();
                                return t.destroy(!0), 1 === e[0]
                            }
                            static getIsIntegerDivisionAccurate() {
                                const t = new this(function(t, e) {
                                        return t[this.thread.x] / e[this.thread.x]
                                    }.toString(), {
                                        context: this.testContext,
                                        canvas: this.testCanvas,
                                        validate: !1,
                                        output: [2],
                                        returnType: "Number",
                                        precision: "unsigned",
                                        tactic: "speed"
                                    }),
                                    e = [
                                        [6, 6030401],
                                        [3, 3991]
                                    ];
                                t.build.apply(t, e), t.run.apply(t, e);
                                const n = t.renderOutput();
                                return t.destroy(!0), 2 === n[0] && 1511 === n[1]
                            }
                            static getIsSpeedTacticSupported() {
                                const t = new this(function(t) {
                                        return t[this.thread.x]
                                    }.toString(), {
                                        context: this.testContext,
                                        canvas: this.testCanvas,
                                        validate: !1,
                                        output: [4],
                                        returnType: "Number",
                                        precision: "unsigned",
                                        tactic: "speed"
                                    }),
                                    e = [
                                        [0, 1, 2, 3]
                                    ];
                                t.build.apply(t, e), t.run.apply(t, e);
                                const n = t.renderOutput();
                                return t.destroy(!0), 0 === Math.round(n[0]) && 1 === Math.round(n[1]) && 2 === Math.round(n[2]) && 3 === Math.round(n[3])
                            }
                            static get testCanvas() {
                                throw new Error(`"testCanvas" not defined on ${this.name}`)
                            }
                            static get testContext() {
                                throw new Error(`"testContext" not defined on ${this.name}`)
                            }
                            static getFeatures() {
                                const t = this.testContext,
                                    e = this.getIsDrawBuffers();
                                return Object.freeze({
                                    isFloatRead: this.getIsFloatRead(),
                                    isIntegerDivisionAccurate: this.getIsIntegerDivisionAccurate(),
                                    isSpeedTacticSupported: this.getIsSpeedTacticSupported(),
                                    isTextureFloat: this.getIsTextureFloat(),
                                    isDrawBuffers: e,
                                    kernelMap: e,
                                    channelCount: this.getChannelCount(),
                                    maxTextureSize: this.getMaxTextureSize(),
                                    lowIntPrecision: t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.LOW_INT),
                                    lowFloatPrecision: t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.LOW_FLOAT),
                                    mediumIntPrecision: t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.MEDIUM_INT),
                                    mediumFloatPrecision: t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.MEDIUM_FLOAT),
                                    highIntPrecision: t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_INT),
                                    highFloatPrecision: t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT)
                                })
                            }
                            static setupFeatureChecks() {
                                throw new Error(`"setupFeatureChecks" not defined on ${this.name}`)
                            }
                            static getSignature(t, e) {
                                return t.getVariablePrecisionString() + (e.length > 0 ? ":" + e.join(",") : "")
                            }
                            setFixIntegerDivisionAccuracy(t) {
                                return this.fixIntegerDivisionAccuracy = t, this
                            }
                            setPrecision(t) {
                                return this.precision = t, this
                            }
                            setFloatTextures(t) {
                                return s.warnDeprecated("method", "setFloatTextures", "setOptimizeFloatMemory"), this.floatTextures = t, this
                            }
                            static nativeFunctionArguments(t) {
                                const e = [],
                                    n = [],
                                    i = [],
                                    s = /^[a-zA-Z_]/,
                                    r = /[a-zA-Z_0-9]/;
                                let a = 0,
                                    o = null,
                                    u = null;
                                for (; a < t.length;) {
                                    const h = t[a],
                                        l = t[a + 1],
                                        c = i.length > 0 ? i[i.length - 1] : null;
                                    if ("FUNCTION_ARGUMENTS" !== c || "/" !== h || "*" !== l)
                                        if ("MULTI_LINE_COMMENT" !== c || "*" !== h || "/" !== l)
                                            if ("FUNCTION_ARGUMENTS" !== c || "/" !== h || "/" !== l)
                                                if ("COMMENT" !== c || "\n" !== h)
                                                    if (null !== c || "(" !== h) {
                                                        if ("FUNCTION_ARGUMENTS" === c) {
                                                            if (")" === h) {
                                                                i.pop();
                                                                break
                                                            }
                                                            if ("f" === h && "l" === l && "o" === t[a + 2] && "a" === t[a + 3] && "t" === t[a + 4] && " " === t[a + 5]) {
                                                                i.push("DECLARE_VARIABLE"), u = "float", o = "", a += 6;
                                                                continue
                                                            }
                                                            if ("i" === h && "n" === l && "t" === t[a + 2] && " " === t[a + 3]) {
                                                                i.push("DECLARE_VARIABLE"), u = "int", o = "", a += 4;
                                                                continue
                                                            }
                                                            if ("v" === h && "e" === l && "c" === t[a + 2] && "2" === t[a + 3] && " " === t[a + 4]) {
                                                                i.push("DECLARE_VARIABLE"), u = "vec2", o = "", a += 5;
                                                                continue
                                                            }
                                                            if ("v" === h && "e" === l && "c" === t[a + 2] && "3" === t[a + 3] && " " === t[a + 4]) {
                                                                i.push("DECLARE_VARIABLE"), u = "vec3", o = "", a += 5;
                                                                continue
                                                            }
                                                            if ("v" === h && "e" === l && "c" === t[a + 2] && "4" === t[a + 3] && " " === t[a + 4]) {
                                                                i.push("DECLARE_VARIABLE"), u = "vec4", o = "", a += 5;
                                                                continue
                                                            }
                                                        } else if ("DECLARE_VARIABLE" === c) {
                                                            if ("" === o) {
                                                                if (" " === h) {
                                                                    a++;
                                                                    continue
                                                                }
                                                                if (!s.test(h)) throw new Error("variable name is not expected string")
                                                            }
                                                            o += h, r.test(l) || (i.pop(), n.push(o), e.push(E[u]))
                                                        }
                                                        a++
                                                    } else i.push("FUNCTION_ARGUMENTS"), a++;
                                    else i.pop(), a++;
                                    else i.push("COMMENT"), a += 2;
                                    else i.pop(), a += 2;
                                    else i.push("MULTI_LINE_COMMENT"), a += 2
                                }
                                if (i.length > 0) throw new Error("GLSL function was not parsable");
                                return {
                                    argumentNames: n,
                                    argumentTypes: e
                                }
                            }
                            static nativeFunctionReturnType(t) {
                                return E[t.match(/int|float|vec[2-4]/)[0]]
                            }
                            static combineKernels(t, e) {
                                t.apply(null, arguments);
                                const {
                                    texSize: n,
                                    context: i,
                                    threadDim: r
                                } = e.texSize;
                                let a;
                                if ("single" === e.precision) {
                                    const t = n[0],
                                        e = Math.ceil(n[1] / 4);
                                    a = new Float32Array(t * e * 4 * 4), i.readPixels(0, 0, t, 4 * e, i.RGBA, i.FLOAT, a)
                                } else {
                                    const t = new Uint8Array(n[0] * n[1] * 4);
                                    i.readPixels(0, 0, n[0], n[1], i.RGBA, i.UNSIGNED_BYTE, t), a = new Float32Array(t.buffer)
                                }
                                return a = a.subarray(0, r[0] * r[1] * r[2]), 1 === e.output.length ? a : 2 === e.output.length ? s.splitArray(a, e.output[0]) : 3 === e.output.length ? s.splitArray(a, e.output[0] * e.output[1]).map((function(t) {
                                    return s.splitArray(t, e.output[0])
                                })) : void 0
                            }
                            constructor(t, e) {
                                super(t, e), this.transferValues = null, this.formatValues = null, this.TextureConstructor = null, this.renderOutput = null, this.renderRawOutput = null, this.texSize = null, this.translatedSource = null, this.compiledFragmentShader = null, this.compiledVertexShader = null, this.switchingKernels = null, this._textureSwitched = null, this._mappedTextureSwitched = null
                            }
                            checkTextureSize() {
                                const {
                                    features: t
                                } = this.constructor;
                                if (this.texSize[0] > t.maxTextureSize || this.texSize[1] > t.maxTextureSize) throw new Error(`Texture size [${this.texSize[0]},${this.texSize[1]}] generated by kernel is larger than supported size [${t.maxTextureSize},${t.maxTextureSize}]`)
                            }
                            translateSource() {
                                throw new Error(`"translateSource" not defined on ${this.constructor.name}`)
                            }
                            pickRenderStrategy(t) {
                                if (this.graphical) return this.renderRawOutput = this.readPackedPixelsToUint8Array, this.transferValues = t => t, this.TextureConstructor = v, null;
                                if ("unsigned" === this.precision)
                                    if (this.renderRawOutput = this.readPackedPixelsToUint8Array, this.transferValues = this.readPackedPixelsToFloat32Array, this.pipeline) switch (this.renderOutput = this.renderTexture, null !== this.subKernels && (this.renderKernels = this.renderKernelsToTextures), this.returnType) {
                                        case "LiteralInteger":
                                        case "Float":
                                        case "Number":
                                        case "Integer":
                                            return this.output[2] > 0 ? (this.TextureConstructor = T, null) : this.output[1] > 0 ? (this.TextureConstructor = w, null) : (this.TextureConstructor = b, null);
                                        case "Array(2)":
                                        case "Array(3)":
                                        case "Array(4)":
                                            return this.requestFallback(t)
                                    } else switch (null !== this.subKernels && (this.renderKernels = this.renderKernelsToArrays), this.returnType) {
                                        case "LiteralInteger":
                                        case "Float":
                                        case "Number":
                                        case "Integer":
                                            return this.renderOutput = this.renderValues, this.output[2] > 0 ? (this.TextureConstructor = T, this.formatValues = s.erect3DPackedFloat, null) : this.output[1] > 0 ? (this.TextureConstructor = w, this.formatValues = s.erect2DPackedFloat, null) : (this.TextureConstructor = b, this.formatValues = s.erectPackedFloat, null);
                                        case "Array(2)":
                                        case "Array(3)":
                                        case "Array(4)":
                                            return this.requestFallback(t)
                                    } else {
                                        if ("single" !== this.precision) throw new Error(`unhandled precision of "${this.precision}"`);
                                        if (this.renderRawOutput = this.readFloatPixelsToFloat32Array, this.transferValues = this.readFloatPixelsToFloat32Array, this.pipeline) switch (this.renderOutput = this.renderTexture, null !== this.subKernels && (this.renderKernels = this.renderKernelsToTextures), this.returnType) {
                                            case "LiteralInteger":
                                            case "Float":
                                            case "Number":
                                            case "Integer":
                                                return this.optimizeFloatMemory ? this.output[2] > 0 ? (this.TextureConstructor = _, null) : this.output[1] > 0 ? (this.TextureConstructor = x, null) : (this.TextureConstructor = y, null) : this.output[2] > 0 ? (this.TextureConstructor = f, null) : this.output[1] > 0 ? (this.TextureConstructor = g, null) : (this.TextureConstructor = m, null);
                                            case "Array(2)":
                                                return this.output[2] > 0 ? (this.TextureConstructor = o, null) : this.output[1] > 0 ? (this.TextureConstructor = a, null) : (this.TextureConstructor = r, null);
                                            case "Array(3)":
                                                return this.output[2] > 0 ? (this.TextureConstructor = l, null) : this.output[1] > 0 ? (this.TextureConstructor = h, null) : (this.TextureConstructor = u, null);
                                            case "Array(4)":
                                                return this.output[2] > 0 ? (this.TextureConstructor = d, null) : this.output[1] > 0 ? (this.TextureConstructor = p, null) : (this.TextureConstructor = c, null)
                                        }
                                        if (this.renderOutput = this.renderValues, null !== this.subKernels && (this.renderKernels = this.renderKernelsToArrays), this.optimizeFloatMemory) switch (this.returnType) {
                                            case "LiteralInteger":
                                            case "Float":
                                            case "Number":
                                            case "Integer":
                                                return this.output[2] > 0 ? (this.TextureConstructor = _, this.formatValues = s.erectMemoryOptimized3DFloat, null) : this.output[1] > 0 ? (this.TextureConstructor = x, this.formatValues = s.erectMemoryOptimized2DFloat, null) : (this.TextureConstructor = y, this.formatValues = s.erectMemoryOptimizedFloat, null);
                                            case "Array(2)":
                                                return this.output[2] > 0 ? (this.TextureConstructor = o, this.formatValues = s.erect3DArray2, null) : this.output[1] > 0 ? (this.TextureConstructor = a, this.formatValues = s.erect2DArray2, null) : (this.TextureConstructor = r, this.formatValues = s.erectArray2, null);
                                            case "Array(3)":
                                                return this.output[2] > 0 ? (this.TextureConstructor = l, this.formatValues = s.erect3DArray3, null) : this.output[1] > 0 ? (this.TextureConstructor = h, this.formatValues = s.erect2DArray3, null) : (this.TextureConstructor = u, this.formatValues = s.erectArray3, null);
                                            case "Array(4)":
                                                return this.output[2] > 0 ? (this.TextureConstructor = d, this.formatValues = s.erect3DArray4, null) : this.output[1] > 0 ? (this.TextureConstructor = p, this.formatValues = s.erect2DArray4, null) : (this.TextureConstructor = c, this.formatValues = s.erectArray4, null)
                                        } else switch (this.returnType) {
                                            case "LiteralInteger":
                                            case "Float":
                                            case "Number":
                                            case "Integer":
                                                return this.output[2] > 0 ? (this.TextureConstructor = f, this.formatValues = s.erect3DFloat, null) : this.output[1] > 0 ? (this.TextureConstructor = g, this.formatValues = s.erect2DFloat, null) : (this.TextureConstructor = m, this.formatValues = s.erectFloat, null);
                                            case "Array(2)":
                                                return this.output[2] > 0 ? (this.TextureConstructor = o, this.formatValues = s.erect3DArray2, null) : this.output[1] > 0 ? (this.TextureConstructor = a, this.formatValues = s.erect2DArray2, null) : (this.TextureConstructor = r, this.formatValues = s.erectArray2, null);
                                            case "Array(3)":
                                                return this.output[2] > 0 ? (this.TextureConstructor = l, this.formatValues = s.erect3DArray3, null) : this.output[1] > 0 ? (this.TextureConstructor = h, this.formatValues = s.erect2DArray3, null) : (this.TextureConstructor = u, this.formatValues = s.erectArray3, null);
                                            case "Array(4)":
                                                return this.output[2] > 0 ? (this.TextureConstructor = d, this.formatValues = s.erect3DArray4, null) : this.output[1] > 0 ? (this.TextureConstructor = p, this.formatValues = s.erect2DArray4, null) : (this.TextureConstructor = c, this.formatValues = s.erectArray4, null)
                                        }
                                    }
                                throw new Error(`unhandled return type "${this.returnType}"`)
                            }
                            getKernelString() {
                                throw new Error("abstract method call")
                            }
                            getMainResultTexture() {
                                switch (this.returnType) {
                                    case "LiteralInteger":
                                    case "Float":
                                    case "Integer":
                                    case "Number":
                                        return this.getMainResultNumberTexture();
                                    case "Array(2)":
                                        return this.getMainResultArray2Texture();
                                    case "Array(3)":
                                        return this.getMainResultArray3Texture();
                                    case "Array(4)":
                                        return this.getMainResultArray4Texture();
                                    default:
                                        throw new Error(`unhandled returnType type ${this.returnType}`)
                                }
                            }
                            getMainResultKernelNumberTexture() {
                                throw new Error("abstract method call")
                            }
                            getMainResultSubKernelNumberTexture() {
                                throw new Error("abstract method call")
                            }
                            getMainResultKernelArray2Texture() {
                                throw new Error("abstract method call")
                            }
                            getMainResultSubKernelArray2Texture() {
                                throw new Error("abstract method call")
                            }
                            getMainResultKernelArray3Texture() {
                                throw new Error("abstract method call")
                            }
                            getMainResultSubKernelArray3Texture() {
                                throw new Error("abstract method call")
                            }
                            getMainResultKernelArray4Texture() {
                                throw new Error("abstract method call")
                            }
                            getMainResultSubKernelArray4Texture() {
                                throw new Error("abstract method call")
                            }
                            getMainResultGraphical() {
                                throw new Error("abstract method call")
                            }
                            getMainResultMemoryOptimizedFloats() {
                                throw new Error("abstract method call")
                            }
                            getMainResultPackedPixels() {
                                throw new Error("abstract method call")
                            }
                            getMainResultString() {
                                return this.graphical ? this.getMainResultGraphical() : "single" === this.precision ? this.optimizeFloatMemory ? this.getMainResultMemoryOptimizedFloats() : this.getMainResultTexture() : this.getMainResultPackedPixels()
                            }
                            getMainResultNumberTexture() {
                                return s.linesToString(this.getMainResultKernelNumberTexture()) + s.linesToString(this.getMainResultSubKernelNumberTexture())
                            }
                            getMainResultArray2Texture() {
                                return s.linesToString(this.getMainResultKernelArray2Texture()) + s.linesToString(this.getMainResultSubKernelArray2Texture())
                            }
                            getMainResultArray3Texture() {
                                return s.linesToString(this.getMainResultKernelArray3Texture()) + s.linesToString(this.getMainResultSubKernelArray3Texture())
                            }
                            getMainResultArray4Texture() {
                                return s.linesToString(this.getMainResultKernelArray4Texture()) + s.linesToString(this.getMainResultSubKernelArray4Texture())
                            }
                            getFloatTacticDeclaration() {
                                return `precision ${this.getVariablePrecisionString(this.texSize,this.tactic)} float;\n`
                            }
                            getIntTacticDeclaration() {
                                return `precision ${this.getVariablePrecisionString(this.texSize,this.tactic,!0)} int;\n`
                            }
                            getSampler2DTacticDeclaration() {
                                return `precision ${this.getVariablePrecisionString(this.texSize,this.tactic)} sampler2D;\n`
                            }
                            getSampler2DArrayTacticDeclaration() {
                                return `precision ${this.getVariablePrecisionString(this.texSize,this.tactic)} sampler2DArray;\n`
                            }
                            renderTexture() {
                                return this.immutable ? this.texture.clone() : this.texture
                            }
                            readPackedPixelsToUint8Array() {
                                if ("unsigned" !== this.precision) throw new Error('Requires this.precision to be "unsigned"');
                                const {
                                    texSize: t,
                                    context: e
                                } = this, n = new Uint8Array(t[0] * t[1] * 4);
                                return e.readPixels(0, 0, t[0], t[1], e.RGBA, e.UNSIGNED_BYTE, n), n
                            }
                            readPackedPixelsToFloat32Array() {
                                return new Float32Array(this.readPackedPixelsToUint8Array().buffer)
                            }
                            readFloatPixelsToFloat32Array() {
                                if ("single" !== this.precision) throw new Error('Requires this.precision to be "single"');
                                const {
                                    texSize: t,
                                    context: e
                                } = this, n = t[0], i = t[1], s = new Float32Array(n * i * 4);
                                return e.readPixels(0, 0, n, i, e.RGBA, e.FLOAT, s), s
                            }
                            getPixels(t) {
                                const {
                                    context: e,
                                    output: n
                                } = this, [i, r] = n, a = new Uint8Array(i * r * 4);
                                return e.readPixels(0, 0, i, r, e.RGBA, e.UNSIGNED_BYTE, a), new Uint8ClampedArray((t ? a : s.flipPixels(a, i, r)).buffer)
                            }
                            renderKernelsToArrays() {
                                const t = {
                                    result: this.renderOutput()
                                };
                                for (let e = 0; e < this.subKernels.length; e++) t[this.subKernels[e].property] = this.mappedTextures[e].toArray();
                                return t
                            }
                            renderKernelsToTextures() {
                                const t = {
                                    result: this.renderOutput()
                                };
                                if (this.immutable)
                                    for (let e = 0; e < this.subKernels.length; e++) t[this.subKernels[e].property] = this.mappedTextures[e].clone();
                                else
                                    for (let e = 0; e < this.subKernels.length; e++) t[this.subKernels[e].property] = this.mappedTextures[e];
                                return t
                            }
                            resetSwitchingKernels() {
                                const t = this.switchingKernels;
                                return this.switchingKernels = null, t
                            }
                            setOutput(t) {
                                const e = this.toKernelOutput(t);
                                if (this.program) {
                                    if (!this.dynamicOutput) throw new Error("Resizing a kernel with dynamicOutput: false is not possible");
                                    const n = [e[0], e[1] || 1, e[2] || 1],
                                        i = s.getKernelTextureSize({
                                            optimizeFloatMemory: this.optimizeFloatMemory,
                                            precision: this.precision
                                        }, n),
                                        r = this.texSize;
                                    if (r) {
                                        const e = this.getVariablePrecisionString(r, this.tactic),
                                            n = this.getVariablePrecisionString(i, this.tactic);
                                        if (e !== n) return this.debug && console.warn("Precision requirement changed, asking GPU instance to recompile"), void this.switchKernels({
                                            type: "outputPrecisionMismatch",
                                            precision: n,
                                            needed: t
                                        })
                                    }
                                    this.output = e, this.threadDim = n, this.texSize = i;
                                    const {
                                        context: a
                                    } = this;
                                    if (a.bindFramebuffer(a.FRAMEBUFFER, this.framebuffer), this.updateMaxTexSize(), this.framebuffer.width = this.texSize[0], this.framebuffer.height = this.texSize[1], a.viewport(0, 0, this.maxTexSize[0], this.maxTexSize[1]), this.canvas.width = this.maxTexSize[0], this.canvas.height = this.maxTexSize[1], this.texture && this.texture.delete(), this.texture = null, this._setupOutputTexture(), this.mappedTextures && this.mappedTextures.length > 0) {
                                        for (let t = 0; t < this.mappedTextures.length; t++) this.mappedTextures[t].delete();
                                        this.mappedTextures = null, this._setupSubOutputTextures()
                                    }
                                } else this.output = e;
                                return this
                            }
                            renderValues() {
                                return this.formatValues(this.transferValues(), this.output[0], this.output[1], this.output[2])
                            }
                            switchKernels(t) {
                                this.switchingKernels ? this.switchingKernels.push(t) : this.switchingKernels = [t]
                            }
                            getVariablePrecisionString(t = this.texSize, e = this.tactic, n = !1) {
                                if (!e) {
                                    if (!this.constructor.features.isSpeedTacticSupported) return "highp";
                                    const e = this.constructor.features[n ? "lowIntPrecision" : "lowFloatPrecision"],
                                        i = this.constructor.features[n ? "mediumIntPrecision" : "mediumFloatPrecision"],
                                        s = this.constructor.features[n ? "highIntPrecision" : "highFloatPrecision"],
                                        r = Math.log2(t[0] * t[1]);
                                    if (r <= e.rangeMax) return "lowp";
                                    if (r <= i.rangeMax) return "mediump";
                                    if (r <= s.rangeMax) return "highp";
                                    throw new Error("The required size exceeds that of the ability of your system")
                                }
                                switch (e) {
                                    case "speed":
                                        return "lowp";
                                    case "balanced":
                                        return "mediump";
                                    case "precision":
                                        return "highp";
                                    default:
                                        throw new Error(`Unknown tactic "${e}" use "speed", "balanced", "precision", or empty for auto`)
                                }
                            }
                            updateTextureArgumentRefs(t, e) {
                                if (this.immutable)
                                    if (this.texture.texture === e.texture) {
                                        const {
                                            prevArg: n
                                        } = t;
                                        n && (1 === n.texture._refs && (this.texture.delete(), this.texture = n.clone(), this._textureSwitched = !0), n.delete()), t.prevArg = e.clone()
                                    } else if (this.mappedTextures && this.mappedTextures.length > 0) {
                                    const {
                                        mappedTextures: n
                                    } = this;
                                    for (let i = 0; i < n.length; i++) {
                                        const s = n[i];
                                        if (s.texture === e.texture) {
                                            const {
                                                prevArg: r
                                            } = t;
                                            return r && (1 === r.texture._refs && (s.delete(), n[i] = r.clone(), this._mappedTextureSwitched[i] = !0), r.delete()), void(t.prevArg = e.clone())
                                        }
                                    }
                                }
                            }
                            onActivate(t) {
                                if (this._textureSwitched = !0, this.texture = t.texture, this.mappedTextures) {
                                    for (let t = 0; t < this.mappedTextures.length; t++) this._mappedTextureSwitched[t] = !0;
                                    this.mappedTextures = t.mappedTextures
                                }
                            }
                            initCanvas() {}
                        }
                    }
                }, {
                    "../../utils": 114,
                    "../kernel": 36,
                    "./texture/array-2-float": 16,
                    "./texture/array-2-float-2d": 14,
                    "./texture/array-2-float-3d": 15,
                    "./texture/array-3-float": 19,
                    "./texture/array-3-float-2d": 17,
                    "./texture/array-3-float-3d": 18,
                    "./texture/array-4-float": 22,
                    "./texture/array-4-float-2d": 20,
                    "./texture/array-4-float-3d": 21,
                    "./texture/float": 25,
                    "./texture/float-2d": 23,
                    "./texture/float-3d": 24,
                    "./texture/graphical": 26,
                    "./texture/memory-optimized": 30,
                    "./texture/memory-optimized-2d": 28,
                    "./texture/memory-optimized-3d": 29,
                    "./texture/unsigned": 33,
                    "./texture/unsigned-2d": 31,
                    "./texture/unsigned-3d": 32
                }],
                14: [function(t, e, n) {
                    const {
                        utils: i
                    } = t("../../../utils"), {
                        GLTextureFloat: s
                    } = t("./float");
                    e.exports = {
                        GLTextureArray2Float2D: class extends s {
                            constructor(t) {
                                super(t), this.type = "ArrayTexture(2)"
                            }
                            toArray() {
                                return i.erect2DArray2(this.renderValues(), this.output[0], this.output[1])
                            }
                        }
                    }
                }, {
                    "../../../utils": 114,
                    "./float": 25
                }],
                15: [function(t, e, n) {
                    const {
                        utils: i
                    } = t("../../../utils"), {
                        GLTextureFloat: s
                    } = t("./float");
                    e.exports = {
                        GLTextureArray2Float3D: class extends s {
                            constructor(t) {
                                super(t), this.type = "ArrayTexture(2)"
                            }
                            toArray() {
                                return i.erect3DArray2(this.renderValues(), this.output[0], this.output[1], this.output[2])
                            }
                        }
                    }
                }, {
                    "../../../utils": 114,
                    "./float": 25
                }],
                16: [function(t, e, n) {
                    const {
                        utils: i
                    } = t("../../../utils"), {
                        GLTextureFloat: s
                    } = t("./float");
                    e.exports = {
                        GLTextureArray2Float: class extends s {
                            constructor(t) {
                                super(t), this.type = "ArrayTexture(2)"
                            }
                            toArray() {
                                return i.erectArray2(this.renderValues(), this.output[0], this.output[1])
                            }
                        }
                    }
                }, {
                    "../../../utils": 114,
                    "./float": 25
                }],
                17: [function(t, e, n) {
                    const {
                        utils: i
                    } = t("../../../utils"), {
                        GLTextureFloat: s
                    } = t("./float");
                    e.exports = {
                        GLTextureArray3Float2D: class extends s {
                            constructor(t) {
                                super(t), this.type = "ArrayTexture(3)"
                            }
                            toArray() {
                                return i.erect2DArray3(this.renderValues(), this.output[0], this.output[1])
                            }
                        }
                    }
                }, {
                    "../../../utils": 114,
                    "./float": 25
                }],
                18: [function(t, e, n) {
                    const {
                        utils: i
                    } = t("../../../utils"), {
                        GLTextureFloat: s
                    } = t("./float");
                    e.exports = {
                        GLTextureArray3Float3D: class extends s {
                            constructor(t) {
                                super(t), this.type = "ArrayTexture(3)"
                            }
                            toArray() {
                                return i.erect3DArray3(this.renderValues(), this.output[0], this.output[1], this.output[2])
                            }
                        }
                    }
                }, {
                    "../../../utils": 114,
                    "./float": 25
                }],
                19: [function(t, e, n) {
                    const {
                        utils: i
                    } = t("../../../utils"), {
                        GLTextureFloat: s
                    } = t("./float");
                    e.exports = {
                        GLTextureArray3Float: class extends s {
                            constructor(t) {
                                super(t), this.type = "ArrayTexture(3)"
                            }
                            toArray() {
                                return i.erectArray3(this.renderValues(), this.output[0])
                            }
                        }
                    }
                }, {
                    "../../../utils": 114,
                    "./float": 25
                }],
                20: [function(t, e, n) {
                    const {
                        utils: i
                    } = t("../../../utils"), {
                        GLTextureFloat: s
                    } = t("./float");
                    e.exports = {
                        GLTextureArray4Float2D: class extends s {
                            constructor(t) {
                                super(t), this.type = "ArrayTexture(4)"
                            }
                            toArray() {
                                return i.erect2DArray4(this.renderValues(), this.output[0], this.output[1])
                            }
                        }
                    }
                }, {
                    "../../../utils": 114,
                    "./float": 25
                }],
                21: [function(t, e, n) {
                    const {
                        utils: i
                    } = t("../../../utils"), {
                        GLTextureFloat: s
                    } = t("./float");
                    e.exports = {
                        GLTextureArray4Float3D: class extends s {
                            constructor(t) {
                                super(t), this.type = "ArrayTexture(4)"
                            }
                            toArray() {
                                return i.erect3DArray4(this.renderValues(), this.output[0], this.output[1], this.output[2])
                            }
                        }
                    }
                }, {
                    "../../../utils": 114,
                    "./float": 25
                }],
                22: [function(t, e, n) {
                    const {
                        utils: i
                    } = t("../../../utils"), {
                        GLTextureFloat: s
                    } = t("./float");
                    e.exports = {
                        GLTextureArray4Float: class extends s {
                            constructor(t) {
                                super(t), this.type = "ArrayTexture(4)"
                            }
                            toArray() {
                                return i.erectArray4(this.renderValues(), this.output[0])
                            }
                        }
                    }
                }, {
                    "../../../utils": 114,
                    "./float": 25
                }],
                23: [function(t, e, n) {
                    const {
                        utils: i
                    } = t("../../../utils"), {
                        GLTextureFloat: s
                    } = t("./float");
                    e.exports = {
                        GLTextureFloat2D: class extends s {
                            constructor(t) {
                                super(t), this.type = "ArrayTexture(1)"
                            }
                            toArray() {
                                return i.erect2DFloat(this.renderValues(), this.output[0], this.output[1])
                            }
                        }
                    }
                }, {
                    "../../../utils": 114,
                    "./float": 25
                }],
                24: [function(t, e, n) {
                    const {
                        utils: i
                    } = t("../../../utils"), {
                        GLTextureFloat: s
                    } = t("./float");
                    e.exports = {
                        GLTextureFloat3D: class extends s {
                            constructor(t) {
                                super(t), this.type = "ArrayTexture(1)"
                            }
                            toArray() {
                                return i.erect3DFloat(this.renderValues(), this.output[0], this.output[1], this.output[2])
                            }
                        }
                    }
                }, {
                    "../../../utils": 114,
                    "./float": 25
                }],
                25: [function(t, e, n) {
                    const {
                        utils: i
                    } = t("../../../utils"), {
                        GLTexture: s
                    } = t("./index");
                    e.exports = {
                        GLTextureFloat: class extends s {
                            get textureType() {
                                return this.context.FLOAT
                            }
                            constructor(t) {
                                super(t), this.type = "ArrayTexture(1)"
                            }
                            renderRawOutput() {
                                const t = this.context,
                                    e = this.size;
                                t.bindFramebuffer(t.FRAMEBUFFER, this.framebuffer()), t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, this.texture, 0);
                                const n = new Float32Array(e[0] * e[1] * 4);
                                return t.readPixels(0, 0, e[0], e[1], t.RGBA, t.FLOAT, n), n
                            }
                            renderValues() {
                                return this._deleted ? null : this.renderRawOutput()
                            }
                            toArray() {
                                return i.erectFloat(this.renderValues(), this.output[0])
                            }
                        }
                    }
                }, {
                    "../../../utils": 114,
                    "./index": 27
                }],
                26: [function(t, e, n) {
                    const {
                        GLTextureUnsigned: i
                    } = t("./unsigned");
                    e.exports = {
                        GLTextureGraphical: class extends i {
                            constructor(t) {
                                super(t), this.type = "ArrayTexture(4)"
                            }
                            toArray() {
                                return this.renderValues()
                            }
                        }
                    }
                }, {
                    "./unsigned": 33
                }],
                27: [function(t, e, n) {
                    const {
                        Texture: i
                    } = t("../../../texture");

                    function s(t, e) {
                        t.activeTexture(t.TEXTURE15), t.bindTexture(t.TEXTURE_2D, e), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.NEAREST), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t.NEAREST)
                    }
                    e.exports = {
                        GLTexture: class extends i {
                            get textureType() {
                                throw new Error(`"textureType" not implemented on ${this.name}`)
                            }
                            clone() {
                                return new this.constructor(this)
                            }
                            beforeMutate() {
                                return this.texture._refs > 1 && (this.newTexture(), !0)
                            }
                            cloneTexture() {
                                this.texture._refs--;
                                const {
                                    context: t,
                                    size: e,
                                    texture: n,
                                    kernel: i
                                } = this;
                                i.debug && console.warn("cloning internal texture"), t.bindFramebuffer(t.FRAMEBUFFER, this.framebuffer()), s(t, n), t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, n, 0);
                                const r = t.createTexture();
                                s(t, r), t.texImage2D(t.TEXTURE_2D, 0, this.internalFormat, e[0], e[1], 0, this.textureFormat, this.textureType, null), t.copyTexSubImage2D(t.TEXTURE_2D, 0, 0, 0, 0, 0, e[0], e[1]), r._refs = 1, this.texture = r
                            }
                            newTexture() {
                                this.texture._refs--;
                                const t = this.context,
                                    e = this.size;
                                this.kernel.debug && console.warn("new internal texture");
                                const n = t.createTexture();
                                s(t, n), t.texImage2D(t.TEXTURE_2D, 0, this.internalFormat, e[0], e[1], 0, this.textureFormat, this.textureType, null), n._refs = 1, this.texture = n
                            }
                            clear() {
                                if (this.texture._refs) {
                                    this.texture._refs--;
                                    const t = this.context,
                                        e = this.texture = t.createTexture();
                                    s(t, e);
                                    const n = this.size;
                                    e._refs = 1, t.texImage2D(t.TEXTURE_2D, 0, this.internalFormat, n[0], n[1], 0, this.textureFormat, this.textureType, null)
                                }
                                const {
                                    context: t,
                                    texture: e
                                } = this;
                                t.bindFramebuffer(t.FRAMEBUFFER, this.framebuffer()), t.bindTexture(t.TEXTURE_2D, e), s(t, e), t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, e, 0), t.clearColor(0, 0, 0, 0), t.clear(t.COLOR_BUFFER_BIT | t.DEPTH_BUFFER_BIT)
                            }
                            delete() {
                                this._deleted || (this._deleted = !0, this.texture._refs && (this.texture._refs--, this.texture._refs) || this.context.deleteTexture(this.texture))
                            }
                            framebuffer() {
                                return this._framebuffer || (this._framebuffer = this.kernel.getRawValueFramebuffer(this.size[0], this.size[1])), this._framebuffer
                            }
                        }
                    }
                }, {
                    "../../../texture": 113
                }],
                28: [function(t, e, n) {
                    const {
                        utils: i
                    } = t("../../../utils"), {
                        GLTextureFloat: s
                    } = t("./float");
                    e.exports = {
                        GLTextureMemoryOptimized2D: class extends s {
                            constructor(t) {
                                super(t), this.type = "MemoryOptimizedNumberTexture"
                            }
                            toArray() {
                                return i.erectMemoryOptimized2DFloat(this.renderValues(), this.output[0], this.output[1])
                            }
                        }
                    }
                }, {
                    "../../../utils": 114,
                    "./float": 25
                }],
                29: [function(t, e, n) {
                    const {
                        utils: i
                    } = t("../../../utils"), {
                        GLTextureFloat: s
                    } = t("./float");
                    e.exports = {
                        GLTextureMemoryOptimized3D: class extends s {
                            constructor(t) {
                                super(t), this.type = "MemoryOptimizedNumberTexture"
                            }
                            toArray() {
                                return i.erectMemoryOptimized3DFloat(this.renderValues(), this.output[0], this.output[1], this.output[2])
                            }
                        }
                    }
                }, {
                    "../../../utils": 114,
                    "./float": 25
                }],
                30: [function(t, e, n) {
                    const {
                        utils: i
                    } = t("../../../utils"), {
                        GLTextureFloat: s
                    } = t("./float");
                    e.exports = {
                        GLTextureMemoryOptimized: class extends s {
                            constructor(t) {
                                super(t), this.type = "MemoryOptimizedNumberTexture"
                            }
                            toArray() {
                                return i.erectMemoryOptimizedFloat(this.renderValues(), this.output[0])
                            }
                        }
                    }
                }, {
                    "../../../utils": 114,
                    "./float": 25
                }],
                31: [function(t, e, n) {
                    const {
                        utils: i
                    } = t("../../../utils"), {
                        GLTextureUnsigned: s
                    } = t("./unsigned");
                    e.exports = {
                        GLTextureUnsigned2D: class extends s {
                            constructor(t) {
                                super(t), this.type = "NumberTexture"
                            }
                            toArray() {
                                return i.erect2DPackedFloat(this.renderValues(), this.output[0], this.output[1])
                            }
                        }
                    }
                }, {
                    "../../../utils": 114,
                    "./unsigned": 33
                }],
                32: [function(t, e, n) {
                    const {
                        utils: i
                    } = t("../../../utils"), {
                        GLTextureUnsigned: s
                    } = t("./unsigned");
                    e.exports = {
                        GLTextureUnsigned3D: class extends s {
                            constructor(t) {
                                super(t), this.type = "NumberTexture"
                            }
                            toArray() {
                                return i.erect3DPackedFloat(this.renderValues(), this.output[0], this.output[1], this.output[2])
                            }
                        }
                    }
                }, {
                    "../../../utils": 114,
                    "./unsigned": 33
                }],
                33: [function(t, e, n) {
                    const {
                        utils: i
                    } = t("../../../utils"), {
                        GLTexture: s
                    } = t("./index");
                    e.exports = {
                        GLTextureUnsigned: class extends s {
                            get textureType() {
                                return this.context.UNSIGNED_BYTE
                            }
                            constructor(t) {
                                super(t), this.type = "NumberTexture"
                            }
                            renderRawOutput() {
                                const {
                                    context: t
                                } = this;
                                t.bindFramebuffer(t.FRAMEBUFFER, this.framebuffer()), t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, this.texture, 0);
                                const e = new Uint8Array(this.size[0] * this.size[1] * 4);
                                return t.readPixels(0, 0, this.size[0], this.size[1], t.RGBA, t.UNSIGNED_BYTE, e), e
                            }
                            renderValues() {
                                return this._deleted ? null : new Float32Array(this.renderRawOutput().buffer)
                            }
                            toArray() {
                                return i.erectPackedFloat(this.renderValues(), this.output[0])
                            }
                        }
                    }
                }, {
                    "../../../utils": 114,
                    "./index": 27
                }],
                34: [function(t, e, n) {
                    const i = t("gl"),
                        {
                            WebGLKernel: s
                        } = t("../web-gl/kernel"),
                        {
                            glKernelString: r
                        } = t("../gl/kernel-string");
                    let a = null,
                        o = null,
                        u = null,
                        h = null,
                        l = null;
                    e.exports = {
                        HeadlessGLKernel: class extends s {
                            static get isSupported() {
                                return null !== a || (this.setupFeatureChecks(), a = null !== u), a
                            }
                            static setupFeatureChecks() {
                                if (o = null, h = null, "function" == typeof i) try {
                                    if (u = i(2, 2, {
                                            preserveDrawingBuffer: !0
                                        }), !u || !u.getExtension) return;
                                    h = {
                                        STACKGL_resize_drawingbuffer: u.getExtension("STACKGL_resize_drawingbuffer"),
                                        STACKGL_destroy_context: u.getExtension("STACKGL_destroy_context"),
                                        OES_texture_float: u.getExtension("OES_texture_float"),
                                        OES_texture_float_linear: u.getExtension("OES_texture_float_linear"),
                                        OES_element_index_uint: u.getExtension("OES_element_index_uint"),
                                        WEBGL_draw_buffers: u.getExtension("WEBGL_draw_buffers"),
                                        WEBGL_color_buffer_float: u.getExtension("WEBGL_color_buffer_float")
                                    }, l = this.getFeatures()
                                } catch (t) {
                                    console.warn(t)
                                }
                            }
                            static isContextMatch(t) {
                                try {
                                    return "ANGLE" === t.getParameter(t.RENDERER)
                                } catch (t) {
                                    return !1
                                }
                            }
                            static getIsTextureFloat() {
                                return Boolean(h.OES_texture_float)
                            }
                            static getIsDrawBuffers() {
                                return Boolean(h.WEBGL_draw_buffers)
                            }
                            static getChannelCount() {
                                return h.WEBGL_draw_buffers ? u.getParameter(h.WEBGL_draw_buffers.MAX_DRAW_BUFFERS_WEBGL) : 1
                            }
                            static getMaxTextureSize() {
                                return u.getParameter(u.MAX_TEXTURE_SIZE)
                            }
                            static get testCanvas() {
                                return o
                            }
                            static get testContext() {
                                return u
                            }
                            static get features() {
                                return l
                            }
                            initCanvas() {
                                return {}
                            }
                            initContext() {
                                return i(2, 2, {
                                    preserveDrawingBuffer: !0
                                })
                            }
                            initExtensions() {
                                this.extensions = {
                                    STACKGL_resize_drawingbuffer: this.context.getExtension("STACKGL_resize_drawingbuffer"),
                                    STACKGL_destroy_context: this.context.getExtension("STACKGL_destroy_context"),
                                    OES_texture_float: this.context.getExtension("OES_texture_float"),
                                    OES_texture_float_linear: this.context.getExtension("OES_texture_float_linear"),
                                    OES_element_index_uint: this.context.getExtension("OES_element_index_uint"),
                                    WEBGL_draw_buffers: this.context.getExtension("WEBGL_draw_buffers")
                                }
                            }
                            build() {
                                super.build.apply(this, arguments), this.fallbackRequested || this.extensions.STACKGL_resize_drawingbuffer.resize(this.maxTexSize[0], this.maxTexSize[1])
                            }
                            destroyExtensions() {
                                this.extensions.STACKGL_resize_drawingbuffer = null, this.extensions.STACKGL_destroy_context = null, this.extensions.OES_texture_float = null, this.extensions.OES_texture_float_linear = null, this.extensions.OES_element_index_uint = null, this.extensions.WEBGL_draw_buffers = null
                            }
                            static destroyContext(t) {
                                const e = t.getExtension("STACKGL_destroy_context");
                                e && e.destroy && e.destroy()
                            }
                            toString() {
                                return r(this.constructor, arguments, this, "const gl = context || require('gl')(1, 1);\n", "    if (!context) { gl.getExtension('STACKGL_destroy_context').destroy(); }\n")
                            }
                            setOutput(t) {
                                return super.setOutput(t), this.graphical && this.extensions.STACKGL_resize_drawingbuffer && this.extensions.STACKGL_resize_drawingbuffer.resize(this.maxTexSize[0], this.maxTexSize[1]), this
                            }
                        }
                    }
                }, {
                    "../gl/kernel-string": 12,
                    "../web-gl/kernel": 70,
                    gl: 2
                }],
                35: [function(t, e, n) {
                    e.exports = {
                        KernelValue: class {
                            constructor(t, e) {
                                const {
                                    name: n,
                                    kernel: i,
                                    context: s,
                                    checkContext: r,
                                    onRequestContextHandle: a,
                                    onUpdateValueMismatch: o,
                                    origin: u,
                                    strictIntegers: h,
                                    type: l,
                                    tactic: c
                                } = e;
                                if (!n) throw new Error("name not set");
                                if (!l) throw new Error("type not set");
                                if (!u) throw new Error("origin not set");
                                if ("user" !== u && "constants" !== u) throw new Error(`origin must be "user" or "constants" value is "${u}"`);
                                if (!a) throw new Error("onRequestContextHandle is not set");
                                this.name = n, this.origin = u, this.tactic = c, this.varName = "constants" === u ? `constants.${n}` : n, this.kernel = i, this.strictIntegers = h, this.type = t.type || l, this.size = t.size || null, this.index = null, this.context = s, this.checkContext = null == r || r, this.contextHandle = null, this.onRequestContextHandle = a, this.onUpdateValueMismatch = o, this.forceUploadEachRun = null
                            }
                            get id() {
                                return `${this.origin}_${name}`
                            }
                            getSource() {
                                throw new Error(`"getSource" not defined on ${this.constructor.name}`)
                            }
                            updateValue(t) {
                                throw new Error(`"updateValue" not defined on ${this.constructor.name}`)
                            }
                        }
                    }
                }, {}],
                36: [function(t, e, n) {
                    const {
                        utils: i
                    } = t("../utils"), {
                        Input: s
                    } = t("../input");
                    e.exports = {
                        Kernel: class {
                            static get isSupported() {
                                throw new Error(`"isSupported" not implemented on ${this.name}`)
                            }
                            static isContextMatch(t) {
                                throw new Error(`"isContextMatch" not implemented on ${this.name}`)
                            }
                            static getFeatures() {
                                throw new Error(`"getFeatures" not implemented on ${this.name}`)
                            }
                            static destroyContext(t) {
                                throw new Error(`"destroyContext" called on ${this.name}`)
                            }
                            static nativeFunctionArguments() {
                                throw new Error(`"nativeFunctionArguments" called on ${this.name}`)
                            }
                            static nativeFunctionReturnType() {
                                throw new Error(`"nativeFunctionReturnType" called on ${this.name}`)
                            }
                            static combineKernels() {
                                throw new Error(`"combineKernels" called on ${this.name}`)
                            }
                            constructor(t, e) {
                                if ("object" != typeof t) {
                                    if ("string" != typeof t) throw new Error("source not a string");
                                    if (!i.isFunctionString(t)) throw new Error("source not a function string")
                                }
                                this.useLegacyEncoder = !1, this.fallbackRequested = !1, this.onRequestFallback = null, this.argumentNames = "string" == typeof t ? i.getArgumentNamesFromString(t) : null, this.argumentTypes = null, this.argumentSizes = null, this.argumentBitRatios = null, this.kernelArguments = null, this.kernelConstants = null, this.forceUploadKernelConstants = null, this.source = t, this.output = null, this.debug = !1, this.graphical = !1, this.loopMaxIterations = 0, this.constants = null, this.constantTypes = null, this.constantBitRatios = null, this.dynamicArguments = !1, this.dynamicOutput = !1, this.canvas = null, this.context = null, this.checkContext = null, this.gpu = null, this.functions = null, this.nativeFunctions = null, this.injectedNative = null, this.subKernels = null, this.validate = !0, this.immutable = !1, this.pipeline = !1, this.precision = null, this.tactic = null, this.plugins = null, this.returnType = null, this.leadingReturnStatement = null, this.followingReturnStatement = null, this.optimizeFloatMemory = null, this.strictIntegers = !1, this.fixIntegerDivisionAccuracy = null, this.built = !1, this.signature = null
                            }
                            mergeSettings(t) {
                                for (let e in t)
                                    if (t.hasOwnProperty(e) && this.hasOwnProperty(e)) {
                                        switch (e) {
                                            case "output":
                                                if (!Array.isArray(t.output)) {
                                                    this.setOutput(t.output);
                                                    continue
                                                }
                                                break;
                                            case "functions":
                                                this.functions = [];
                                                for (let e = 0; e < t.functions.length; e++) this.addFunction(t.functions[e]);
                                                continue;
                                            case "graphical":
                                                t[e] && !t.hasOwnProperty("precision") && (this.precision = "unsigned"), this[e] = t[e];
                                                continue;
                                            case "nativeFunctions":
                                                if (!t.nativeFunctions) continue;
                                                this.nativeFunctions = [];
                                                for (let e = 0; e < t.nativeFunctions.length; e++) {
                                                    const n = t.nativeFunctions[e],
                                                        {
                                                            name: i,
                                                            source: s
                                                        } = n;
                                                    this.addNativeFunction(i, s, n)
                                                }
                                                continue
                                        }
                                        this[e] = t[e]
                                    } this.canvas || (this.canvas = this.initCanvas()), this.context || (this.context = this.initContext()), this.plugins || (this.plugins = this.initPlugins(t))
                            }
                            build() {
                                throw new Error(`"build" not defined on ${this.constructor.name}`)
                            }
                            run() {
                                throw new Error(`"run" not defined on ${this.constructor.name}`)
                            }
                            initCanvas() {
                                throw new Error(`"initCanvas" not defined on ${this.constructor.name}`)
                            }
                            initContext() {
                                throw new Error(`"initContext" not defined on ${this.constructor.name}`)
                            }
                            initPlugins(t) {
                                throw new Error(`"initPlugins" not defined on ${this.constructor.name}`)
                            }
                            addFunction(t, e = {}) {
                                if (t.name && t.source && t.argumentTypes && "returnType" in t) this.functions.push(t);
                                else if ("settings" in t && "source" in t) this.functions.push(this.functionToIGPUFunction(t.source, t.settings));
                                else {
                                    if ("string" != typeof t && "function" != typeof t) throw new Error("function not properly defined");
                                    this.functions.push(this.functionToIGPUFunction(t, e))
                                }
                                return this
                            }
                            addNativeFunction(t, e, n = {}) {
                                const {
                                    argumentTypes: i,
                                    argumentNames: s
                                } = n.argumentTypes ? function(t) {
                                    const e = Object.keys(t),
                                        n = [];
                                    for (let i = 0; i < e.length; i++) {
                                        const s = e[i];
                                        n.push(t[s])
                                    }
                                    return {
                                        argumentTypes: n,
                                        argumentNames: e
                                    }
                                }(n.argumentTypes) : this.constructor.nativeFunctionArguments(e) || {};
                                return this.nativeFunctions.push({
                                    name: t,
                                    source: e,
                                    settings: n,
                                    argumentTypes: i,
                                    argumentNames: s,
                                    returnType: n.returnType || this.constructor.nativeFunctionReturnType(e)
                                }), this
                            }
                            setupArguments(t) {
                                if (this.kernelArguments = [], this.argumentTypes)
                                    for (let t = 0; t < this.argumentTypes.length; t++) this.kernelArguments.push({
                                        type: this.argumentTypes[t]
                                    });
                                else if (!this.argumentTypes) {
                                    this.argumentTypes = [];
                                    for (let e = 0; e < t.length; e++) {
                                        const n = i.getVariableType(t[e], this.strictIntegers),
                                            s = "Integer" === n ? "Number" : n;
                                        this.argumentTypes.push(s), this.kernelArguments.push({
                                            type: s
                                        })
                                    }
                                }
                                this.argumentSizes = new Array(t.length), this.argumentBitRatios = new Int32Array(t.length);
                                for (let e = 0; e < t.length; e++) {
                                    const n = t[e];
                                    this.argumentSizes[e] = n.constructor === s ? n.size : null, this.argumentBitRatios[e] = this.getBitRatio(n)
                                }
                                if (this.argumentNames.length !== t.length) throw new Error("arguments are miss-aligned")
                            }
                            setupConstants() {
                                this.kernelConstants = [];
                                let t = null === this.constantTypes;
                                if (t && (this.constantTypes = {}), this.constantBitRatios = {}, this.constants)
                                    for (let e in this.constants) {
                                        if (t) {
                                            const t = i.getVariableType(this.constants[e], this.strictIntegers);
                                            this.constantTypes[e] = t, this.kernelConstants.push({
                                                name: e,
                                                type: t
                                            })
                                        } else this.kernelConstants.push({
                                            name: e,
                                            type: this.constantTypes[e]
                                        });
                                        this.constantBitRatios[e] = this.getBitRatio(this.constants[e])
                                    }
                            }
                            setOptimizeFloatMemory(t) {
                                return this.optimizeFloatMemory = t, this
                            }
                            toKernelOutput(t) {
                                return t.hasOwnProperty("x") ? t.hasOwnProperty("y") ? t.hasOwnProperty("z") ? [t.x, t.y, t.z] : [t.x, t.y] : [t.x] : t
                            }
                            setOutput(t) {
                                return this.output = this.toKernelOutput(t), this
                            }
                            setDebug(t) {
                                return this.debug = t, this
                            }
                            setGraphical(t) {
                                return this.graphical = t, this.precision = "unsigned", this
                            }
                            setLoopMaxIterations(t) {
                                return this.loopMaxIterations = t, this
                            }
                            setConstants(t) {
                                return this.constants = t, this
                            }
                            setConstantTypes(t) {
                                return this.constantTypes = t, this
                            }
                            setFunctions(t) {
                                for (let e = 0; e < t.length; e++) this.addFunction(t[e]);
                                return this
                            }
                            setNativeFunctions(t) {
                                for (let e = 0; e < t.length; e++) {
                                    const n = t[e],
                                        {
                                            name: i,
                                            source: s
                                        } = n;
                                    this.addNativeFunction(i, s, n)
                                }
                                return this
                            }
                            setInjectedNative(t) {
                                return this.injectedNative = t, this
                            }
                            setPipeline(t) {
                                return this.pipeline = t, this
                            }
                            setPrecision(t) {
                                return this.precision = t, this
                            }
                            setDimensions(t) {
                                return i.warnDeprecated("method", "setDimensions", "setOutput"), this.output = t, this
                            }
                            setOutputToTexture(t) {
                                return i.warnDeprecated("method", "setOutputToTexture", "setPipeline"), this.pipeline = t, this
                            }
                            setImmutable(t) {
                                return this.immutable = t, this
                            }
                            setCanvas(t) {
                                return this.canvas = t, this
                            }
                            setStrictIntegers(t) {
                                return this.strictIntegers = t, this
                            }
                            setDynamicOutput(t) {
                                return this.dynamicOutput = t, this
                            }
                            setHardcodeConstants(t) {
                                return i.warnDeprecated("method", "setHardcodeConstants"), this.setDynamicOutput(t), this.setDynamicArguments(t), this
                            }
                            setDynamicArguments(t) {
                                return this.dynamicArguments = t, this
                            }
                            setUseLegacyEncoder(t) {
                                return this.useLegacyEncoder = t, this
                            }
                            setWarnVarUsage(t) {
                                return i.warnDeprecated("method", "setWarnVarUsage"), this
                            }
                            getCanvas() {
                                return i.warnDeprecated("method", "getCanvas"), this.canvas
                            }
                            getWebGl() {
                                return i.warnDeprecated("method", "getWebGl"), this.context
                            }
                            setContext(t) {
                                return this.context = t, this
                            }
                            setArgumentTypes(t) {
                                if (Array.isArray(t)) this.argumentTypes = t;
                                else {
                                    this.argumentTypes = [];
                                    for (const e in t) {
                                        if (!t.hasOwnProperty(e)) continue;
                                        const n = this.argumentNames.indexOf(e);
                                        if (-1 === n) throw new Error(`unable to find argument ${e}`);
                                        this.argumentTypes[n] = t[e]
                                    }
                                }
                                return this
                            }
                            setTactic(t) {
                                return this.tactic = t, this
                            }
                            requestFallback(t) {
                                if (!this.onRequestFallback) throw new Error(`"onRequestFallback" not defined on ${this.constructor.name}`);
                                return this.fallbackRequested = !0, this.onRequestFallback(t)
                            }
                            validateSettings() {
                                throw new Error(`"validateSettings" not defined on ${this.constructor.name}`)
                            }
                            addSubKernel(t) {
                                if (null === this.subKernels && (this.subKernels = []), !t.source) throw new Error('subKernel missing "source" property');
                                if (!t.property && isNaN(t.property)) throw new Error('subKernel missing "property" property');
                                if (!t.name) throw new Error('subKernel missing "name" property');
                                return this.subKernels.push(t), this
                            }
                            destroy(t) {
                                throw new Error(`"destroy" called on ${this.constructor.name}`)
                            }
                            getBitRatio(t) {
                                if ("single" === this.precision) return 4;
                                if (Array.isArray(t[0])) return this.getBitRatio(t[0]);
                                if (t.constructor === s) return this.getBitRatio(t.value);
                                switch (t.constructor) {
                                    case Uint8ClampedArray:
                                    case Uint8Array:
                                    case Int8Array:
                                        return 1;
                                    case Uint16Array:
                                    case Int16Array:
                                        return 2;
                                    case Float32Array:
                                    case Int32Array:
                                    default:
                                        return 4
                                }
                            }
                            getPixels(t) {
                                throw new Error(`"getPixels" called on ${this.constructor.name}`)
                            }
                            checkOutput() {
                                if (!this.output || !i.isArray(this.output)) throw new Error("kernel.output not an array");
                                if (this.output.length < 1) throw new Error("kernel.output is empty, needs at least 1 value");
                                for (let t = 0; t < this.output.length; t++)
                                    if (isNaN(this.output[t]) || this.output[t] < 1) throw new Error(`${this.constructor.name}.output[${t}] incorrectly defined as \`${this.output[t]}\`, needs to be numeric, and greater than 0`)
                            }
                            prependString(t) {
                                throw new Error(`"prependString" called on ${this.constructor.name}`)
                            }
                            hasPrependString(t) {
                                throw new Error(`"hasPrependString" called on ${this.constructor.name}`)
                            }
                            toJSON() {
                                return {
                                    settings: {
                                        output: this.output,
                                        pipeline: this.pipeline,
                                        argumentNames: this.argumentNames,
                                        argumentsTypes: this.argumentTypes,
                                        constants: this.constants,
                                        pluginNames: this.plugins ? this.plugins.map((t => t.name)) : null,
                                        returnType: this.returnType
                                    }
                                }
                            }
                            buildSignature(t) {
                                const e = this.constructor;
                                this.signature = e.getSignature(this, e.getArgumentTypes(this, t))
                            }
                            static getArgumentTypes(t, e) {
                                const n = new Array(e.length);
                                for (let s = 0; s < e.length; s++) {
                                    const r = e[s],
                                        a = t.argumentTypes[s];
                                    if (r.type) n[s] = r.type;
                                    else switch (a) {
                                        case "Number":
                                        case "Integer":
                                        case "Float":
                                        case "ArrayTexture(1)":
                                            n[s] = i.getVariableType(r);
                                            break;
                                        default:
                                            n[s] = a
                                    }
                                }
                                return n
                            }
                            static getSignature(t, e) {
                                throw new Error(`"getSignature" not implemented on ${this.name}`)
                            }
                            functionToIGPUFunction(t, e = {}) {
                                if ("string" != typeof t && "function" != typeof t) throw new Error("source not a string or function");
                                const n = "string" == typeof t ? t : t.toString();
                                let s = [];
                                return s = Array.isArray(e.argumentTypes) ? e.argumentTypes : "object" == typeof e.argumentTypes ? i.getArgumentNamesFromString(n).map((t => e.argumentTypes[t])) || [] : e.argumentTypes || [], {
                                    name: i.getFunctionNameFromString(n) || null,
                                    source: n,
                                    argumentTypes: s,
                                    returnType: e.returnType || null
                                }
                            }
                            onActivate(t) {}
                        }
                    }
                }, {
                    "../input": 110,
                    "../utils": 114
                }],
                37: [function(t, e, n) {
                    const i = `__HEADER__;\n__FLOAT_TACTIC_DECLARATION__;\n__INT_TACTIC_DECLARATION__;\n__SAMPLER_2D_TACTIC_DECLARATION__;\n\nconst int LOOP_MAX = __LOOP_MAX__;\n\n__PLUGINS__;\n__CONSTANTS__;\n\nvarying vec2 vTexCoord;\n\nfloat acosh(float x) {\n  return log(x + sqrt(x * x - 1.0));\n}\n\nfloat sinh(float x) {\n  return (pow(${Math.E}, x) - pow(${Math.E}, -x)) / 2.0;\n}\n\nfloat asinh(float x) {\n  return log(x + sqrt(x * x + 1.0));\n}\n\nfloat atan2(float v1, float v2) {\n  if (v1 == 0.0 || v2 == 0.0) return 0.0;\n  return atan(v1 / v2);\n}\n\nfloat atanh(float x) {\n  x = (x + 1.0) / (x - 1.0);\n  if (x < 0.0) {\n    return 0.5 * log(-x);\n  }\n  return 0.5 * log(x);\n}\n\nfloat cbrt(float x) {\n  if (x >= 0.0) {\n    return pow(x, 1.0 / 3.0);\n  } else {\n    return -pow(x, 1.0 / 3.0);\n  }\n}\n\nfloat cosh(float x) {\n  return (pow(${Math.E}, x) + pow(${Math.E}, -x)) / 2.0; \n}\n\nfloat expm1(float x) {\n  return pow(${Math.E}, x) - 1.0; \n}\n\nfloat fround(highp float x) {\n  return x;\n}\n\nfloat imul(float v1, float v2) {\n  return float(int(v1) * int(v2));\n}\n\nfloat log10(float x) {\n  return log2(x) * (1.0 / log2(10.0));\n}\n\nfloat log1p(float x) {\n  return log(1.0 + x);\n}\n\nfloat _pow(float v1, float v2) {\n  if (v2 == 0.0) return 1.0;\n  return pow(v1, v2);\n}\n\nfloat tanh(float x) {\n  float e = exp(2.0 * x);\n  return (e - 1.0) / (e + 1.0);\n}\n\nfloat trunc(float x) {\n  if (x >= 0.0) {\n    return floor(x); \n  } else {\n    return ceil(x);\n  }\n}\n\nvec4 _round(vec4 x) {\n  return floor(x + 0.5);\n}\n\nfloat _round(float x) {\n  return floor(x + 0.5);\n}\n\nconst int BIT_COUNT = 32;\nint modi(int x, int y) {\n  return x - y * (x / y);\n}\n\nint bitwiseOr(int a, int b) {\n  int result = 0;\n  int n = 1;\n  \n  for (int i = 0; i < BIT_COUNT; i++) {\n    if ((modi(a, 2) == 1) || (modi(b, 2) == 1)) {\n      result += n;\n    }\n    a = a / 2;\n    b = b / 2;\n    n = n * 2;\n    if(!(a > 0 || b > 0)) {\n      break;\n    }\n  }\n  return result;\n}\nint bitwiseXOR(int a, int b) {\n  int result = 0;\n  int n = 1;\n  \n  for (int i = 0; i < BIT_COUNT; i++) {\n    if ((modi(a, 2) == 1) != (modi(b, 2) == 1)) {\n      result += n;\n    }\n    a = a / 2;\n    b = b / 2;\n    n = n * 2;\n    if(!(a > 0 || b > 0)) {\n      break;\n    }\n  }\n  return result;\n}\nint bitwiseAnd(int a, int b) {\n  int result = 0;\n  int n = 1;\n  for (int i = 0; i < BIT_COUNT; i++) {\n    if ((modi(a, 2) == 1) && (modi(b, 2) == 1)) {\n      result += n;\n    }\n    a = a / 2;\n    b = b / 2;\n    n = n * 2;\n    if(!(a > 0 && b > 0)) {\n      break;\n    }\n  }\n  return result;\n}\nint bitwiseNot(int a) {\n  int result = 0;\n  int n = 1;\n  \n  for (int i = 0; i < BIT_COUNT; i++) {\n    if (modi(a, 2) == 0) {\n      result += n;    \n    }\n    a = a / 2;\n    n = n * 2;\n  }\n  return result;\n}\nint bitwiseZeroFillLeftShift(int n, int shift) {\n  int maxBytes = BIT_COUNT;\n  for (int i = 0; i < BIT_COUNT; i++) {\n    if (maxBytes >= n) {\n      break;\n    }\n    maxBytes *= 2;\n  }\n  for (int i = 0; i < BIT_COUNT; i++) {\n    if (i >= shift) {\n      break;\n    }\n    n *= 2;\n  }\n\n  int result = 0;\n  int byteVal = 1;\n  for (int i = 0; i < BIT_COUNT; i++) {\n    if (i >= maxBytes) break;\n    if (modi(n, 2) > 0) { result += byteVal; }\n    n = int(n / 2);\n    byteVal *= 2;\n  }\n  return result;\n}\n\nint bitwiseSignedRightShift(int num, int shifts) {\n  return int(floor(float(num) / pow(2.0, float(shifts))));\n}\n\nint bitwiseZeroFillRightShift(int n, int shift) {\n  int maxBytes = BIT_COUNT;\n  for (int i = 0; i < BIT_COUNT; i++) {\n    if (maxBytes >= n) {\n      break;\n    }\n    maxBytes *= 2;\n  }\n  for (int i = 0; i < BIT_COUNT; i++) {\n    if (i >= shift) {\n      break;\n    }\n    n /= 2;\n  }\n  int result = 0;\n  int byteVal = 1;\n  for (int i = 0; i < BIT_COUNT; i++) {\n    if (i >= maxBytes) break;\n    if (modi(n, 2) > 0) { result += byteVal; }\n    n = int(n / 2);\n    byteVal *= 2;\n  }\n  return result;\n}\n\nvec2 integerMod(vec2 x, float y) {\n  vec2 res = floor(mod(x, y));\n  return res * step(1.0 - floor(y), -res);\n}\n\nvec3 integerMod(vec3 x, float y) {\n  vec3 res = floor(mod(x, y));\n  return res * step(1.0 - floor(y), -res);\n}\n\nvec4 integerMod(vec4 x, vec4 y) {\n  vec4 res = floor(mod(x, y));\n  return res * step(1.0 - floor(y), -res);\n}\n\nfloat integerMod(float x, float y) {\n  float res = floor(mod(x, y));\n  return res * (res > floor(y) - 1.0 ? 0.0 : 1.0);\n}\n\nint integerMod(int x, int y) {\n  return x - (y * int(x / y));\n}\n\n__DIVIDE_WITH_INTEGER_CHECK__;\n\n// Here be dragons!\n// DO NOT OPTIMIZE THIS CODE\n// YOU WILL BREAK SOMETHING ON SOMEBODY'S MACHINE\n// LEAVE IT AS IT IS, LEST YOU WASTE YOUR OWN TIME\nconst vec2 MAGIC_VEC = vec2(1.0, -256.0);\nconst vec4 SCALE_FACTOR = vec4(1.0, 256.0, 65536.0, 0.0);\nconst vec4 SCALE_FACTOR_INV = vec4(1.0, 0.00390625, 0.0000152587890625, 0.0); // 1, 1/256, 1/65536\nfloat decode32(vec4 texel) {\n  __DECODE32_ENDIANNESS__;\n  texel *= 255.0;\n  vec2 gte128;\n  gte128.x = texel.b >= 128.0 ? 1.0 : 0.0;\n  gte128.y = texel.a >= 128.0 ? 1.0 : 0.0;\n  float exponent = 2.0 * texel.a - 127.0 + dot(gte128, MAGIC_VEC);\n  float res = exp2(_round(exponent));\n  texel.b = texel.b - 128.0 * gte128.x;\n  res = dot(texel, SCALE_FACTOR) * exp2(_round(exponent-23.0)) + res;\n  res *= gte128.y * -2.0 + 1.0;\n  return res;\n}\n\nfloat decode16(vec4 texel, int index) {\n  int channel = integerMod(index, 2);\n  if (channel == 0) return texel.r * 255.0 + texel.g * 65280.0;\n  if (channel == 1) return texel.b * 255.0 + texel.a * 65280.0;\n  return 0.0;\n}\n\nfloat decode8(vec4 texel, int index) {\n  int channel = integerMod(index, 4);\n  if (channel == 0) return texel.r * 255.0;\n  if (channel == 1) return texel.g * 255.0;\n  if (channel == 2) return texel.b * 255.0;\n  if (channel == 3) return texel.a * 255.0;\n  return 0.0;\n}\n\nvec4 legacyEncode32(float f) {\n  float F = abs(f);\n  float sign = f < 0.0 ? 1.0 : 0.0;\n  float exponent = floor(log2(F));\n  float mantissa = (exp2(-exponent) * F);\n  // exponent += floor(log2(mantissa));\n  vec4 texel = vec4(F * exp2(23.0-exponent)) * SCALE_FACTOR_INV;\n  texel.rg = integerMod(texel.rg, 256.0);\n  texel.b = integerMod(texel.b, 128.0);\n  texel.a = exponent*0.5 + 63.5;\n  texel.ba += vec2(integerMod(exponent+127.0, 2.0), sign) * 128.0;\n  texel = floor(texel);\n  texel *= 0.003921569; // 1/255\n  __ENCODE32_ENDIANNESS__;\n  return texel;\n}\n\n// https://github.com/gpujs/gpu.js/wiki/Encoder-details\nvec4 encode32(float value) {\n  if (value == 0.0) return vec4(0, 0, 0, 0);\n\n  float exponent;\n  float mantissa;\n  vec4  result;\n  float sgn;\n\n  sgn = step(0.0, -value);\n  value = abs(value);\n\n  exponent = floor(log2(value));\n\n  mantissa = value*pow(2.0, -exponent)-1.0;\n  exponent = exponent+127.0;\n  result   = vec4(0,0,0,0);\n\n  result.a = floor(exponent/2.0);\n  exponent = exponent - result.a*2.0;\n  result.a = result.a + 128.0*sgn;\n\n  result.b = floor(mantissa * 128.0);\n  mantissa = mantissa - result.b / 128.0;\n  result.b = result.b + exponent*128.0;\n\n  result.g = floor(mantissa*32768.0);\n  mantissa = mantissa - result.g/32768.0;\n\n  result.r = floor(mantissa*8388608.0);\n  return result/255.0;\n}\n// Dragons end here\n\nint index;\nivec3 threadId;\n\nivec3 indexTo3D(int idx, ivec3 texDim) {\n  int z = int(idx / (texDim.x * texDim.y));\n  idx -= z * int(texDim.x * texDim.y);\n  int y = int(idx / texDim.x);\n  int x = int(integerMod(idx, texDim.x));\n  return ivec3(x, y, z);\n}\n\nfloat get32(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\n  int index = x + texDim.x * (y + texDim.y * z);\n  int w = texSize.x;\n  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\n  vec4 texel = texture2D(tex, st / vec2(texSize));\n  return decode32(texel);\n}\n\nfloat get16(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\n  int index = x + texDim.x * (y + texDim.y * z);\n  int w = texSize.x * 2;\n  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\n  vec4 texel = texture2D(tex, st / vec2(texSize.x * 2, texSize.y));\n  return decode16(texel, index);\n}\n\nfloat get8(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\n  int index = x + texDim.x * (y + texDim.y * z);\n  int w = texSize.x * 4;\n  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\n  vec4 texel = texture2D(tex, st / vec2(texSize.x * 4, texSize.y));\n  return decode8(texel, index);\n}\n\nfloat getMemoryOptimized32(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\n  int index = x + texDim.x * (y + texDim.y * z);\n  int channel = integerMod(index, 4);\n  index = index / 4;\n  int w = texSize.x;\n  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\n  vec4 texel = texture2D(tex, st / vec2(texSize));\n  if (channel == 0) return texel.r;\n  if (channel == 1) return texel.g;\n  if (channel == 2) return texel.b;\n  if (channel == 3) return texel.a;\n  return 0.0;\n}\n\nvec4 getImage2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\n  int index = x + texDim.x * (y + texDim.y * z);\n  int w = texSize.x;\n  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\n  return texture2D(tex, st / vec2(texSize));\n}\n\nfloat getFloatFromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\n  vec4 result = getImage2D(tex, texSize, texDim, z, y, x);\n  return result[0];\n}\n\nvec2 getVec2FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\n  vec4 result = getImage2D(tex, texSize, texDim, z, y, x);\n  return vec2(result[0], result[1]);\n}\n\nvec2 getMemoryOptimizedVec2(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\n  int index = x + (texDim.x * (y + (texDim.y * z)));\n  int channel = integerMod(index, 2);\n  index = index / 2;\n  int w = texSize.x;\n  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\n  vec4 texel = texture2D(tex, st / vec2(texSize));\n  if (channel == 0) return vec2(texel.r, texel.g);\n  if (channel == 1) return vec2(texel.b, texel.a);\n  return vec2(0.0, 0.0);\n}\n\nvec3 getVec3FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\n  vec4 result = getImage2D(tex, texSize, texDim, z, y, x);\n  return vec3(result[0], result[1], result[2]);\n}\n\nvec3 getMemoryOptimizedVec3(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\n  int fieldIndex = 3 * (x + texDim.x * (y + texDim.y * z));\n  int vectorIndex = fieldIndex / 4;\n  int vectorOffset = fieldIndex - vectorIndex * 4;\n  int readY = vectorIndex / texSize.x;\n  int readX = vectorIndex - readY * texSize.x;\n  vec4 tex1 = texture2D(tex, (vec2(readX, readY) + 0.5) / vec2(texSize));\n  \n  if (vectorOffset == 0) {\n    return tex1.xyz;\n  } else if (vectorOffset == 1) {\n    return tex1.yzw;\n  } else {\n    readX++;\n    if (readX >= texSize.x) {\n      readX = 0;\n      readY++;\n    }\n    vec4 tex2 = texture2D(tex, vec2(readX, readY) / vec2(texSize));\n    if (vectorOffset == 2) {\n      return vec3(tex1.z, tex1.w, tex2.x);\n    } else {\n      return vec3(tex1.w, tex2.x, tex2.y);\n    }\n  }\n}\n\nvec4 getVec4FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\n  return getImage2D(tex, texSize, texDim, z, y, x);\n}\n\nvec4 getMemoryOptimizedVec4(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\n  int index = x + texDim.x * (y + texDim.y * z);\n  int channel = integerMod(index, 2);\n  int w = texSize.x;\n  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\n  vec4 texel = texture2D(tex, st / vec2(texSize));\n  return vec4(texel.r, texel.g, texel.b, texel.a);\n}\n\nvec4 actualColor;\nvoid color(float r, float g, float b, float a) {\n  actualColor = vec4(r,g,b,a);\n}\n\nvoid color(float r, float g, float b) {\n  color(r,g,b,1.0);\n}\n\nvoid color(sampler2D image) {\n  actualColor = texture2D(image, vTexCoord);\n}\n\nfloat modulo(float number, float divisor) {\n  if (number < 0.0) {\n    number = abs(number);\n    if (divisor < 0.0) {\n      divisor = abs(divisor);\n    }\n    return -mod(number, divisor);\n  }\n  if (divisor < 0.0) {\n    divisor = abs(divisor);\n  }\n  return mod(number, divisor);\n}\n\n__INJECTED_NATIVE__;\n__MAIN_CONSTANTS__;\n__MAIN_ARGUMENTS__;\n__KERNEL__;\n\nvoid main(void) {\n  index = int(vTexCoord.s * float(uTexSize.x)) + int(vTexCoord.t * float(uTexSize.y)) * uTexSize.x;\n  __MAIN_RESULT__;\n}`;
                    e.exports = {
                        fragmentShader: i
                    }
                }, {}],
                38: [function(t, e, n) {
                    const {
                        utils: i
                    } = t("../../utils"), {
                        FunctionNode: s
                    } = t("../function-node");
                    const r = {
                            Array: "sampler2D",
                            "Array(2)": "vec2",
                            "Array(3)": "vec3",
                            "Array(4)": "vec4",
                            "Matrix(2)": "mat2",
                            "Matrix(3)": "mat3",
                            "Matrix(4)": "mat4",
                            Array2D: "sampler2D",
                            Array3D: "sampler2D",
                            Boolean: "bool",
                            Float: "float",
                            Input: "sampler2D",
                            Integer: "int",
                            Number: "float",
                            LiteralInteger: "float",
                            NumberTexture: "sampler2D",
                            MemoryOptimizedNumberTexture: "sampler2D",
                            "ArrayTexture(1)": "sampler2D",
                            "ArrayTexture(2)": "sampler2D",
                            "ArrayTexture(3)": "sampler2D",
                            "ArrayTexture(4)": "sampler2D",
                            HTMLVideo: "sampler2D",
                            HTMLCanvas: "sampler2D",
                            OffscreenCanvas: "sampler2D",
                            HTMLImage: "sampler2D",
                            ImageBitmap: "sampler2D",
                            ImageData: "sampler2D",
                            HTMLImageArray: "sampler2DArray"
                        },
                        a = {
                            "===": "==",
                            "!==": "!="
                        };
                    e.exports = {
                        WebGLFunctionNode: class extends s {
                            constructor(t, e) {
                                super(t, e), e && e.hasOwnProperty("fixIntegerDivisionAccuracy") && (this.fixIntegerDivisionAccuracy = e.fixIntegerDivisionAccuracy)
                            }
                            astConditionalExpression(t, e) {
                                if ("ConditionalExpression" !== t.type) throw this.astErrorOutput("Not a conditional expression", t);
                                const n = this.getType(t.consequent),
                                    i = this.getType(t.alternate);
                                return null === n && null === i ? (e.push("if ("), this.astGeneric(t.test, e), e.push(") {"), this.astGeneric(t.consequent, e), e.push(";"), e.push("} else {"), this.astGeneric(t.alternate, e), e.push(";"), e.push("}"), e) : (e.push("("), this.astGeneric(t.test, e), e.push("?"), this.astGeneric(t.consequent, e), e.push(":"), this.astGeneric(t.alternate, e), e.push(")"), e)
                            }
                            astFunction(t, e) {
                                if (this.isRootKernel) e.push("void");
                                else {
                                    this.returnType || this.findLastReturn() && (this.returnType = this.getType(t.body), "LiteralInteger" === this.returnType && (this.returnType = "Number"));
                                    const {
                                        returnType: n
                                    } = this;
                                    if (n) {
                                        const t = r[n];
                                        if (!t) throw new Error(`unknown type ${n}`);
                                        e.push(t)
                                    } else e.push("void")
                                }
                                if (e.push(" "), e.push(this.name), e.push("("), !this.isRootKernel)
                                    for (let n = 0; n < this.argumentNames.length; ++n) {
                                        const s = this.argumentNames[n];
                                        n > 0 && e.push(", ");
                                        let a = this.argumentTypes[this.argumentNames.indexOf(s)];
                                        if (!a) throw this.astErrorOutput(`Unknown argument ${s} type`, t);
                                        "LiteralInteger" === a && (this.argumentTypes[n] = a = "Number");
                                        const o = r[a];
                                        if (!o) throw this.astErrorOutput("Unexpected expression", t);
                                        const u = i.sanitizeName(s);
                                        "sampler2D" === o || "sampler2DArray" === o ? e.push(`${o} user_${u},ivec2 user_${u}Size,ivec3 user_${u}Dim`) : e.push(`${o} user_${u}`)
                                    }
                                e.push(") {\n");
                                for (let n = 0; n < t.body.body.length; ++n) this.astGeneric(t.body.body[n], e), e.push("\n");
                                return e.push("}\n"), e
                            }
                            astReturnStatement(t, e) {
                                if (!t.argument) throw this.astErrorOutput("Unexpected return statement", t);
                                this.pushState("skip-literal-correction");
                                const n = this.getType(t.argument);
                                this.popState("skip-literal-correction");
                                const i = [];
                                switch (this.returnType || (this.returnType = "LiteralInteger" === n || "Integer" === n ? "Number" : n), this.returnType) {
                                    case "LiteralInteger":
                                    case "Number":
                                    case "Float":
                                        switch (n) {
                                            case "Integer":
                                                i.push("float("), this.astGeneric(t.argument, i), i.push(")");
                                                break;
                                            case "LiteralInteger":
                                                this.castLiteralToFloat(t.argument, i), "Integer" === this.getType(t) && (i.unshift("float("), i.push(")"));
                                                break;
                                            default:
                                                this.astGeneric(t.argument, i)
                                        }
                                        break;
                                    case "Integer":
                                        switch (n) {
                                            case "Float":
                                            case "Number":
                                                this.castValueToInteger(t.argument, i);
                                                break;
                                            case "LiteralInteger":
                                                this.castLiteralToInteger(t.argument, i);
                                                break;
                                            default:
                                                this.astGeneric(t.argument, i)
                                        }
                                        break;
                                    case "Array(4)":
                                    case "Array(3)":
                                    case "Array(2)":
                                    case "Matrix(2)":
                                    case "Matrix(3)":
                                    case "Matrix(4)":
                                    case "Input":
                                        this.astGeneric(t.argument, i);
                                        break;
                                    default:
                                        throw this.astErrorOutput(`unhandled return type ${this.returnType}`, t)
                                }
                                return this.isRootKernel ? (e.push(`kernelResult = ${i.join("")};`), e.push("return;")) : this.isSubKernel ? (e.push(`subKernelResult_${this.name} = ${i.join("")};`), e.push(`return subKernelResult_${this.name};`)) : e.push(`return ${i.join("")};`), e
                            }
                            astLiteral(t, e) {
                                if (isNaN(t.value)) throw this.astErrorOutput("Non-numeric literal not supported : " + t.value, t);
                                const n = this.astKey(t);
                                return Number.isInteger(t.value) ? this.isState("casting-to-integer") || this.isState("building-integer") ? (this.literalTypes[n] = "Integer", e.push(`${t.value}`)) : (this.isState("casting-to-float") || this.isState("building-float"), this.literalTypes[n] = "Number", e.push(`${t.value}.0`)) : this.isState("casting-to-integer") || this.isState("building-integer") ? (this.literalTypes[n] = "Integer", e.push(Math.round(t.value))) : (this.literalTypes[n] = "Number", e.push(`${t.value}`)), e
                            }
                            astBinaryExpression(t, e) {
                                if (this.checkAndUpconvertOperator(t, e)) return e;
                                if (this.fixIntegerDivisionAccuracy && "/" === t.operator) {
                                    switch (e.push("divWithIntCheck("), this.pushState("building-float"), this.getType(t.left)) {
                                        case "Integer":
                                            this.castValueToFloat(t.left, e);
                                            break;
                                        case "LiteralInteger":
                                            this.castLiteralToFloat(t.left, e);
                                            break;
                                        default:
                                            this.astGeneric(t.left, e)
                                    }
                                    switch (e.push(", "), this.getType(t.right)) {
                                        case "Integer":
                                            this.castValueToFloat(t.right, e);
                                            break;
                                        case "LiteralInteger":
                                            this.castLiteralToFloat(t.right, e);
                                            break;
                                        default:
                                            this.astGeneric(t.right, e)
                                    }
                                    return this.popState("building-float"), e.push(")"), e
                                }
                                e.push("(");
                                const n = this.getType(t.left) || "Number",
                                    i = this.getType(t.right) || "Number";
                                if (!n || !i) throw this.astErrorOutput("Unhandled binary expression", t);
                                const s = n + " & " + i;
                                switch (s) {
                                    case "Integer & Integer":
                                        this.pushState("building-integer"), this.astGeneric(t.left, e), e.push(a[t.operator] || t.operator), this.astGeneric(t.right, e), this.popState("building-integer");
                                        break;
                                    case "Number & Float":
                                    case "Float & Number":
                                    case "Float & Float":
                                    case "Number & Number":
                                        this.pushState("building-float"), this.astGeneric(t.left, e), e.push(a[t.operator] || t.operator), this.astGeneric(t.right, e), this.popState("building-float");
                                        break;
                                    case "LiteralInteger & LiteralInteger":
                                        this.isState("casting-to-integer") || this.isState("building-integer") ? (this.pushState("building-integer"), this.astGeneric(t.left, e), e.push(a[t.operator] || t.operator), this.astGeneric(t.right, e), this.popState("building-integer")) : (this.pushState("building-float"), this.castLiteralToFloat(t.left, e), e.push(a[t.operator] || t.operator), this.castLiteralToFloat(t.right, e), this.popState("building-float"));
                                        break;
                                    case "Integer & Float":
                                    case "Integer & Number":
                                        if ((">" === t.operator || "<" === t.operator && "Literal" === t.right.type) && !Number.isInteger(t.right.value)) {
                                            this.pushState("building-float"), this.castValueToFloat(t.left, e), e.push(a[t.operator] || t.operator), this.astGeneric(t.right, e), this.popState("building-float");
                                            break
                                        }
                                        if (this.pushState("building-integer"), this.astGeneric(t.left, e), e.push(a[t.operator] || t.operator), this.pushState("casting-to-integer"), "Literal" === t.right.type) {
                                            const n = [];
                                            if (this.astGeneric(t.right, n), "Integer" !== this.getType(t.right)) throw this.astErrorOutput("Unhandled binary expression with literal", t);
                                            e.push(n.join(""))
                                        } else e.push("int("), this.astGeneric(t.right, e), e.push(")");
                                        this.popState("casting-to-integer"), this.popState("building-integer");
                                        break;
                                    case "Integer & LiteralInteger":
                                        this.pushState("building-integer"), this.astGeneric(t.left, e), e.push(a[t.operator] || t.operator), this.castLiteralToInteger(t.right, e), this.popState("building-integer");
                                        break;
                                    case "Number & Integer":
                                    case "Float & Integer":
                                        this.pushState("building-float"), this.astGeneric(t.left, e), e.push(a[t.operator] || t.operator), this.castValueToFloat(t.right, e), this.popState("building-float");
                                        break;
                                    case "Float & LiteralInteger":
                                    case "Number & LiteralInteger":
                                        this.pushState("building-float"), this.astGeneric(t.left, e), e.push(a[t.operator] || t.operator), this.castLiteralToFloat(t.right, e), this.popState("building-float");
                                        break;
                                    case "LiteralInteger & Float":
                                    case "LiteralInteger & Number":
                                        this.isState("casting-to-integer") ? (this.pushState("building-integer"), this.castLiteralToInteger(t.left, e), e.push(a[t.operator] || t.operator), this.castValueToInteger(t.right, e), this.popState("building-integer")) : (this.pushState("building-float"), this.astGeneric(t.left, e), e.push(a[t.operator] || t.operator), this.pushState("casting-to-float"), this.astGeneric(t.right, e), this.popState("casting-to-float"), this.popState("building-float"));
                                        break;
                                    case "LiteralInteger & Integer":
                                        this.pushState("building-integer"), this.castLiteralToInteger(t.left, e), e.push(a[t.operator] || t.operator), this.astGeneric(t.right, e), this.popState("building-integer");
                                        break;
                                    case "Boolean & Boolean":
                                        this.pushState("building-boolean"), this.astGeneric(t.left, e), e.push(a[t.operator] || t.operator), this.astGeneric(t.right, e), this.popState("building-boolean");
                                        break;
                                    default:
                                        throw this.astErrorOutput(`Unhandled binary expression between ${s}`, t)
                                }
                                return e.push(")"), e
                            }
                            checkAndUpconvertOperator(t, e) {
                                const n = this.checkAndUpconvertBitwiseOperators(t, e);
                                if (n) return n;
                                const i = {
                                    "%": this.fixIntegerDivisionAccuracy ? "integerCorrectionModulo" : "modulo",
                                    "**": "pow"
                                } [t.operator];
                                if (!i) return null;
                                switch (e.push(i), e.push("("), this.getType(t.left)) {
                                    case "Integer":
                                        this.castValueToFloat(t.left, e);
                                        break;
                                    case "LiteralInteger":
                                        this.castLiteralToFloat(t.left, e);
                                        break;
                                    default:
                                        this.astGeneric(t.left, e)
                                }
                                switch (e.push(","), this.getType(t.right)) {
                                    case "Integer":
                                        this.castValueToFloat(t.right, e);
                                        break;
                                    case "LiteralInteger":
                                        this.castLiteralToFloat(t.right, e);
                                        break;
                                    default:
                                        this.astGeneric(t.right, e)
                                }
                                return e.push(")"), e
                            }
                            checkAndUpconvertBitwiseOperators(t, e) {
                                const n = {
                                    "&": "bitwiseAnd",
                                    "|": "bitwiseOr",
                                    "^": "bitwiseXOR",
                                    "<<": "bitwiseZeroFillLeftShift",
                                    ">>": "bitwiseSignedRightShift",
                                    ">>>": "bitwiseZeroFillRightShift"
                                } [t.operator];
                                if (!n) return null;
                                switch (e.push(n), e.push("("), this.getType(t.left)) {
                                    case "Number":
                                    case "Float":
                                        this.castValueToInteger(t.left, e);
                                        break;
                                    case "LiteralInteger":
                                        this.castLiteralToInteger(t.left, e);
                                        break;
                                    default:
                                        this.astGeneric(t.left, e)
                                }
                                switch (e.push(","), this.getType(t.right)) {
                                    case "Number":
                                    case "Float":
                                        this.castValueToInteger(t.right, e);
                                        break;
                                    case "LiteralInteger":
                                        this.castLiteralToInteger(t.right, e);
                                        break;
                                    default:
                                        this.astGeneric(t.right, e)
                                }
                                return e.push(")"), e
                            }
                            checkAndUpconvertBitwiseUnary(t, e) {
                                const n = {
                                    "~": "bitwiseNot"
                                } [t.operator];
                                if (!n) return null;
                                switch (e.push(n), e.push("("), this.getType(t.argument)) {
                                    case "Number":
                                    case "Float":
                                        this.castValueToInteger(t.argument, e);
                                        break;
                                    case "LiteralInteger":
                                        this.castLiteralToInteger(t.argument, e);
                                        break;
                                    default:
                                        this.astGeneric(t.argument, e)
                                }
                                return e.push(")"), e
                            }
                            castLiteralToInteger(t, e) {
                                return this.pushState("casting-to-integer"), this.astGeneric(t, e), this.popState("casting-to-integer"), e
                            }
                            castLiteralToFloat(t, e) {
                                return this.pushState("casting-to-float"), this.astGeneric(t, e), this.popState("casting-to-float"), e
                            }
                            castValueToInteger(t, e) {
                                return this.pushState("casting-to-integer"), e.push("int("), this.astGeneric(t, e), e.push(")"), this.popState("casting-to-integer"), e
                            }
                            castValueToFloat(t, e) {
                                return this.pushState("casting-to-float"), e.push("float("), this.astGeneric(t, e), e.push(")"), this.popState("casting-to-float"), e
                            }
                            astIdentifierExpression(t, e) {
                                if ("Identifier" !== t.type) throw this.astErrorOutput("IdentifierExpression - not an Identifier", t);
                                const n = this.getType(t),
                                    s = i.sanitizeName(t.name);
                                return "Infinity" === t.name ? e.push("3.402823466e+38") : "Boolean" === n && this.argumentNames.indexOf(s) > -1 ? e.push(`bool(user_${s})`) : e.push(`user_${s}`), e
                            }
                            astForStatement(t, e) {
                                if ("ForStatement" !== t.type) throw this.astErrorOutput("Invalid for statement", t);
                                const n = [],
                                    i = [],
                                    s = [],
                                    r = [];
                                let a = null;
                                if (t.init) {
                                    const {
                                        declarations: e
                                    } = t.init;
                                    e.length > 1 && (a = !1), this.astGeneric(t.init, n);
                                    for (let t = 0; t < e.length; t++) e[t].init && "Literal" !== e[t].init.type && (a = !1)
                                } else a = !1;
                                if (t.test ? this.astGeneric(t.test, i) : a = !1, t.update ? this.astGeneric(t.update, s) : a = !1, t.body && (this.pushState("loop-body"), this.astGeneric(t.body, r), this.popState("loop-body")), null === a && (a = this.isSafe(t.init) && this.isSafe(t.test)), a) {
                                    const t = n.join(""),
                                        a = ";" !== t[t.length - 1];
                                    e.push(`for (${t}${a?";":""}${i.join("")};${s.join("")}){\n`), e.push(r.join("")), e.push("}\n")
                                } else {
                                    const t = this.getInternalVariableName("safeI");
                                    n.length > 0 && e.push(n.join(""), "\n"), e.push(`for (int ${t}=0;${t}<LOOP_MAX;${t}++){\n`), i.length > 0 && e.push(`if (!${i.join("")}) break;\n`), e.push(r.join("")), e.push(`\n${s.join("")};`), e.push("}\n")
                                }
                                return e
                            }
                            astWhileStatement(t, e) {
                                if ("WhileStatement" !== t.type) throw this.astErrorOutput("Invalid while statement", t);
                                const n = this.getInternalVariableName("safeI");
                                return e.push(`for (int ${n}=0;${n}<LOOP_MAX;${n}++){\n`), e.push("if (!"), this.astGeneric(t.test, e), e.push(") break;\n"), this.astGeneric(t.body, e), e.push("}\n"), e
                            }
                            astDoWhileStatement(t, e) {
                                if ("DoWhileStatement" !== t.type) throw this.astErrorOutput("Invalid while statement", t);
                                const n = this.getInternalVariableName("safeI");
                                return e.push(`for (int ${n}=0;${n}<LOOP_MAX;${n}++){\n`), this.astGeneric(t.body, e), e.push("if (!"), this.astGeneric(t.test, e), e.push(") break;\n"), e.push("}\n"), e
                            }
                            astAssignmentExpression(t, e) {
                                if ("%=" === t.operator) this.astGeneric(t.left, e), e.push("="), e.push("mod("), this.astGeneric(t.left, e), e.push(","), this.astGeneric(t.right, e), e.push(")");
                                else {
                                    if ("**=" !== t.operator) {
                                        const n = this.getType(t.left),
                                            i = this.getType(t.right);
                                        return this.astGeneric(t.left, e), e.push(t.operator), "Integer" !== n && "Integer" === i ? (e.push("float("), this.astGeneric(t.right, e), e.push(")")) : this.astGeneric(t.right, e), e
                                    }
                                    this.astGeneric(t.left, e), e.push("="), e.push("pow("), this.astGeneric(t.left, e), e.push(","), this.astGeneric(t.right, e), e.push(")")
                                }
                            }
                            astBlockStatement(t, e) {
                                if (this.isState("loop-body")) {
                                    this.pushState("block-body");
                                    for (let n = 0; n < t.body.length; n++) this.astGeneric(t.body[n], e);
                                    this.popState("block-body")
                                } else {
                                    e.push("{\n");
                                    for (let n = 0; n < t.body.length; n++) this.astGeneric(t.body[n], e);
                                    e.push("}\n")
                                }
                                return e
                            }
                            astVariableDeclaration(t, e) {
                                const n = t.declarations;
                                if (!n || !n[0] || !n[0].init) throw this.astErrorOutput("Unexpected expression", t);
                                const s = [];
                                let a = null;
                                const o = [];
                                let u = [];
                                for (let e = 0; e < n.length; e++) {
                                    const s = n[e],
                                        h = s.init,
                                        l = this.getDeclaration(s.id),
                                        c = this.getType(s.init);
                                    let p = c;
                                    "LiteralInteger" === p && (p = "Integer" === l.suggestedType ? "Integer" : "Number");
                                    const d = r[p];
                                    if (!d) throw this.astErrorOutput(`Markup type ${p} not handled`, t);
                                    const m = [];
                                    if ("Integer" === c && "Integer" === p) {
                                        if (l.valueType = "Number", 0 === e || null === a) m.push("float ");
                                        else if (p !== a) throw new Error("Unhandled declaration");
                                        a = p, m.push(`user_${i.sanitizeName(s.id.name)}=`), m.push("float("), this.astGeneric(h, m), m.push(")")
                                    } else l.valueType = p, 0 === e || null === a ? m.push(`${d} `) : p !== a && (o.push(u.join(",")), u = [], m.push(`${d} `)), a = p, m.push(`user_${i.sanitizeName(s.id.name)}=`), "Number" === c && "Integer" === p ? h.left && "Literal" === h.left.type ? this.astGeneric(h, m) : (m.push("int("), this.astGeneric(h, m), m.push(")")) : "LiteralInteger" === c && "Integer" === p ? this.castLiteralToInteger(h, m) : this.astGeneric(h, m);
                                    u.push(m.join(""))
                                }
                                return u.length > 0 && o.push(u.join(",")), s.push(o.join(";")), e.push(s.join("")), e.push(";"), e
                            }
                            astIfStatement(t, e) {
                                return e.push("if ("), this.astGeneric(t.test, e), e.push(")"), "BlockStatement" === t.consequent.type ? this.astGeneric(t.consequent, e) : (e.push(" {\n"), this.astGeneric(t.consequent, e), e.push("\n}\n")), t.alternate && (e.push("else "), "BlockStatement" === t.alternate.type || "IfStatement" === t.alternate.type ? this.astGeneric(t.alternate, e) : (e.push(" {\n"), this.astGeneric(t.alternate, e), e.push("\n}\n"))), e
                            }
                            astSwitchStatement(t, e) {
                                if ("SwitchStatement" !== t.type) throw this.astErrorOutput("Invalid switch statement", t);
                                const {
                                    discriminant: n,
                                    cases: i
                                } = t, s = this.getType(n), r = `switchDiscriminant${this.astKey(t,"_")}`;
                                switch (s) {
                                    case "Float":
                                    case "Number":
                                        e.push(`float ${r} = `), this.astGeneric(n, e), e.push(";\n");
                                        break;
                                    case "Integer":
                                        e.push(`int ${r} = `), this.astGeneric(n, e), e.push(";\n")
                                }
                                if (1 === i.length && !i[0].test) return this.astGeneric(i[0].consequent, e), e;
                                let a = !1,
                                    o = [],
                                    u = !1,
                                    h = !1;
                                for (let t = 0; t < i.length; t++) {
                                    if (i[t].test) {
                                        if (0 !== t && h ? a ? (e.push(`${r} == `), a = !1) : e.push(` else if (${r} == `) : (h = !0, e.push(`if (${r} == `)), "Integer" === s) switch (this.getType(i[t].test)) {
                                            case "Number":
                                            case "Float":
                                                this.castValueToInteger(i[t].test, e);
                                                break;
                                            case "LiteralInteger":
                                                this.castLiteralToInteger(i[t].test, e)
                                        } else {
                                            if ("Float" !== s) throw new Error("unhanlded");
                                            switch (this.getType(i[t].test)) {
                                                case "LiteralInteger":
                                                    this.castLiteralToFloat(i[t].test, e);
                                                    break;
                                                case "Integer":
                                                    this.castValueToFloat(i[t].test, e)
                                            }
                                        }
                                        if (!i[t].consequent || 0 === i[t].consequent.length) {
                                            a = !0, e.push(" || ");
                                            continue
                                        }
                                        e.push(") {\n")
                                    } else {
                                        if (i.length > t + 1) {
                                            u = !0, this.astGeneric(i[t].consequent, o);
                                            continue
                                        }
                                        e.push(" else {\n")
                                    }
                                    this.astGeneric(i[t].consequent, e), e.push("\n}")
                                }
                                return u && (e.push(" else {"), e.push(o.join("")), e.push("}")), e
                            }
                            astThisExpression(t, e) {
                                return e.push("this"), e
                            }
                            astMemberExpression(t, e) {
                                const {
                                    property: n,
                                    name: s,
                                    signature: r,
                                    origin: a,
                                    type: o,
                                    xProperty: u,
                                    yProperty: h,
                                    zProperty: l
                                } = this.getMemberExpressionDetails(t);
                                switch (r) {
                                    case "value.thread.value":
                                    case "this.thread.value":
                                        if ("x" !== s && "y" !== s && "z" !== s) throw this.astErrorOutput("Unexpected expression, expected `this.thread.x`, `this.thread.y`, or `this.thread.z`", t);
                                        return e.push(`threadId.${s}`), e;
                                    case "this.output.value":
                                        if (this.dynamicOutput) switch (s) {
                                            case "x":
                                                this.isState("casting-to-float") ? e.push("float(uOutputDim.x)") : e.push("uOutputDim.x");
                                                break;
                                            case "y":
                                                this.isState("casting-to-float") ? e.push("float(uOutputDim.y)") : e.push("uOutputDim.y");
                                                break;
                                            case "z":
                                                this.isState("casting-to-float") ? e.push("float(uOutputDim.z)") : e.push("uOutputDim.z");
                                                break;
                                            default:
                                                throw this.astErrorOutput("Unexpected expression", t)
                                        } else switch (s) {
                                            case "x":
                                                this.isState("casting-to-integer") ? e.push(this.output[0]) : e.push(this.output[0], ".0");
                                                break;
                                            case "y":
                                                this.isState("casting-to-integer") ? e.push(this.output[1]) : e.push(this.output[1], ".0");
                                                break;
                                            case "z":
                                                this.isState("casting-to-integer") ? e.push(this.output[2]) : e.push(this.output[2], ".0");
                                                break;
                                            default:
                                                throw this.astErrorOutput("Unexpected expression", t)
                                        }
                                        return e;
                                    case "value":
                                        throw this.astErrorOutput("Unexpected expression", t);
                                    case "value[]":
                                    case "value[][]":
                                    case "value[][][]":
                                    case "value[][][][]":
                                    case "value.value":
                                        if ("Math" === a) return e.push(Math[s]), e;
                                        const r = i.sanitizeName(s);
                                        switch (n) {
                                            case "r":
                                                return e.push(`user_${r}.r`), e;
                                            case "g":
                                                return e.push(`user_${r}.g`), e;
                                            case "b":
                                                return e.push(`user_${r}.b`), e;
                                            case "a":
                                                return e.push(`user_${r}.a`), e
                                        }
                                        break;
                                    case "this.constants.value":
                                        if (void 0 === u) switch (o) {
                                            case "Array(2)":
                                            case "Array(3)":
                                            case "Array(4)":
                                                return e.push(`constants_${i.sanitizeName(s)}`), e
                                        }
                                        case "this.constants.value[]":
                                    case "this.constants.value[][]":
                                    case "this.constants.value[][][]":
                                    case "this.constants.value[][][][]":
                                        break;
                                    case "fn()[]":
                                        return this.astCallExpression(t.object, e), e.push("["), e.push(this.memberExpressionPropertyMarkup(n)), e.push("]"), e;
                                    case "fn()[][]":
                                        return this.astCallExpression(t.object.object, e), e.push("["), e.push(this.memberExpressionPropertyMarkup(t.object.property)), e.push("]"), e.push("["), e.push(this.memberExpressionPropertyMarkup(t.property)), e.push("]"), e;
                                    case "[][]":
                                        return this.astArrayExpression(t.object, e), e.push("["), e.push(this.memberExpressionPropertyMarkup(n)), e.push("]"), e;
                                    default:
                                        throw this.astErrorOutput("Unexpected expression", t)
                                }
                                if (!1 === t.computed) switch (o) {
                                    case "Number":
                                    case "Integer":
                                    case "Float":
                                    case "Boolean":
                                        return e.push(`${a}_${i.sanitizeName(s)}`), e
                                }
                                const c = `${a}_${i.sanitizeName(s)}`;
                                switch (o) {
                                    case "Array(2)":
                                    case "Array(3)":
                                    case "Array(4)":
                                        this.astGeneric(t.object, e), e.push("["), e.push(this.memberExpressionPropertyMarkup(u)), e.push("]");
                                        break;
                                    case "HTMLImageArray":
                                        e.push(`getImage3D(${c}, ${c}Size, ${c}Dim, `), this.memberExpressionXYZ(u, h, l, e), e.push(")");
                                        break;
                                    case "ArrayTexture(1)":
                                        e.push(`getFloatFromSampler2D(${c}, ${c}Size, ${c}Dim, `), this.memberExpressionXYZ(u, h, l, e), e.push(")");
                                        break;
                                    case "Array1D(2)":
                                    case "Array2D(2)":
                                    case "Array3D(2)":
                                        e.push(`getMemoryOptimizedVec2(${c}, ${c}Size, ${c}Dim, `), this.memberExpressionXYZ(u, h, l, e), e.push(")");
                                        break;
                                    case "ArrayTexture(2)":
                                        e.push(`getVec2FromSampler2D(${c}, ${c}Size, ${c}Dim, `), this.memberExpressionXYZ(u, h, l, e), e.push(")");
                                        break;
                                    case "Array1D(3)":
                                    case "Array2D(3)":
                                    case "Array3D(3)":
                                        e.push(`getMemoryOptimizedVec3(${c}, ${c}Size, ${c}Dim, `), this.memberExpressionXYZ(u, h, l, e), e.push(")");
                                        break;
                                    case "ArrayTexture(3)":
                                        e.push(`getVec3FromSampler2D(${c}, ${c}Size, ${c}Dim, `), this.memberExpressionXYZ(u, h, l, e), e.push(")");
                                        break;
                                    case "Array1D(4)":
                                    case "Array2D(4)":
                                    case "Array3D(4)":
                                        e.push(`getMemoryOptimizedVec4(${c}, ${c}Size, ${c}Dim, `), this.memberExpressionXYZ(u, h, l, e), e.push(")");
                                        break;
                                    case "ArrayTexture(4)":
                                    case "HTMLCanvas":
                                    case "OffscreenCanvas":
                                    case "HTMLImage":
                                    case "ImageBitmap":
                                    case "ImageData":
                                    case "HTMLVideo":
                                        e.push(`getVec4FromSampler2D(${c}, ${c}Size, ${c}Dim, `), this.memberExpressionXYZ(u, h, l, e), e.push(")");
                                        break;
                                    case "NumberTexture":
                                    case "Array":
                                    case "Array2D":
                                    case "Array3D":
                                    case "Array4D":
                                    case "Input":
                                    case "Number":
                                    case "Float":
                                    case "Integer":
                                        if ("single" === this.precision) e.push(`getMemoryOptimized32(${c}, ${c}Size, ${c}Dim, `), this.memberExpressionXYZ(u, h, l, e), e.push(")");
                                        else {
                                            const t = "user" === a ? this.lookupFunctionArgumentBitRatio(this.name, s) : this.constantBitRatios[s];
                                            switch (t) {
                                                case 1:
                                                    e.push(`get8(${c}, ${c}Size, ${c}Dim, `);
                                                    break;
                                                case 2:
                                                    e.push(`get16(${c}, ${c}Size, ${c}Dim, `);
                                                    break;
                                                case 4:
                                                case 0:
                                                    e.push(`get32(${c}, ${c}Size, ${c}Dim, `);
                                                    break;
                                                default:
                                                    throw new Error(`unhandled bit ratio of ${t}`)
                                            }
                                            this.memberExpressionXYZ(u, h, l, e), e.push(")")
                                        }
                                        break;
                                    case "MemoryOptimizedNumberTexture":
                                        e.push(`getMemoryOptimized32(${c}, ${c}Size, ${c}Dim, `), this.memberExpressionXYZ(u, h, l, e), e.push(")");
                                        break;
                                    case "Matrix(2)":
                                    case "Matrix(3)":
                                    case "Matrix(4)":
                                        e.push(`${c}[${this.memberExpressionPropertyMarkup(h)}]`), h && e.push(`[${this.memberExpressionPropertyMarkup(u)}]`);
                                        break;
                                    default:
                                        throw new Error(`unhandled member expression "${o}"`)
                                }
                                return e
                            }
                            astCallExpression(t, e) {
                                if (!t.callee) throw this.astErrorOutput("Unknown CallExpression", t);
                                let n = null;
                                const s = this.isAstMathFunction(t);
                                if (n = s || t.callee.object && "ThisExpression" === t.callee.object.type ? t.callee.property.name : "SequenceExpression" !== t.callee.type || "Literal" !== t.callee.expressions[0].type || isNaN(t.callee.expressions[0].raw) ? t.callee.name : t.callee.expressions[1].property.name, !n) throw this.astErrorOutput("Unhandled function, couldn't find name", t);
                                switch (n) {
                                    case "pow":
                                        n = "_pow";
                                        break;
                                    case "round":
                                        n = "_round"
                                }
                                if (this.calledFunctions.indexOf(n) < 0 && this.calledFunctions.push(n), "random" === n && this.plugins && this.plugins.length > 0)
                                    for (let t = 0; t < this.plugins.length; t++) {
                                        const n = this.plugins[t];
                                        if ("Math.random()" === n.functionMatch && n.functionReplace) return e.push(n.functionReplace), e
                                    }
                                if (this.onFunctionCall && this.onFunctionCall(this.name, n, t.arguments), e.push(n), e.push("("), s)
                                    for (let n = 0; n < t.arguments.length; ++n) {
                                        const i = t.arguments[n],
                                            s = this.getType(i);
                                        n > 0 && e.push(", "), "Integer" === s ? this.castValueToFloat(i, e) : this.astGeneric(i, e)
                                    } else {
                                        const s = this.lookupFunctionArgumentTypes(n) || [];
                                        for (let r = 0; r < t.arguments.length; ++r) {
                                            const a = t.arguments[r];
                                            let o = s[r];
                                            r > 0 && e.push(", ");
                                            const u = this.getType(a);
                                            switch (o || (this.triggerImplyArgumentType(n, r, u, this), o = u), u) {
                                                case "Boolean":
                                                    this.astGeneric(a, e);
                                                    continue;
                                                case "Number":
                                                case "Float":
                                                    if ("Integer" === o) {
                                                        e.push("int("), this.astGeneric(a, e), e.push(")");
                                                        continue
                                                    }
                                                    if ("Number" === o || "Float" === o) {
                                                        this.astGeneric(a, e);
                                                        continue
                                                    }
                                                    if ("LiteralInteger" === o) {
                                                        this.castLiteralToFloat(a, e);
                                                        continue
                                                    }
                                                    break;
                                                case "Integer":
                                                    if ("Number" === o || "Float" === o) {
                                                        e.push("float("), this.astGeneric(a, e), e.push(")");
                                                        continue
                                                    }
                                                    if ("Integer" === o) {
                                                        this.astGeneric(a, e);
                                                        continue
                                                    }
                                                    break;
                                                case "LiteralInteger":
                                                    if ("Integer" === o) {
                                                        this.castLiteralToInteger(a, e);
                                                        continue
                                                    }
                                                    if ("Number" === o || "Float" === o) {
                                                        this.castLiteralToFloat(a, e);
                                                        continue
                                                    }
                                                    if ("LiteralInteger" === o) {
                                                        this.astGeneric(a, e);
                                                        continue
                                                    }
                                                    break;
                                                case "Array(2)":
                                                case "Array(3)":
                                                case "Array(4)":
                                                    if (o === u) {
                                                        if ("Identifier" === a.type) e.push(`user_${i.sanitizeName(a.name)}`);
                                                        else {
                                                            if ("ArrayExpression" !== a.type && "MemberExpression" !== a.type && "CallExpression" !== a.type) throw this.astErrorOutput(`Unhandled argument type ${a.type}`, t);
                                                            this.astGeneric(a, e)
                                                        }
                                                        continue
                                                    }
                                                    break;
                                                case "HTMLCanvas":
                                                case "OffscreenCanvas":
                                                case "HTMLImage":
                                                case "ImageBitmap":
                                                case "ImageData":
                                                case "HTMLImageArray":
                                                case "HTMLVideo":
                                                case "ArrayTexture(1)":
                                                case "ArrayTexture(2)":
                                                case "ArrayTexture(3)":
                                                case "ArrayTexture(4)":
                                                case "Array":
                                                case "Input":
                                                    if (o === u) {
                                                        if ("Identifier" !== a.type) throw this.astErrorOutput(`Unhandled argument type ${a.type}`, t);
                                                        this.triggerImplyArgumentBitRatio(this.name, a.name, n, r);
                                                        const s = i.sanitizeName(a.name);
                                                        e.push(`user_${s},user_${s}Size,user_${s}Dim`);
                                                        continue
                                                    }
                                            }
                                            throw this.astErrorOutput(`Unhandled argument combination of ${u} and ${o} for argument named "${a.name}"`, t)
                                        }
                                    }
                                return e.push(")"), e
                            }
                            astArrayExpression(t, e) {
                                const n = this.getType(t),
                                    i = t.elements.length;
                                switch (n) {
                                    case "Matrix(2)":
                                    case "Matrix(3)":
                                    case "Matrix(4)":
                                        e.push(`mat${i}(`);
                                        break;
                                    default:
                                        e.push(`vec${i}(`)
                                }
                                for (let n = 0; n < i; ++n) {
                                    n > 0 && e.push(", ");
                                    const i = t.elements[n];
                                    this.astGeneric(i, e)
                                }
                                return e.push(")"), e
                            }
                            memberExpressionXYZ(t, e, n, i) {
                                return n ? i.push(this.memberExpressionPropertyMarkup(n), ", ") : i.push("0, "), e ? i.push(this.memberExpressionPropertyMarkup(e), ", ") : i.push("0, "), i.push(this.memberExpressionPropertyMarkup(t)), i
                            }
                            memberExpressionPropertyMarkup(t) {
                                if (!t) throw new Error("Property not set");
                                const e = [];
                                switch (this.getType(t)) {
                                    case "Number":
                                    case "Float":
                                        this.castValueToInteger(t, e);
                                        break;
                                    case "LiteralInteger":
                                        this.castLiteralToInteger(t, e);
                                        break;
                                    default:
                                        this.astGeneric(t, e)
                                }
                                return e.join("")
                            }
                        }
                    }
                }, {
                    "../../utils": 114,
                    "../function-node": 10
                }],
                39: [function(t, e, n) {
                    const {
                        WebGLKernelValueBoolean: i
                    } = t("./kernel-value/boolean"), {
                        WebGLKernelValueFloat: s
                    } = t("./kernel-value/float"), {
                        WebGLKernelValueInteger: r
                    } = t("./kernel-value/integer"), {
                        WebGLKernelValueHTMLImage: a
                    } = t("./kernel-value/html-image"), {
                        WebGLKernelValueDynamicHTMLImage: o
                    } = t("./kernel-value/dynamic-html-image"), {
                        WebGLKernelValueHTMLVideo: u
                    } = t("./kernel-value/html-video"), {
                        WebGLKernelValueDynamicHTMLVideo: h
                    } = t("./kernel-value/dynamic-html-video"), {
                        WebGLKernelValueSingleInput: l
                    } = t("./kernel-value/single-input"), {
                        WebGLKernelValueDynamicSingleInput: c
                    } = t("./kernel-value/dynamic-single-input"), {
                        WebGLKernelValueUnsignedInput: p
                    } = t("./kernel-value/unsigned-input"), {
                        WebGLKernelValueDynamicUnsignedInput: d
                    } = t("./kernel-value/dynamic-unsigned-input"), {
                        WebGLKernelValueMemoryOptimizedNumberTexture: m
                    } = t("./kernel-value/memory-optimized-number-texture"), {
                        WebGLKernelValueDynamicMemoryOptimizedNumberTexture: g
                    } = t("./kernel-value/dynamic-memory-optimized-number-texture"), {
                        WebGLKernelValueNumberTexture: f
                    } = t("./kernel-value/number-texture"), {
                        WebGLKernelValueDynamicNumberTexture: y
                    } = t("./kernel-value/dynamic-number-texture"), {
                        WebGLKernelValueSingleArray: x
                    } = t("./kernel-value/single-array"), {
                        WebGLKernelValueDynamicSingleArray: _
                    } = t("./kernel-value/dynamic-single-array"), {
                        WebGLKernelValueSingleArray1DI: b
                    } = t("./kernel-value/single-array1d-i"), {
                        WebGLKernelValueDynamicSingleArray1DI: w
                    } = t("./kernel-value/dynamic-single-array1d-i"), {
                        WebGLKernelValueSingleArray2DI: T
                    } = t("./kernel-value/single-array2d-i"), {
                        WebGLKernelValueDynamicSingleArray2DI: v
                    } = t("./kernel-value/dynamic-single-array2d-i"), {
                        WebGLKernelValueSingleArray3DI: E
                    } = t("./kernel-value/single-array3d-i"), {
                        WebGLKernelValueDynamicSingleArray3DI: A
                    } = t("./kernel-value/dynamic-single-array3d-i"), {
                        WebGLKernelValueArray2: I
                    } = t("./kernel-value/array2"), {
                        WebGLKernelValueArray3: S
                    } = t("./kernel-value/array3"), {
                        WebGLKernelValueArray4: k
                    } = t("./kernel-value/array4"), {
                        WebGLKernelValueUnsignedArray: D
                    } = t("./kernel-value/unsigned-array"), {
                        WebGLKernelValueDynamicUnsignedArray: L
                    } = t("./kernel-value/dynamic-unsigned-array"), C = {
                        unsigned: {
                            dynamic: {
                                Boolean: i,
                                Integer: r,
                                Float: s,
                                Array: L,
                                "Array(2)": I,
                                "Array(3)": S,
                                "Array(4)": k,
                                "Array1D(2)": !1,
                                "Array1D(3)": !1,
                                "Array1D(4)": !1,
                                "Array2D(2)": !1,
                                "Array2D(3)": !1,
                                "Array2D(4)": !1,
                                "Array3D(2)": !1,
                                "Array3D(3)": !1,
                                "Array3D(4)": !1,
                                Input: d,
                                NumberTexture: y,
                                "ArrayTexture(1)": y,
                                "ArrayTexture(2)": y,
                                "ArrayTexture(3)": y,
                                "ArrayTexture(4)": y,
                                MemoryOptimizedNumberTexture: g,
                                HTMLCanvas: o,
                                OffscreenCanvas: o,
                                HTMLImage: o,
                                ImageBitmap: o,
                                ImageData: o,
                                HTMLImageArray: !1,
                                HTMLVideo: h
                            },
                            static: {
                                Boolean: i,
                                Float: s,
                                Integer: r,
                                Array: D,
                                "Array(2)": I,
                                "Array(3)": S,
                                "Array(4)": k,
                                "Array1D(2)": !1,
                                "Array1D(3)": !1,
                                "Array1D(4)": !1,
                                "Array2D(2)": !1,
                                "Array2D(3)": !1,
                                "Array2D(4)": !1,
                                "Array3D(2)": !1,
                                "Array3D(3)": !1,
                                "Array3D(4)": !1,
                                Input: p,
                                NumberTexture: f,
                                "ArrayTexture(1)": f,
                                "ArrayTexture(2)": f,
                                "ArrayTexture(3)": f,
                                "ArrayTexture(4)": f,
                                MemoryOptimizedNumberTexture: m,
                                HTMLCanvas: a,
                                OffscreenCanvas: a,
                                HTMLImage: a,
                                ImageBitmap: a,
                                ImageData: a,
                                HTMLImageArray: !1,
                                HTMLVideo: u
                            }
                        },
                        single: {
                            dynamic: {
                                Boolean: i,
                                Integer: r,
                                Float: s,
                                Array: _,
                                "Array(2)": I,
                                "Array(3)": S,
                                "Array(4)": k,
                                "Array1D(2)": w,
                                "Array1D(3)": w,
                                "Array1D(4)": w,
                                "Array2D(2)": v,
                                "Array2D(3)": v,
                                "Array2D(4)": v,
                                "Array3D(2)": A,
                                "Array3D(3)": A,
                                "Array3D(4)": A,
                                Input: c,
                                NumberTexture: y,
                                "ArrayTexture(1)": y,
                                "ArrayTexture(2)": y,
                                "ArrayTexture(3)": y,
                                "ArrayTexture(4)": y,
                                MemoryOptimizedNumberTexture: g,
                                HTMLCanvas: o,
                                OffscreenCanvas: o,
                                HTMLImage: o,
                                ImageBitmap: o,
                                ImageData: o,
                                HTMLImageArray: !1,
                                HTMLVideo: h
                            },
                            static: {
                                Boolean: i,
                                Float: s,
                                Integer: r,
                                Array: x,
                                "Array(2)": I,
                                "Array(3)": S,
                                "Array(4)": k,
                                "Array1D(2)": b,
                                "Array1D(3)": b,
                                "Array1D(4)": b,
                                "Array2D(2)": T,
                                "Array2D(3)": T,
                                "Array2D(4)": T,
                                "Array3D(2)": E,
                                "Array3D(3)": E,
                                "Array3D(4)": E,
                                Input: l,
                                NumberTexture: f,
                                "ArrayTexture(1)": f,
                                "ArrayTexture(2)": f,
                                "ArrayTexture(3)": f,
                                "ArrayTexture(4)": f,
                                MemoryOptimizedNumberTexture: m,
                                HTMLCanvas: a,
                                OffscreenCanvas: a,
                                HTMLImage: a,
                                ImageBitmap: a,
                                ImageData: a,
                                HTMLImageArray: !1,
                                HTMLVideo: u
                            }
                        }
                    };
                    e.exports = {
                        lookupKernelValueType: function(t, e, n, i) {
                            if (!t) throw new Error("type missing");
                            if (!e) throw new Error("dynamic missing");
                            if (!n) throw new Error("precision missing");
                            i.type && (t = i.type);
                            const s = C[n][e];
                            if (!1 === s[t]) return null;
                            if (void 0 === s[t]) throw new Error(`Could not find a KernelValue for ${t}`);
                            return s[t]
                        },
                        kernelValueMaps: C
                    }
                }, {
                    "./kernel-value/array2": 41,
                    "./kernel-value/array3": 42,
                    "./kernel-value/array4": 43,
                    "./kernel-value/boolean": 44,
                    "./kernel-value/dynamic-html-image": 45,
                    "./kernel-value/dynamic-html-video": 46,
                    "./kernel-value/dynamic-memory-optimized-number-texture": 47,
                    "./kernel-value/dynamic-number-texture": 48,
                    "./kernel-value/dynamic-single-array": 49,
                    "./kernel-value/dynamic-single-array1d-i": 50,
                    "./kernel-value/dynamic-single-array2d-i": 51,
                    "./kernel-value/dynamic-single-array3d-i": 52,
                    "./kernel-value/dynamic-single-input": 53,
                    "./kernel-value/dynamic-unsigned-array": 54,
                    "./kernel-value/dynamic-unsigned-input": 55,
                    "./kernel-value/float": 56,
                    "./kernel-value/html-image": 57,
                    "./kernel-value/html-video": 58,
                    "./kernel-value/integer": 60,
                    "./kernel-value/memory-optimized-number-texture": 61,
                    "./kernel-value/number-texture": 62,
                    "./kernel-value/single-array": 63,
                    "./kernel-value/single-array1d-i": 64,
                    "./kernel-value/single-array2d-i": 65,
                    "./kernel-value/single-array3d-i": 66,
                    "./kernel-value/single-input": 67,
                    "./kernel-value/unsigned-array": 68,
                    "./kernel-value/unsigned-input": 69
                }],
                40: [function(t, e, n) {
                    const {
                        WebGLKernelValue: i
                    } = t("./index"), {
                        Input: s
                    } = t("../../../input");
                    e.exports = {
                        WebGLKernelArray: class extends i {
                            checkSize(t, e) {
                                if (!this.kernel.validate) return;
                                const {
                                    maxTextureSize: n
                                } = this.kernel.constructor.features;
                                if (t > n || e > n) throw t > e ? new Error(`Argument texture width of ${t} larger than maximum size of ${n} for your GPU`) : t < e ? new Error(`Argument texture height of ${e} larger than maximum size of ${n} for your GPU`) : new Error(`Argument texture height and width of ${e} larger than maximum size of ${n} for your GPU`)
                            }
                            setup() {
                                this.requestTexture(), this.setupTexture(), this.defineTexture()
                            }
                            requestTexture() {
                                this.texture = this.onRequestTexture()
                            }
                            defineTexture() {
                                const {
                                    context: t
                                } = this;
                                t.activeTexture(this.contextHandle), t.bindTexture(t.TEXTURE_2D, this.texture), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.NEAREST), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t.NEAREST)
                            }
                            setupTexture() {
                                this.contextHandle = this.onRequestContextHandle(), this.index = this.onRequestIndex(), this.dimensionsId = this.id + "Dim", this.sizeId = this.id + "Size"
                            }
                            getBitRatio(t) {
                                if (Array.isArray(t[0])) return this.getBitRatio(t[0]);
                                if (t.constructor === s) return this.getBitRatio(t.value);
                                switch (t.constructor) {
                                    case Uint8ClampedArray:
                                    case Uint8Array:
                                    case Int8Array:
                                        return 1;
                                    case Uint16Array:
                                    case Int16Array:
                                        return 2;
                                    case Float32Array:
                                    case Int32Array:
                                    default:
                                        return 4
                                }
                            }
                            destroy() {
                                this.prevArg && this.prevArg.delete(), this.context.deleteTexture(this.texture)
                            }
                        }
                    }
                }, {
                    "../../../input": 110,
                    "./index": 59
                }],
                41: [function(t, e, n) {
                    const {
                        WebGLKernelValue: i
                    } = t("./index");
                    e.exports = {
                        WebGLKernelValueArray2: class extends i {
                            constructor(t, e) {
                                super(t, e), this.uploadValue = t
                            }
                            getSource(t) {
                                return "constants" === this.origin ? `const vec2 ${this.id} = vec2(${t[0]},${t[1]});\n` : `uniform vec2 ${this.id};\n`
                            }
                            getStringValueHandler() {
                                return "constants" === this.origin ? "" : `const uploadValue_${this.name} = ${this.varName};\n`
                            }
                            updateValue(t) {
                                "constants" !== this.origin && this.kernel.setUniform2fv(this.id, this.uploadValue = t)
                            }
                        }
                    }
                }, {
                    "./index": 59
                }],
                42: [function(t, e, n) {
                    const {
                        WebGLKernelValue: i
                    } = t("./index");
                    e.exports = {
                        WebGLKernelValueArray3: class extends i {
                            constructor(t, e) {
                                super(t, e), this.uploadValue = t
                            }
                            getSource(t) {
                                return "constants" === this.origin ? `const vec3 ${this.id} = vec3(${t[0]},${t[1]},${t[2]});\n` : `uniform vec3 ${this.id};\n`
                            }
                            getStringValueHandler() {
                                return "constants" === this.origin ? "" : `const uploadValue_${this.name} = ${this.varName};\n`
                            }
                            updateValue(t) {
                                "constants" !== this.origin && this.kernel.setUniform3fv(this.id, this.uploadValue = t)
                            }
                        }
                    }
                }, {
                    "./index": 59
                }],
                43: [function(t, e, n) {
                    const {
                        WebGLKernelValue: i
                    } = t("./index");
                    e.exports = {
                        WebGLKernelValueArray4: class extends i {
                            constructor(t, e) {
                                super(t, e), this.uploadValue = t
                            }
                            getSource(t) {
                                return "constants" === this.origin ? `const vec4 ${this.id} = vec4(${t[0]},${t[1]},${t[2]},${t[3]});\n` : `uniform vec4 ${this.id};\n`
                            }
                            getStringValueHandler() {
                                return "constants" === this.origin ? "" : `const uploadValue_${this.name} = ${this.varName};\n`
                            }
                            updateValue(t) {
                                "constants" !== this.origin && this.kernel.setUniform4fv(this.id, this.uploadValue = t)
                            }
                        }
                    }
                }, {
                    "./index": 59
                }],
                44: [function(t, e, n) {
                    const {
                        utils: i
                    } = t("../../../utils"), {
                        WebGLKernelValue: s
                    } = t("./index");
                    e.exports = {
                        WebGLKernelValueBoolean: class extends s {
                            constructor(t, e) {
                                super(t, e), this.uploadValue = t
                            }
                            getSource(t) {
                                return "constants" === this.origin ? `const bool ${this.id} = ${t};\n` : `uniform bool ${this.id};\n`
                            }
                            getStringValueHandler() {
                                return `const uploadValue_${this.name} = ${this.varName};\n`
                            }
                            updateValue(t) {
                                "constants" !== this.origin && this.kernel.setUniform1i(this.id, this.uploadValue = t)
                            }
                        }
                    }
                }, {
                    "../../../utils": 114,
                    "./index": 59
                }],
                45: [function(t, e, n) {
                    const {
                        utils: i
                    } = t("../../../utils"), {
                        WebGLKernelValueHTMLImage: s
                    } = t("./html-image");
                    e.exports = {
                        WebGLKernelValueDynamicHTMLImage: class extends s {
                            getSource() {
                                return i.linesToString([`uniform sampler2D ${this.id}`, `uniform ivec2 ${this.sizeId}`, `uniform ivec3 ${this.dimensionsId}`])
                            }
                            updateValue(t) {
                                const {
                                    width: e,
                                    height: n
                                } = t;
                                this.checkSize(e, n), this.dimensions = [e, n, 1], this.textureSize = [e, n], this.kernel.setUniform3iv(this.dimensionsId, this.dimensions), this.kernel.setUniform2iv(this.sizeId, this.textureSize), super.updateValue(t)
                            }
                        }
                    }
                }, {
                    "../../../utils": 114,
                    "./html-image": 57
                }],
                46: [function(t, e, n) {
                    const {
                        WebGLKernelValueDynamicHTMLImage: i
                    } = t("./dynamic-html-image");
                    e.exports = {
                        WebGLKernelValueDynamicHTMLVideo: class extends i {}
                    }
                }, {
                    "./dynamic-html-image": 45
                }],
                47: [function(t, e, n) {
                    const {
                        utils: i
                    } = t("../../../utils"), {
                        WebGLKernelValueMemoryOptimizedNumberTexture: s
                    } = t("./memory-optimized-number-texture");
                    e.exports = {
                        WebGLKernelValueDynamicMemoryOptimizedNumberTexture: class extends s {
                            getSource() {
                                return i.linesToString([`uniform sampler2D ${this.id}`, `uniform ivec2 ${this.sizeId}`, `uniform ivec3 ${this.dimensionsId}`])
                            }
                            updateValue(t) {
                                this.dimensions = t.dimensions, this.checkSize(t.size[0], t.size[1]), this.textureSize = t.size, this.kernel.setUniform3iv(this.dimensionsId, this.dimensions), this.kernel.setUniform2iv(this.sizeId, this.textureSize), super.updateValue(t)
                            }
                        }
                    }
                }, {
                    "../../../utils": 114,
                    "./memory-optimized-number-texture": 61
                }],
                48: [function(t, e, n) {
                    const {
                        utils: i
                    } = t("../../../utils"), {
                        WebGLKernelValueNumberTexture: s
                    } = t("./number-texture");
                    e.exports = {
                        WebGLKernelValueDynamicNumberTexture: class extends s {
                            getSource() {
                                return i.linesToString([`uniform sampler2D ${this.id}`, `uniform ivec2 ${this.sizeId}`, `uniform ivec3 ${this.dimensionsId}`])
                            }
                            updateValue(t) {
                                this.dimensions = t.dimensions, this.checkSize(t.size[0], t.size[1]), this.textureSize = t.size, this.kernel.setUniform3iv(this.dimensionsId, this.dimensions), this.kernel.setUniform2iv(this.sizeId, this.textureSize), super.updateValue(t)
                            }
                        }
                    }
                }, {
                    "../../../utils": 114,
                    "./number-texture": 62
                }],
                49: [function(t, e, n) {
                    const {
                        utils: i
                    } = t("../../../utils"), {
                        WebGLKernelValueSingleArray: s
                    } = t("./single-array");
                    e.exports = {
                        WebGLKernelValueDynamicSingleArray: class extends s {
                            getSource() {
                                return i.linesToString([`uniform sampler2D ${this.id}`, `uniform ivec2 ${this.sizeId}`, `uniform ivec3 ${this.dimensionsId}`])
                            }
                            updateValue(t) {
                                this.dimensions = i.getDimensions(t, !0), this.textureSize = i.getMemoryOptimizedFloatTextureSize(this.dimensions, this.bitRatio), this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio, this.checkSize(this.textureSize[0], this.textureSize[1]), this.uploadValue = new Float32Array(this.uploadArrayLength), this.kernel.setUniform3iv(this.dimensionsId, this.dimensions), this.kernel.setUniform2iv(this.sizeId, this.textureSize), super.updateValue(t)
                            }
                        }
                    }
                }, {
                    "../../../utils": 114,
                    "./single-array": 63
                }],
                50: [function(t, e, n) {
                    const {
                        utils: i
                    } = t("../../../utils"), {
                        WebGLKernelValueSingleArray1DI: s
                    } = t("./single-array1d-i");
                    e.exports = {
                        WebGLKernelValueDynamicSingleArray1DI: class extends s {
                            getSource() {
                                return i.linesToString([`uniform sampler2D ${this.id}`, `uniform ivec2 ${this.sizeId}`, `uniform ivec3 ${this.dimensionsId}`])
                            }
                            updateValue(t) {
                                this.setShape(t), this.kernel.setUniform3iv(this.dimensionsId, this.dimensions), this.kernel.setUniform2iv(this.sizeId, this.textureSize), super.updateValue(t)
                            }
                        }
                    }
                }, {
                    "../../../utils": 114,
                    "./single-array1d-i": 64
                }],
                51: [function(t, e, n) {
                    const {
                        utils: i
                    } = t("../../../utils"), {
                        WebGLKernelValueSingleArray2DI: s
                    } = t("./single-array2d-i");
                    e.exports = {
                        WebGLKernelValueDynamicSingleArray2DI: class extends s {
                            getSource() {
                                return i.linesToString([`uniform sampler2D ${this.id}`, `uniform ivec2 ${this.sizeId}`, `uniform ivec3 ${this.dimensionsId}`])
                            }
                            updateValue(t) {
                                this.setShape(t), this.kernel.setUniform3iv(this.dimensionsId, this.dimensions), this.kernel.setUniform2iv(this.sizeId, this.textureSize), super.updateValue(t)
                            }
                        }
                    }
                }, {
                    "../../../utils": 114,
                    "./single-array2d-i": 65
                }],
                52: [function(t, e, n) {
                    const {
                        utils: i
                    } = t("../../../utils"), {
                        WebGLKernelValueSingleArray3DI: s
                    } = t("./single-array3d-i");
                    e.exports = {
                        WebGLKernelValueDynamicSingleArray3DI: class extends s {
                            getSource() {
                                return i.linesToString([`uniform sampler2D ${this.id}`, `uniform ivec2 ${this.sizeId}`, `uniform ivec3 ${this.dimensionsId}`])
                            }
                            updateValue(t) {
                                this.setShape(t), this.kernel.setUniform3iv(this.dimensionsId, this.dimensions), this.kernel.setUniform2iv(this.sizeId, this.textureSize), super.updateValue(t)
                            }
                        }
                    }
                }, {
                    "../../../utils": 114,
                    "./single-array3d-i": 66
                }],
                53: [function(t, e, n) {
                    const {
                        utils: i
                    } = t("../../../utils"), {
                        WebGLKernelValueSingleInput: s
                    } = t("./single-input");
                    e.exports = {
                        WebGLKernelValueDynamicSingleInput: class extends s {
                            getSource() {
                                return i.linesToString([`uniform sampler2D ${this.id}`, `uniform ivec2 ${this.sizeId}`, `uniform ivec3 ${this.dimensionsId}`])
                            }
                            updateValue(t) {
                                let [e, n, s] = t.size;
                                this.dimensions = new Int32Array([e || 1, n || 1, s || 1]), this.textureSize = i.getMemoryOptimizedFloatTextureSize(this.dimensions, this.bitRatio), this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio, this.checkSize(this.textureSize[0], this.textureSize[1]), this.uploadValue = new Float32Array(this.uploadArrayLength), this.kernel.setUniform3iv(this.dimensionsId, this.dimensions), this.kernel.setUniform2iv(this.sizeId, this.textureSize), super.updateValue(t)
                            }
                        }
                    }
                }, {
                    "../../../utils": 114,
                    "./single-input": 67
                }],
                54: [function(t, e, n) {
                    const {
                        utils: i
                    } = t("../../../utils"), {
                        WebGLKernelValueUnsignedArray: s
                    } = t("./unsigned-array");
                    e.exports = {
                        WebGLKernelValueDynamicUnsignedArray: class extends s {
                            getSource() {
                                return i.linesToString([`uniform sampler2D ${this.id}`, `uniform ivec2 ${this.sizeId}`, `uniform ivec3 ${this.dimensionsId}`])
                            }
                            updateValue(t) {
                                this.dimensions = i.getDimensions(t, !0), this.textureSize = i.getMemoryOptimizedPackedTextureSize(this.dimensions, this.bitRatio), this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * (4 / this.bitRatio), this.checkSize(this.textureSize[0], this.textureSize[1]);
                                const e = this.getTransferArrayType(t);
                                this.preUploadValue = new e(this.uploadArrayLength), this.uploadValue = new Uint8Array(this.preUploadValue.buffer), this.kernel.setUniform3iv(this.dimensionsId, this.dimensions), this.kernel.setUniform2iv(this.sizeId, this.textureSize), super.updateValue(t)
                            }
                        }
                    }
                }, {
                    "../../../utils": 114,
                    "./unsigned-array": 68
                }],
                55: [function(t, e, n) {
                    const {
                        utils: i
                    } = t("../../../utils"), {
                        WebGLKernelValueUnsignedInput: s
                    } = t("./unsigned-input");
                    e.exports = {
                        WebGLKernelValueDynamicUnsignedInput: class extends s {
                            getSource() {
                                return i.linesToString([`uniform sampler2D ${this.id}`, `uniform ivec2 ${this.sizeId}`, `uniform ivec3 ${this.dimensionsId}`])
                            }
                            updateValue(t) {
                                let [e, n, s] = t.size;
                                this.dimensions = new Int32Array([e || 1, n || 1, s || 1]), this.textureSize = i.getMemoryOptimizedPackedTextureSize(this.dimensions, this.bitRatio), this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * (4 / this.bitRatio), this.checkSize(this.textureSize[0], this.textureSize[1]);
                                const r = this.getTransferArrayType(t.value);
                                this.preUploadValue = new r(this.uploadArrayLength), this.uploadValue = new Uint8Array(this.preUploadValue.buffer), this.kernel.setUniform3iv(this.dimensionsId, this.dimensions), this.kernel.setUniform2iv(this.sizeId, this.textureSize), super.updateValue(t)
                            }
                        }
                    }
                }, {
                    "../../../utils": 114,
                    "./unsigned-input": 69
                }],
                56: [function(t, e, n) {
                    const {
                        utils: i
                    } = t("../../../utils"), {
                        WebGLKernelValue: s
                    } = t("./index");
                    e.exports = {
                        WebGLKernelValueFloat: class extends s {
                            constructor(t, e) {
                                super(t, e), this.uploadValue = t
                            }
                            getStringValueHandler() {
                                return `const uploadValue_${this.name} = ${this.varName};\n`
                            }
                            getSource(t) {
                                return "constants" === this.origin ? Number.isInteger(t) ? `const float ${this.id} = ${t}.0;\n` : `const float ${this.id} = ${t};\n` : `uniform float ${this.id};\n`
                            }
                            updateValue(t) {
                                "constants" !== this.origin && this.kernel.setUniform1f(this.id, this.uploadValue = t)
                            }
                        }
                    }
                }, {
                    "../../../utils": 114,
                    "./index": 59
                }],
                57: [function(t, e, n) {
                    const {
                        utils: i
                    } = t("../../../utils"), {
                        WebGLKernelArray: s
                    } = t("./array");
                    e.exports = {
                        WebGLKernelValueHTMLImage: class extends s {
                            constructor(t, e) {
                                super(t, e);
                                const {
                                    width: n,
                                    height: i
                                } = t;
                                this.checkSize(n, i), this.dimensions = [n, i, 1], this.textureSize = [n, i], this.uploadValue = t
                            }
                            getStringValueHandler() {
                                return `const uploadValue_${this.name} = ${this.varName};\n`
                            }
                            getSource() {
                                return i.linesToString([`uniform sampler2D ${this.id}`, `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`, `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`])
                            }
                            updateValue(t) {
                                if (t.constructor !== this.initialValueConstructor) return void this.onUpdateValueMismatch(t.constructor);
                                const {
                                    context: e
                                } = this;
                                e.activeTexture(this.contextHandle), e.bindTexture(e.TEXTURE_2D, this.texture), e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, !0), e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, this.uploadValue = t), this.kernel.setUniform1i(this.id, this.index)
                            }
                        }
                    }
                }, {
                    "../../../utils": 114,
                    "./array": 40
                }],
                58: [function(t, e, n) {
                    const {
                        WebGLKernelValueHTMLImage: i
                    } = t("./html-image");
                    e.exports = {
                        WebGLKernelValueHTMLVideo: class extends i {}
                    }
                }, {
                    "./html-image": 57
                }],
                59: [function(t, e, n) {
                    const {
                        utils: i
                    } = t("../../../utils"), {
                        KernelValue: s
                    } = t("../../kernel-value");
                    e.exports = {
                        WebGLKernelValue: class extends s {
                            constructor(t, e) {
                                super(t, e), this.dimensionsId = null, this.sizeId = null, this.initialValueConstructor = t.constructor, this.onRequestTexture = e.onRequestTexture, this.onRequestIndex = e.onRequestIndex, this.uploadValue = null, this.textureSize = null, this.bitRatio = null, this.prevArg = null
                            }
                            get id() {
                                return `${this.origin}_${i.sanitizeName(this.name)}`
                            }
                            setup() {}
                            getTransferArrayType(t) {
                                if (Array.isArray(t[0])) return this.getTransferArrayType(t[0]);
                                switch (t.constructor) {
                                    case Array:
                                    case Int32Array:
                                    case Int16Array:
                                    case Int8Array:
                                        return Float32Array;
                                    case Uint8ClampedArray:
                                    case Uint8Array:
                                    case Uint16Array:
                                    case Uint32Array:
                                    case Float32Array:
                                    case Float64Array:
                                        return t.constructor
                                }
                                return console.warn("Unfamiliar constructor type.  Will go ahead and use, but likley this may result in a transfer of zeros"), t.constructor
                            }
                            getStringValueHandler() {
                                throw new Error(`"getStringValueHandler" not implemented on ${this.constructor.name}`)
                            }
                            getVariablePrecisionString() {
                                return this.kernel.getVariablePrecisionString(this.textureSize || void 0, this.tactic || void 0)
                            }
                            destroy() {}
                        }
                    }
                }, {
                    "../../../utils": 114,
                    "../../kernel-value": 35
                }],
                60: [function(t, e, n) {
                    const {
                        utils: i
                    } = t("../../../utils"), {
                        WebGLKernelValue: s
                    } = t("./index");
                    e.exports = {
                        WebGLKernelValueInteger: class extends s {
                            constructor(t, e) {
                                super(t, e), this.uploadValue = t
                            }
                            getStringValueHandler() {
                                return `const uploadValue_${this.name} = ${this.varName};\n`
                            }
                            getSource(t) {
                                return "constants" === this.origin ? `const int ${this.id} = ${parseInt(t)};\n` : `uniform int ${this.id};\n`
                            }
                            updateValue(t) {
                                "constants" !== this.origin && this.kernel.setUniform1i(this.id, this.uploadValue = t)
                            }
                        }
                    }
                }, {
                    "../../../utils": 114,
                    "./index": 59
                }],
                61: [function(t, e, n) {
                    const {
                        utils: i
                    } = t("../../../utils"), {
                        WebGLKernelArray: s
                    } = t("./array"), r = "Source and destination textures are the same.  Use immutable = true and manually cleanup kernel output texture memory with texture.delete()";
                    e.exports = {
                        WebGLKernelValueMemoryOptimizedNumberTexture: class extends s {
                            constructor(t, e) {
                                super(t, e);
                                const [n, i] = t.size;
                                this.checkSize(n, i), this.dimensions = t.dimensions, this.textureSize = t.size, this.uploadValue = t.texture, this.forceUploadEachRun = !0
                            }
                            setup() {
                                this.setupTexture()
                            }
                            getStringValueHandler() {
                                return `const uploadValue_${this.name} = ${this.varName}.texture;\n`
                            }
                            getSource() {
                                return i.linesToString([`uniform sampler2D ${this.id}`, `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`, `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`])
                            }
                            updateValue(t) {
                                if (t.constructor !== this.initialValueConstructor) return void this.onUpdateValueMismatch(t.constructor);
                                if (this.checkContext && t.context !== this.context) throw new Error(`Value ${this.name} (${this.type}) must be from same context`);
                                const {
                                    kernel: e,
                                    context: n
                                } = this;
                                if (e.pipeline)
                                    if (e.immutable) e.updateTextureArgumentRefs(this, t);
                                    else {
                                        if (e.texture && e.texture.texture === t.texture) throw new Error(r);
                                        if (e.mappedTextures) {
                                            const {
                                                mappedTextures: n
                                            } = e;
                                            for (let e = 0; e < n.length; e++)
                                                if (n[e].texture === t.texture) throw new Error(r)
                                        }
                                    } n.activeTexture(this.contextHandle), n.bindTexture(n.TEXTURE_2D, this.uploadValue = t.texture), this.kernel.setUniform1i(this.id, this.index)
                            }
                        },
                        sameError: r
                    }
                }, {
                    "../../../utils": 114,
                    "./array": 40
                }],
                62: [function(t, e, n) {
                    const {
                        utils: i
                    } = t("../../../utils"), {
                        WebGLKernelArray: s
                    } = t("./array"), {
                        sameError: r
                    } = t("./memory-optimized-number-texture");
                    e.exports = {
                        WebGLKernelValueNumberTexture: class extends s {
                            constructor(t, e) {
                                super(t, e);
                                const [n, i] = t.size;
                                this.checkSize(n, i);
                                const {
                                    size: s,
                                    dimensions: r
                                } = t;
                                this.bitRatio = this.getBitRatio(t), this.dimensions = r, this.textureSize = s, this.uploadValue = t.texture, this.forceUploadEachRun = !0
                            }
                            setup() {
                                this.setupTexture()
                            }
                            getStringValueHandler() {
                                return `const uploadValue_${this.name} = ${this.varName}.texture;\n`
                            }
                            getSource() {
                                return i.linesToString([`uniform sampler2D ${this.id}`, `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`, `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`])
                            }
                            updateValue(t) {
                                if (t.constructor !== this.initialValueConstructor) return void this.onUpdateValueMismatch(t.constructor);
                                if (this.checkContext && t.context !== this.context) throw new Error(`Value ${this.name} (${this.type}) must be from same context`);
                                const {
                                    kernel: e,
                                    context: n
                                } = this;
                                if (e.pipeline)
                                    if (e.immutable) e.updateTextureArgumentRefs(this, t);
                                    else {
                                        if (e.texture && e.texture.texture === t.texture) throw new Error(r);
                                        if (e.mappedTextures) {
                                            const {
                                                mappedTextures: n
                                            } = e;
                                            for (let e = 0; e < n.length; e++)
                                                if (n[e].texture === t.texture) throw new Error(r)
                                        }
                                    } n.activeTexture(this.contextHandle), n.bindTexture(n.TEXTURE_2D, this.uploadValue = t.texture), this.kernel.setUniform1i(this.id, this.index)
                            }
                        }
                    }
                }, {
                    "../../../utils": 114,
                    "./array": 40,
                    "./memory-optimized-number-texture": 61
                }],
                63: [function(t, e, n) {
                    const {
                        utils: i
                    } = t("../../../utils"), {
                        WebGLKernelArray: s
                    } = t("./array");
                    e.exports = {
                        WebGLKernelValueSingleArray: class extends s {
                            constructor(t, e) {
                                super(t, e), this.bitRatio = 4, this.dimensions = i.getDimensions(t, !0), this.textureSize = i.getMemoryOptimizedFloatTextureSize(this.dimensions, this.bitRatio), this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio, this.checkSize(this.textureSize[0], this.textureSize[1]), this.uploadValue = new Float32Array(this.uploadArrayLength)
                            }
                            getStringValueHandler() {
                                return i.linesToString([`const uploadValue_${this.name} = new Float32Array(${this.uploadArrayLength})`, `flattenTo(${this.varName}, uploadValue_${this.name})`])
                            }
                            getSource() {
                                return i.linesToString([`uniform sampler2D ${this.id}`, `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`, `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`])
                            }
                            updateValue(t) {
                                if (t.constructor !== this.initialValueConstructor) return void this.onUpdateValueMismatch(t.constructor);
                                const {
                                    context: e
                                } = this;
                                i.flattenTo(t, this.uploadValue), e.activeTexture(this.contextHandle), e.bindTexture(e.TEXTURE_2D, this.texture), e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, !1), e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, this.textureSize[0], this.textureSize[1], 0, e.RGBA, e.FLOAT, this.uploadValue), this.kernel.setUniform1i(this.id, this.index)
                            }
                        }
                    }
                }, {
                    "../../../utils": 114,
                    "./array": 40
                }],
                64: [function(t, e, n) {
                    const {
                        utils: i
                    } = t("../../../utils"), {
                        WebGLKernelArray: s
                    } = t("./array");
                    e.exports = {
                        WebGLKernelValueSingleArray1DI: class extends s {
                            constructor(t, e) {
                                super(t, e), this.bitRatio = 4, this.setShape(t)
                            }
                            setShape(t) {
                                const e = i.getDimensions(t, !0);
                                this.textureSize = i.getMemoryOptimizedFloatTextureSize(e, this.bitRatio), this.dimensions = new Int32Array([e[1], 1, 1]), this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio, this.checkSize(this.textureSize[0], this.textureSize[1]), this.uploadValue = new Float32Array(this.uploadArrayLength)
                            }
                            getStringValueHandler() {
                                return i.linesToString([`const uploadValue_${this.name} = new Float32Array(${this.uploadArrayLength})`, `flattenTo(${this.varName}, uploadValue_${this.name})`])
                            }
                            getSource() {
                                return i.linesToString([`uniform sampler2D ${this.id}`, `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`, `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`])
                            }
                            updateValue(t) {
                                if (t.constructor !== this.initialValueConstructor) return void this.onUpdateValueMismatch(t.constructor);
                                const {
                                    context: e
                                } = this;
                                i.flatten2dArrayTo(t, this.uploadValue), e.activeTexture(this.contextHandle), e.bindTexture(e.TEXTURE_2D, this.texture), e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, !1), e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, this.textureSize[0], this.textureSize[1], 0, e.RGBA, e.FLOAT, this.uploadValue), this.kernel.setUniform1i(this.id, this.index)
                            }
                        }
                    }
                }, {
                    "../../../utils": 114,
                    "./array": 40
                }],
                65: [function(t, e, n) {
                    const {
                        utils: i
                    } = t("../../../utils"), {
                        WebGLKernelArray: s
                    } = t("./array");
                    e.exports = {
                        WebGLKernelValueSingleArray2DI: class extends s {
                            constructor(t, e) {
                                super(t, e), this.bitRatio = 4, this.setShape(t)
                            }
                            setShape(t) {
                                const e = i.getDimensions(t, !0);
                                this.textureSize = i.getMemoryOptimizedFloatTextureSize(e, this.bitRatio), this.dimensions = new Int32Array([e[1], e[2], 1]), this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio, this.checkSize(this.textureSize[0], this.textureSize[1]), this.uploadValue = new Float32Array(this.uploadArrayLength)
                            }
                            getStringValueHandler() {
                                return i.linesToString([`const uploadValue_${this.name} = new Float32Array(${this.uploadArrayLength})`, `flattenTo(${this.varName}, uploadValue_${this.name})`])
                            }
                            getSource() {
                                return i.linesToString([`uniform sampler2D ${this.id}`, `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`, `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`])
                            }
                            updateValue(t) {
                                if (t.constructor !== this.initialValueConstructor) return void this.onUpdateValueMismatch(t.constructor);
                                const {
                                    context: e
                                } = this;
                                i.flatten3dArrayTo(t, this.uploadValue), e.activeTexture(this.contextHandle), e.bindTexture(e.TEXTURE_2D, this.texture), e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, !1), e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, this.textureSize[0], this.textureSize[1], 0, e.RGBA, e.FLOAT, this.uploadValue), this.kernel.setUniform1i(this.id, this.index)
                            }
                        }
                    }
                }, {
                    "../../../utils": 114,
                    "./array": 40
                }],
                66: [function(t, e, n) {
                    const {
                        utils: i
                    } = t("../../../utils"), {
                        WebGLKernelArray: s
                    } = t("./array");
                    e.exports = {
                        WebGLKernelValueSingleArray3DI: class extends s {
                            constructor(t, e) {
                                super(t, e), this.bitRatio = 4, this.setShape(t)
                            }
                            setShape(t) {
                                const e = i.getDimensions(t, !0);
                                this.textureSize = i.getMemoryOptimizedFloatTextureSize(e, this.bitRatio), this.dimensions = new Int32Array([e[1], e[2], e[3]]), this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio, this.checkSize(this.textureSize[0], this.textureSize[1]), this.uploadValue = new Float32Array(this.uploadArrayLength)
                            }
                            getStringValueHandler() {
                                return i.linesToString([`const uploadValue_${this.name} = new Float32Array(${this.uploadArrayLength})`, `flattenTo(${this.varName}, uploadValue_${this.name})`])
                            }
                            getSource() {
                                return i.linesToString([`uniform sampler2D ${this.id}`, `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`, `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`])
                            }
                            updateValue(t) {
                                if (t.constructor !== this.initialValueConstructor) return void this.onUpdateValueMismatch(t.constructor);
                                const {
                                    context: e
                                } = this;
                                i.flatten4dArrayTo(t, this.uploadValue), e.activeTexture(this.contextHandle), e.bindTexture(e.TEXTURE_2D, this.texture), e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, !1), e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, this.textureSize[0], this.textureSize[1], 0, e.RGBA, e.FLOAT, this.uploadValue), this.kernel.setUniform1i(this.id, this.index)
                            }
                        }
                    }
                }, {
                    "../../../utils": 114,
                    "./array": 40
                }],
                67: [function(t, e, n) {
                    const {
                        utils: i
                    } = t("../../../utils"), {
                        WebGLKernelArray: s
                    } = t("./array");
                    e.exports = {
                        WebGLKernelValueSingleInput: class extends s {
                            constructor(t, e) {
                                super(t, e), this.bitRatio = 4;
                                let [n, s, r] = t.size;
                                this.dimensions = new Int32Array([n || 1, s || 1, r || 1]), this.textureSize = i.getMemoryOptimizedFloatTextureSize(this.dimensions, this.bitRatio), this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio, this.checkSize(this.textureSize[0], this.textureSize[1]), this.uploadValue = new Float32Array(this.uploadArrayLength)
                            }
                            getStringValueHandler() {
                                return i.linesToString([`const uploadValue_${this.name} = new Float32Array(${this.uploadArrayLength})`, `flattenTo(${this.varName}.value, uploadValue_${this.name})`])
                            }
                            getSource() {
                                return i.linesToString([`uniform sampler2D ${this.id}`, `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`, `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`])
                            }
                            updateValue(t) {
                                if (t.constructor !== this.initialValueConstructor) return void this.onUpdateValueMismatch(t.constructor);
                                const {
                                    context: e
                                } = this;
                                i.flattenTo(t.value, this.uploadValue), e.activeTexture(this.contextHandle), e.bindTexture(e.TEXTURE_2D, this.texture), e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, !1), e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, this.textureSize[0], this.textureSize[1], 0, e.RGBA, e.FLOAT, this.uploadValue), this.kernel.setUniform1i(this.id, this.index)
                            }
                        }
                    }
                }, {
                    "../../../utils": 114,
                    "./array": 40
                }],
                68: [function(t, e, n) {
                    const {
                        utils: i
                    } = t("../../../utils"), {
                        WebGLKernelArray: s
                    } = t("./array");
                    e.exports = {
                        WebGLKernelValueUnsignedArray: class extends s {
                            constructor(t, e) {
                                super(t, e), this.bitRatio = this.getBitRatio(t), this.dimensions = i.getDimensions(t, !0), this.textureSize = i.getMemoryOptimizedPackedTextureSize(this.dimensions, this.bitRatio), this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * (4 / this.bitRatio), this.checkSize(this.textureSize[0], this.textureSize[1]), this.TranserArrayType = this.getTransferArrayType(t), this.preUploadValue = new this.TranserArrayType(this.uploadArrayLength), this.uploadValue = new Uint8Array(this.preUploadValue.buffer)
                            }
                            getStringValueHandler() {
                                return i.linesToString([`const preUploadValue_${this.name} = new ${this.TranserArrayType.name}(${this.uploadArrayLength})`, `const uploadValue_${this.name} = new Uint8Array(preUploadValue_${this.name}.buffer)`, `flattenTo(${this.varName}, preUploadValue_${this.name})`])
                            }
                            getSource() {
                                return i.linesToString([`uniform sampler2D ${this.id}`, `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`, `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`])
                            }
                            updateValue(t) {
                                if (t.constructor !== this.initialValueConstructor) return void this.onUpdateValueMismatch(t.constructor);
                                const {
                                    context: e
                                } = this;
                                i.flattenTo(t, this.preUploadValue), e.activeTexture(this.contextHandle), e.bindTexture(e.TEXTURE_2D, this.texture), e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, !1), e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, this.textureSize[0], this.textureSize[1], 0, e.RGBA, e.UNSIGNED_BYTE, this.uploadValue), this.kernel.setUniform1i(this.id, this.index)
                            }
                        }
                    }
                }, {
                    "../../../utils": 114,
                    "./array": 40
                }],
                69: [function(t, e, n) {
                    const {
                        utils: i
                    } = t("../../../utils"), {
                        WebGLKernelArray: s
                    } = t("./array");
                    e.exports = {
                        WebGLKernelValueUnsignedInput: class extends s {
                            constructor(t, e) {
                                super(t, e), this.bitRatio = this.getBitRatio(t);
                                const [n, s, r] = t.size;
                                this.dimensions = new Int32Array([n || 1, s || 1, r || 1]), this.textureSize = i.getMemoryOptimizedPackedTextureSize(this.dimensions, this.bitRatio), this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * (4 / this.bitRatio), this.checkSize(this.textureSize[0], this.textureSize[1]), this.TranserArrayType = this.getTransferArrayType(t.value), this.preUploadValue = new this.TranserArrayType(this.uploadArrayLength), this.uploadValue = new Uint8Array(this.preUploadValue.buffer)
                            }
                            getStringValueHandler() {
                                return i.linesToString([`const preUploadValue_${this.name} = new ${this.TranserArrayType.name}(${this.uploadArrayLength})`, `const uploadValue_${this.name} = new Uint8Array(preUploadValue_${this.name}.buffer)`, `flattenTo(${this.varName}.value, preUploadValue_${this.name})`])
                            }
                            getSource() {
                                return i.linesToString([`uniform sampler2D ${this.id}`, `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`, `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`])
                            }
                            updateValue(t) {
                                if (t.constructor !== this.initialValueConstructor) return void this.onUpdateValueMismatch(value.constructor);
                                const {
                                    context: e
                                } = this;
                                i.flattenTo(t.value, this.preUploadValue), e.activeTexture(this.contextHandle), e.bindTexture(e.TEXTURE_2D, this.texture), e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, !1), e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, this.textureSize[0], this.textureSize[1], 0, e.RGBA, e.UNSIGNED_BYTE, this.uploadValue), this.kernel.setUniform1i(this.id, this.index)
                            }
                        }
                    }
                }, {
                    "../../../utils": 114,
                    "./array": 40
                }],
                70: [function(t, e, n) {
                    const {
                        GLKernel: i
                    } = t("../gl/kernel"), {
                        FunctionBuilder: s
                    } = t("../function-builder"), {
                        WebGLFunctionNode: r
                    } = t("./function-node"), {
                        utils: a
                    } = t("../../utils"), o = t("../../plugins/math-random-uniformly-distributed"), {
                        fragmentShader: u
                    } = t("./fragment-shader"), {
                        vertexShader: h
                    } = t("./vertex-shader"), {
                        glKernelString: l
                    } = t("../gl/kernel-string"), {
                        lookupKernelValueType: c
                    } = t("./kernel-value-maps");
                    let p = null,
                        d = null,
                        m = null,
                        g = null,
                        f = null;
                    const y = [o],
                        x = [],
                        _ = {};
                    e.exports = {
                        WebGLKernel: class extends i {
                            static get isSupported() {
                                return null !== p || (this.setupFeatureChecks(), p = this.isContextMatch(m)), p
                            }
                            static setupFeatureChecks() {
                                "undefined" != typeof document ? d = document.createElement("canvas") : "undefined" != typeof OffscreenCanvas && (d = new OffscreenCanvas(0, 0)), d && (m = d.getContext("webgl") || d.getContext("experimental-webgl"), m && m.getExtension && (g = {
                                    OES_texture_float: m.getExtension("OES_texture_float"),
                                    OES_texture_float_linear: m.getExtension("OES_texture_float_linear"),
                                    OES_element_index_uint: m.getExtension("OES_element_index_uint"),
                                    WEBGL_draw_buffers: m.getExtension("WEBGL_draw_buffers")
                                }, f = this.getFeatures()))
                            }
                            static isContextMatch(t) {
                                return "undefined" != typeof WebGLRenderingContext && t instanceof WebGLRenderingContext
                            }
                            static getIsTextureFloat() {
                                return Boolean(g.OES_texture_float)
                            }
                            static getIsDrawBuffers() {
                                return Boolean(g.WEBGL_draw_buffers)
                            }
                            static getChannelCount() {
                                return g.WEBGL_draw_buffers ? m.getParameter(g.WEBGL_draw_buffers.MAX_DRAW_BUFFERS_WEBGL) : 1
                            }
                            static getMaxTextureSize() {
                                return m.getParameter(m.MAX_TEXTURE_SIZE)
                            }
                            static lookupKernelValueType(t, e, n, i) {
                                return c(t, e, n, i)
                            }
                            static get testCanvas() {
                                return d
                            }
                            static get testContext() {
                                return m
                            }
                            static get features() {
                                return f
                            }
                            static get fragmentShader() {
                                return u
                            }
                            static get vertexShader() {
                                return h
                            }
                            constructor(t, e) {
                                super(t, e), this.program = null, this.pipeline = e.pipeline, this.endianness = a.systemEndianness(), this.extensions = {}, this.argumentTextureCount = 0, this.constantTextureCount = 0, this.fragShader = null, this.vertShader = null, this.drawBuffersMap = null, this.maxTexSize = null, this.onRequestSwitchKernel = null, this.texture = null, this.mappedTextures = null, this.mergeSettings(t.settings || e), this.threadDim = null, this.framebuffer = null, this.buffer = null, this.textureCache = [], this.programUniformLocationCache = {}, this.uniform1fCache = {}, this.uniform1iCache = {}, this.uniform2fCache = {}, this.uniform2fvCache = {}, this.uniform2ivCache = {}, this.uniform3fvCache = {}, this.uniform3ivCache = {}, this.uniform4fvCache = {}, this.uniform4ivCache = {}
                            }
                            initCanvas() {
                                if ("undefined" != typeof document) {
                                    const t = document.createElement("canvas");
                                    return t.width = 2, t.height = 2, t
                                }
                                if ("undefined" != typeof OffscreenCanvas) return new OffscreenCanvas(0, 0)
                            }
                            initContext() {
                                const t = {
                                    alpha: !1,
                                    depth: !1,
                                    antialias: !1
                                };
                                return this.canvas.getContext("webgl", t) || this.canvas.getContext("experimental-webgl", t)
                            }
                            initPlugins(t) {
                                const e = [],
                                    {
                                        source: n
                                    } = this;
                                if ("string" == typeof n)
                                    for (let t = 0; t < y.length; t++) {
                                        const i = y[t];
                                        n.match(i.functionMatch) && e.push(i)
                                    } else if ("object" == typeof n && t.pluginNames)
                                        for (let n = 0; n < y.length; n++) {
                                            const i = y[n];
                                            t.pluginNames.some((t => t === i.name)) && e.push(i)
                                        }
                                return e
                            }
                            initExtensions() {
                                this.extensions = {
                                    OES_texture_float: this.context.getExtension("OES_texture_float"),
                                    OES_texture_float_linear: this.context.getExtension("OES_texture_float_linear"),
                                    OES_element_index_uint: this.context.getExtension("OES_element_index_uint"),
                                    WEBGL_draw_buffers: this.context.getExtension("WEBGL_draw_buffers"),
                                    WEBGL_color_buffer_float: this.context.getExtension("WEBGL_color_buffer_float")
                                }
                            }
                            validateSettings(t) {
                                if (!this.validate) return void(this.texSize = a.getKernelTextureSize({
                                    optimizeFloatMemory: this.optimizeFloatMemory,
                                    precision: this.precision
                                }, this.output));
                                const {
                                    features: e
                                } = this.constructor;
                                if (!0 === this.optimizeFloatMemory && !e.isTextureFloat) throw new Error("Float textures are not supported");
                                if ("single" === this.precision && !e.isFloatRead) throw new Error("Single precision not supported");
                                if (!this.graphical && null === this.precision && e.isTextureFloat && (this.precision = e.isFloatRead ? "single" : "unsigned"), this.subKernels && this.subKernels.length > 0 && !this.extensions.WEBGL_draw_buffers) throw new Error("could not instantiate draw buffers extension");
                                if (null === this.fixIntegerDivisionAccuracy ? this.fixIntegerDivisionAccuracy = !e.isIntegerDivisionAccurate : this.fixIntegerDivisionAccuracy && e.isIntegerDivisionAccurate && (this.fixIntegerDivisionAccuracy = !1), this.checkOutput(), !this.output || 0 === this.output.length) {
                                    if (1 !== t.length) throw new Error("Auto output only supported for kernels with only one input");
                                    const e = a.getVariableType(t[0], this.strictIntegers);
                                    switch (e) {
                                        case "Array":
                                            this.output = a.getDimensions(e);
                                            break;
                                        case "NumberTexture":
                                        case "MemoryOptimizedNumberTexture":
                                        case "ArrayTexture(1)":
                                        case "ArrayTexture(2)":
                                        case "ArrayTexture(3)":
                                        case "ArrayTexture(4)":
                                            this.output = t[0].output;
                                            break;
                                        default:
                                            throw new Error("Auto output not supported for input type: " + e)
                                    }
                                }
                                if (this.graphical) {
                                    if (2 !== this.output.length) throw new Error("Output must have 2 dimensions on graphical mode");
                                    return "precision" === this.precision && (this.precision = "unsigned", console.warn("Cannot use graphical mode and single precision at the same time")), void(this.texSize = a.clone(this.output))
                                }
                                null === this.precision && e.isTextureFloat && (this.precision = "single"), this.texSize = a.getKernelTextureSize({
                                    optimizeFloatMemory: this.optimizeFloatMemory,
                                    precision: this.precision
                                }, this.output), this.checkTextureSize()
                            }
                            updateMaxTexSize() {
                                const {
                                    texSize: t,
                                    canvas: e
                                } = this;
                                if (null === this.maxTexSize) {
                                    let n = x.indexOf(e); - 1 === n && (n = x.length, x.push(e), _[n] = [t[0], t[1]]), this.maxTexSize = _[n]
                                }
                                this.maxTexSize[0] < t[0] && (this.maxTexSize[0] = t[0]), this.maxTexSize[1] < t[1] && (this.maxTexSize[1] = t[1])
                            }
                            setupArguments(t) {
                                this.kernelArguments = [], this.argumentTextureCount = 0;
                                const e = null === this.argumentTypes;
                                if (e && (this.argumentTypes = []), this.argumentSizes = [], this.argumentBitRatios = [], t.length < this.argumentNames.length) throw new Error("not enough arguments for kernel");
                                if (t.length > this.argumentNames.length) throw new Error("too many arguments for kernel");
                                const {
                                    context: n
                                } = this;
                                let i = 0;
                                const s = () => this.createTexture(),
                                    r = () => this.constantTextureCount + i++,
                                    o = t => {
                                        this.switchKernels({
                                            type: "argumentMismatch",
                                            needed: t
                                        })
                                    },
                                    u = () => n.TEXTURE0 + this.constantTextureCount + this.argumentTextureCount++;
                                for (let i = 0; i < t.length; i++) {
                                    const h = t[i],
                                        l = this.argumentNames[i];
                                    let c;
                                    e ? (c = a.getVariableType(h, this.strictIntegers), this.argumentTypes.push(c)) : c = this.argumentTypes[i];
                                    const p = this.constructor.lookupKernelValueType(c, this.dynamicArguments ? "dynamic" : "static", this.precision, t[i]);
                                    if (null === p) return this.requestFallback(t);
                                    const d = new p(h, {
                                        name: l,
                                        type: c,
                                        tactic: this.tactic,
                                        origin: "user",
                                        context: n,
                                        checkContext: this.checkContext,
                                        kernel: this,
                                        strictIntegers: this.strictIntegers,
                                        onRequestTexture: s,
                                        onRequestIndex: r,
                                        onUpdateValueMismatch: o,
                                        onRequestContextHandle: u
                                    });
                                    this.kernelArguments.push(d), d.setup(), this.argumentSizes.push(d.textureSize), this.argumentBitRatios[i] = d.bitRatio
                                }
                            }
                            createTexture() {
                                const t = this.context.createTexture();
                                return this.textureCache.push(t), t
                            }
                            setupConstants(t) {
                                const {
                                    context: e
                                } = this;
                                this.kernelConstants = [], this.forceUploadKernelConstants = [];
                                let n = null === this.constantTypes;
                                n && (this.constantTypes = {}), this.constantBitRatios = {};
                                let i = 0;
                                for (const s in this.constants) {
                                    const r = this.constants[s];
                                    let o;
                                    n ? (o = a.getVariableType(r, this.strictIntegers), this.constantTypes[s] = o) : o = this.constantTypes[s];
                                    const u = this.constructor.lookupKernelValueType(o, "static", this.precision, r);
                                    if (null === u) return this.requestFallback(t);
                                    const h = new u(r, {
                                        name: s,
                                        type: o,
                                        tactic: this.tactic,
                                        origin: "constants",
                                        context: this.context,
                                        checkContext: this.checkContext,
                                        kernel: this,
                                        strictIntegers: this.strictIntegers,
                                        onRequestTexture: () => this.createTexture(),
                                        onRequestIndex: () => i++,
                                        onRequestContextHandle: () => e.TEXTURE0 + this.constantTextureCount++
                                    });
                                    this.constantBitRatios[s] = h.bitRatio, this.kernelConstants.push(h), h.setup(), h.forceUploadEachRun && this.forceUploadKernelConstants.push(h)
                                }
                            }
                            build() {
                                if (this.built) return;
                                if (this.initExtensions(), this.validateSettings(arguments), this.setupConstants(arguments), this.fallbackRequested) return;
                                if (this.setupArguments(arguments), this.fallbackRequested) return;
                                this.updateMaxTexSize(), this.translateSource();
                                const t = this.pickRenderStrategy(arguments);
                                if (t) return t;
                                const {
                                    texSize: e,
                                    context: n,
                                    canvas: i
                                } = this;
                                n.enable(n.SCISSOR_TEST), this.pipeline && this.precision, n.viewport(0, 0, this.maxTexSize[0], this.maxTexSize[1]), i.width = this.maxTexSize[0], i.height = this.maxTexSize[1];
                                const s = this.threadDim = Array.from(this.output);
                                for (; s.length < 3;) s.push(1);
                                const r = this.getVertexShader(arguments),
                                    a = n.createShader(n.VERTEX_SHADER);
                                n.shaderSource(a, r), n.compileShader(a), this.vertShader = a;
                                const o = this.getFragmentShader(arguments),
                                    u = n.createShader(n.FRAGMENT_SHADER);
                                if (n.shaderSource(u, o), n.compileShader(u), this.fragShader = u, this.debug && (console.log("GLSL Shader Output:"), console.log(o)), !n.getShaderParameter(a, n.COMPILE_STATUS)) throw new Error("Error compiling vertex shader: " + n.getShaderInfoLog(a));
                                if (!n.getShaderParameter(u, n.COMPILE_STATUS)) throw new Error("Error compiling fragment shader: " + n.getShaderInfoLog(u));
                                const h = this.program = n.createProgram();
                                n.attachShader(h, a), n.attachShader(h, u), n.linkProgram(h), this.framebuffer = n.createFramebuffer(), this.framebuffer.width = e[0], this.framebuffer.height = e[1], this.rawValueFramebuffers = {};
                                const l = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]),
                                    c = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]),
                                    p = l.byteLength;
                                let d = this.buffer;
                                d ? n.bindBuffer(n.ARRAY_BUFFER, d) : (d = this.buffer = n.createBuffer(), n.bindBuffer(n.ARRAY_BUFFER, d), n.bufferData(n.ARRAY_BUFFER, l.byteLength + c.byteLength, n.STATIC_DRAW)), n.bufferSubData(n.ARRAY_BUFFER, 0, l), n.bufferSubData(n.ARRAY_BUFFER, p, c);
                                const m = n.getAttribLocation(this.program, "aPos");
                                n.enableVertexAttribArray(m), n.vertexAttribPointer(m, 2, n.FLOAT, !1, 0, 0);
                                const g = n.getAttribLocation(this.program, "aTexCoord");
                                n.enableVertexAttribArray(g), n.vertexAttribPointer(g, 2, n.FLOAT, !1, 0, p), n.bindFramebuffer(n.FRAMEBUFFER, this.framebuffer);
                                let f = 0;
                                n.useProgram(this.program);
                                for (let t in this.constants) this.kernelConstants[f++].updateValue(this.constants[t]);
                                this._setupOutputTexture(), null !== this.subKernels && this.subKernels.length > 0 && (this._mappedTextureSwitched = {}, this._setupSubOutputTextures()), this.buildSignature(arguments), this.built = !0
                            }
                            translateSource() {
                                const t = s.fromKernel(this, r, {
                                    fixIntegerDivisionAccuracy: this.fixIntegerDivisionAccuracy
                                });
                                this.translatedSource = t.getPrototypeString("kernel"), this.setupReturnTypes(t)
                            }
                            setupReturnTypes(t) {
                                if (this.graphical || this.returnType || (this.returnType = t.getKernelResultType()), this.subKernels && this.subKernels.length > 0)
                                    for (let e = 0; e < this.subKernels.length; e++) {
                                        const n = this.subKernels[e];
                                        n.returnType || (n.returnType = t.getSubKernelResultType(e))
                                    }
                            }
                            run() {
                                const {
                                    kernelArguments: t,
                                    texSize: e,
                                    forceUploadKernelConstants: n,
                                    context: i
                                } = this;
                                i.useProgram(this.program), i.scissor(0, 0, e[0], e[1]), this.dynamicOutput && (this.setUniform3iv("uOutputDim", new Int32Array(this.threadDim)), this.setUniform2iv("uTexSize", e)), this.setUniform2f("ratio", e[0] / this.maxTexSize[0], e[1] / this.maxTexSize[1]);
                                for (let t = 0; t < n.length; t++) {
                                    const e = n[t];
                                    if (e.updateValue(this.constants[e.name]), this.switchingKernels) return
                                }
                                for (let e = 0; e < t.length; e++)
                                    if (t[e].updateValue(arguments[e]), this.switchingKernels) return;
                                if (this.plugins)
                                    for (let t = 0; t < this.plugins.length; t++) {
                                        const e = this.plugins[t];
                                        e.onBeforeRun && e.onBeforeRun(this)
                                    }
                                if (this.graphical) return this.pipeline ? (i.bindRenderbuffer(i.RENDERBUFFER, null), i.bindFramebuffer(i.FRAMEBUFFER, this.framebuffer), this.immutable && this._replaceOutputTexture(), i.drawArrays(i.TRIANGLE_STRIP, 0, 4), this.immutable ? this.texture.clone() : this.texture) : (i.bindRenderbuffer(i.RENDERBUFFER, null), i.bindFramebuffer(i.FRAMEBUFFER, null), void i.drawArrays(i.TRIANGLE_STRIP, 0, 4));
                                i.bindFramebuffer(i.FRAMEBUFFER, this.framebuffer), this.immutable && this._replaceOutputTexture(), null !== this.subKernels && (this.immutable && this._replaceSubOutputTextures(), this.drawBuffers()), i.drawArrays(i.TRIANGLE_STRIP, 0, 4)
                            }
                            drawBuffers() {
                                this.extensions.WEBGL_draw_buffers.drawBuffersWEBGL(this.drawBuffersMap)
                            }
                            getInternalFormat() {
                                return this.context.RGBA
                            }
                            getTextureFormat() {
                                const {
                                    context: t
                                } = this;
                                if (this.getInternalFormat() === t.RGBA) return t.RGBA;
                                throw new Error("Unknown internal format")
                            }
                            _replaceOutputTexture() {
                                if (this.texture.beforeMutate() || this._textureSwitched) {
                                    const t = this.context;
                                    t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, this.texture.texture, 0), this._textureSwitched = !1
                                }
                            }
                            _setupOutputTexture() {
                                const t = this.context,
                                    e = this.texSize;
                                if (this.texture) return void t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, this.texture.texture, 0);
                                const n = this.createTexture();
                                t.activeTexture(t.TEXTURE0 + this.constantTextureCount + this.argumentTextureCount), t.bindTexture(t.TEXTURE_2D, n), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.NEAREST), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t.NEAREST);
                                const i = this.getInternalFormat();
                                "single" === this.precision ? t.texImage2D(t.TEXTURE_2D, 0, i, e[0], e[1], 0, t.RGBA, t.FLOAT, null) : t.texImage2D(t.TEXTURE_2D, 0, i, e[0], e[1], 0, i, t.UNSIGNED_BYTE, null), t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, n, 0), this.texture = new this.TextureConstructor({
                                    texture: n,
                                    size: e,
                                    dimensions: this.threadDim,
                                    output: this.output,
                                    context: this.context,
                                    internalFormat: this.getInternalFormat(),
                                    textureFormat: this.getTextureFormat(),
                                    kernel: this
                                })
                            }
                            _replaceSubOutputTextures() {
                                const t = this.context;
                                for (let e = 0; e < this.mappedTextures.length; e++) {
                                    const n = this.mappedTextures[e];
                                    (n.beforeMutate() || this._mappedTextureSwitched[e]) && (t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0 + e + 1, t.TEXTURE_2D, n.texture, 0), this._mappedTextureSwitched[e] = !1)
                                }
                            }
                            _setupSubOutputTextures() {
                                const t = this.context;
                                if (this.mappedTextures) {
                                    for (let e = 0; e < this.subKernels.length; e++) t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0 + e + 1, t.TEXTURE_2D, this.mappedTextures[e].texture, 0);
                                    return
                                }
                                const e = this.texSize;
                                this.drawBuffersMap = [t.COLOR_ATTACHMENT0], this.mappedTextures = [];
                                for (let n = 0; n < this.subKernels.length; n++) {
                                    const i = this.createTexture();
                                    this.drawBuffersMap.push(t.COLOR_ATTACHMENT0 + n + 1), t.activeTexture(t.TEXTURE0 + this.constantTextureCount + this.argumentTextureCount + n), t.bindTexture(t.TEXTURE_2D, i), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.NEAREST), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t.NEAREST), "single" === this.precision ? t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, e[0], e[1], 0, t.RGBA, t.FLOAT, null) : t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, e[0], e[1], 0, t.RGBA, t.UNSIGNED_BYTE, null), t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0 + n + 1, t.TEXTURE_2D, i, 0), this.mappedTextures.push(new this.TextureConstructor({
                                        texture: i,
                                        size: e,
                                        dimensions: this.threadDim,
                                        output: this.output,
                                        context: this.context,
                                        internalFormat: this.getInternalFormat(),
                                        textureFormat: this.getTextureFormat(),
                                        kernel: this
                                    }))
                                }
                            }
                            setUniform1f(t, e) {
                                if (this.uniform1fCache.hasOwnProperty(t) && e === this.uniform1fCache[t]) return;
                                this.uniform1fCache[t] = e;
                                const n = this.getUniformLocation(t);
                                this.context.uniform1f(n, e)
                            }
                            setUniform1i(t, e) {
                                if (this.uniform1iCache.hasOwnProperty(t) && e === this.uniform1iCache[t]) return;
                                this.uniform1iCache[t] = e;
                                const n = this.getUniformLocation(t);
                                this.context.uniform1i(n, e)
                            }
                            setUniform2f(t, e, n) {
                                if (this.uniform2fCache.hasOwnProperty(t)) {
                                    const i = this.uniform2fCache[t];
                                    if (e === i[0] && n === i[1]) return
                                }
                                this.uniform2fCache[t] = [e, n];
                                const i = this.getUniformLocation(t);
                                this.context.uniform2f(i, e, n)
                            }
                            setUniform2fv(t, e) {
                                if (this.uniform2fvCache.hasOwnProperty(t)) {
                                    const n = this.uniform2fvCache[t];
                                    if (e[0] === n[0] && e[1] === n[1]) return
                                }
                                this.uniform2fvCache[t] = e;
                                const n = this.getUniformLocation(t);
                                this.context.uniform2fv(n, e)
                            }
                            setUniform2iv(t, e) {
                                if (this.uniform2ivCache.hasOwnProperty(t)) {
                                    const n = this.uniform2ivCache[t];
                                    if (e[0] === n[0] && e[1] === n[1]) return
                                }
                                this.uniform2ivCache[t] = e;
                                const n = this.getUniformLocation(t);
                                this.context.uniform2iv(n, e)
                            }
                            setUniform3fv(t, e) {
                                if (this.uniform3fvCache.hasOwnProperty(t)) {
                                    const n = this.uniform3fvCache[t];
                                    if (e[0] === n[0] && e[1] === n[1] && e[2] === n[2]) return
                                }
                                this.uniform3fvCache[t] = e;
                                const n = this.getUniformLocation(t);
                                this.context.uniform3fv(n, e)
                            }
                            setUniform3iv(t, e) {
                                if (this.uniform3ivCache.hasOwnProperty(t)) {
                                    const n = this.uniform3ivCache[t];
                                    if (e[0] === n[0] && e[1] === n[1] && e[2] === n[2]) return
                                }
                                this.uniform3ivCache[t] = e;
                                const n = this.getUniformLocation(t);
                                this.context.uniform3iv(n, e)
                            }
                            setUniform4fv(t, e) {
                                if (this.uniform4fvCache.hasOwnProperty(t)) {
                                    const n = this.uniform4fvCache[t];
                                    if (e[0] === n[0] && e[1] === n[1] && e[2] === n[2] && e[3] === n[3]) return
                                }
                                this.uniform4fvCache[t] = e;
                                const n = this.getUniformLocation(t);
                                this.context.uniform4fv(n, e)
                            }
                            setUniform4iv(t, e) {
                                if (this.uniform4ivCache.hasOwnProperty(t)) {
                                    const n = this.uniform4ivCache[t];
                                    if (e[0] === n[0] && e[1] === n[1] && e[2] === n[2] && e[3] === n[3]) return
                                }
                                this.uniform4ivCache[t] = e;
                                const n = this.getUniformLocation(t);
                                this.context.uniform4iv(n, e)
                            }
                            getUniformLocation(t) {
                                return this.programUniformLocationCache.hasOwnProperty(t) ? this.programUniformLocationCache[t] : this.programUniformLocationCache[t] = this.context.getUniformLocation(this.program, t)
                            }
                            _getFragShaderArtifactMap(t) {
                                return {
                                    HEADER: this._getHeaderString(),
                                    LOOP_MAX: this._getLoopMaxString(),
                                    PLUGINS: this._getPluginsString(),
                                    CONSTANTS: this._getConstantsString(),
                                    DECODE32_ENDIANNESS: this._getDecode32EndiannessString(),
                                    ENCODE32_ENDIANNESS: this._getEncode32EndiannessString(),
                                    DIVIDE_WITH_INTEGER_CHECK: this._getDivideWithIntegerCheckString(),
                                    INJECTED_NATIVE: this._getInjectedNative(),
                                    MAIN_CONSTANTS: this._getMainConstantsString(),
                                    MAIN_ARGUMENTS: this._getMainArgumentsString(t),
                                    KERNEL: this.getKernelString(),
                                    MAIN_RESULT: this.getMainResultString(),
                                    FLOAT_TACTIC_DECLARATION: this.getFloatTacticDeclaration(),
                                    INT_TACTIC_DECLARATION: this.getIntTacticDeclaration(),
                                    SAMPLER_2D_TACTIC_DECLARATION: this.getSampler2DTacticDeclaration(),
                                    SAMPLER_2D_ARRAY_TACTIC_DECLARATION: this.getSampler2DArrayTacticDeclaration()
                                }
                            }
                            _getVertShaderArtifactMap(t) {
                                return {
                                    FLOAT_TACTIC_DECLARATION: this.getFloatTacticDeclaration(),
                                    INT_TACTIC_DECLARATION: this.getIntTacticDeclaration(),
                                    SAMPLER_2D_TACTIC_DECLARATION: this.getSampler2DTacticDeclaration(),
                                    SAMPLER_2D_ARRAY_TACTIC_DECLARATION: this.getSampler2DArrayTacticDeclaration()
                                }
                            }
                            _getHeaderString() {
                                return null !== this.subKernels ? "#extension GL_EXT_draw_buffers : require\n" : ""
                            }
                            _getLoopMaxString() {
                                return this.loopMaxIterations ? ` ${parseInt(this.loopMaxIterations)};\n` : " 1000;\n"
                            }
                            _getPluginsString() {
                                return this.plugins ? this.plugins.map((t => t.source && this.source.match(t.functionMatch) ? t.source : "")).join("\n") : "\n"
                            }
                            _getConstantsString() {
                                const t = [],
                                    {
                                        threadDim: e,
                                        texSize: n
                                    } = this;
                                return this.dynamicOutput ? t.push("uniform ivec3 uOutputDim", "uniform ivec2 uTexSize") : t.push(`ivec3 uOutputDim = ivec3(${e[0]}, ${e[1]}, ${e[2]})`, `ivec2 uTexSize = ivec2(${n[0]}, ${n[1]})`), a.linesToString(t)
                            }
                            _getTextureCoordinate() {
                                const t = this.subKernels;
                                return null === t || t.length < 1 ? "varying vec2 vTexCoord;\n" : "out vec2 vTexCoord;\n"
                            }
                            _getDecode32EndiannessString() {
                                return "LE" === this.endianness ? "" : "  texel.rgba = texel.abgr;\n"
                            }
                            _getEncode32EndiannessString() {
                                return "LE" === this.endianness ? "" : "  texel.rgba = texel.abgr;\n"
                            }
                            _getDivideWithIntegerCheckString() {
                                return this.fixIntegerDivisionAccuracy ? "float divWithIntCheck(float x, float y) {\n  if (floor(x) == x && floor(y) == y && integerMod(x, y) == 0.0) {\n    return float(int(x) / int(y));\n  }\n  return x / y;\n}\n\nfloat integerCorrectionModulo(float number, float divisor) {\n  if (number < 0.0) {\n    number = abs(number);\n    if (divisor < 0.0) {\n      divisor = abs(divisor);\n    }\n    return -(number - (divisor * floor(divWithIntCheck(number, divisor))));\n  }\n  if (divisor < 0.0) {\n    divisor = abs(divisor);\n  }\n  return number - (divisor * floor(divWithIntCheck(number, divisor)));\n}" : ""
                            }
                            _getMainArgumentsString(t) {
                                const e = [],
                                    {
                                        argumentNames: n
                                    } = this;
                                for (let i = 0; i < n.length; i++) e.push(this.kernelArguments[i].getSource(t[i]));
                                return e.join("")
                            }
                            _getInjectedNative() {
                                return this.injectedNative || ""
                            }
                            _getMainConstantsString() {
                                const t = [],
                                    {
                                        constants: e
                                    } = this;
                                if (e) {
                                    let n = 0;
                                    for (const i in e) this.constants.hasOwnProperty(i) && t.push(this.kernelConstants[n++].getSource(this.constants[i]))
                                }
                                return t.join("")
                            }
                            getRawValueFramebuffer(t, e) {
                                if (this.rawValueFramebuffers[t] || (this.rawValueFramebuffers[t] = {}), !this.rawValueFramebuffers[t][e]) {
                                    const n = this.context.createFramebuffer();
                                    n.width = t, n.height = e, this.rawValueFramebuffers[t][e] = n
                                }
                                return this.rawValueFramebuffers[t][e]
                            }
                            getKernelResultDeclaration() {
                                switch (this.returnType) {
                                    case "Array(2)":
                                        return "vec2 kernelResult";
                                    case "Array(3)":
                                        return "vec3 kernelResult";
                                    case "Array(4)":
                                        return "vec4 kernelResult";
                                    case "LiteralInteger":
                                    case "Float":
                                    case "Number":
                                    case "Integer":
                                        return "float kernelResult";
                                    default:
                                        if (this.graphical) return "float kernelResult";
                                        throw new Error(`unrecognized output type "${this.returnType}"`)
                                }
                            }
                            getKernelString() {
                                const t = [this.getKernelResultDeclaration()],
                                    {
                                        subKernels: e
                                    } = this;
                                if (null !== e) switch (this.returnType) {
                                    case "Number":
                                    case "Float":
                                    case "Integer":
                                        for (let n = 0; n < e.length; n++) {
                                            const i = e[n];
                                            t.push("Integer" === i.returnType ? `int subKernelResult_${i.name} = 0` : `float subKernelResult_${i.name} = 0.0`)
                                        }
                                        break;
                                    case "Array(2)":
                                        for (let n = 0; n < e.length; n++) t.push(`vec2 subKernelResult_${e[n].name}`);
                                        break;
                                    case "Array(3)":
                                        for (let n = 0; n < e.length; n++) t.push(`vec3 subKernelResult_${e[n].name}`);
                                        break;
                                    case "Array(4)":
                                        for (let n = 0; n < e.length; n++) t.push(`vec4 subKernelResult_${e[n].name}`)
                                }
                                return a.linesToString(t) + this.translatedSource
                            }
                            getMainResultGraphical() {
                                return a.linesToString(["  threadId = indexTo3D(index, uOutputDim)", "  kernel()", "  gl_FragColor = actualColor"])
                            }
                            getMainResultPackedPixels() {
                                switch (this.returnType) {
                                    case "LiteralInteger":
                                    case "Number":
                                    case "Integer":
                                    case "Float":
                                        return this.getMainResultKernelPackedPixels() + this.getMainResultSubKernelPackedPixels();
                                    default:
                                        throw new Error(`packed output only usable with Numbers, "${this.returnType}" specified`)
                                }
                            }
                            getMainResultKernelPackedPixels() {
                                return a.linesToString(["  threadId = indexTo3D(index, uOutputDim)", "  kernel()", `  gl_FragData[0] = ${this.useLegacyEncoder?"legacyEncode32":"encode32"}(kernelResult)`])
                            }
                            getMainResultSubKernelPackedPixels() {
                                const t = [];
                                if (!this.subKernels) return "";
                                for (let e = 0; e < this.subKernels.length; e++) "Integer" === this.subKernels[e].returnType ? t.push(`  gl_FragData[${e+1}] = ${this.useLegacyEncoder?"legacyEncode32":"encode32"}(float(subKernelResult_${this.subKernels[e].name}))`) : t.push(`  gl_FragData[${e+1}] = ${this.useLegacyEncoder?"legacyEncode32":"encode32"}(subKernelResult_${this.subKernels[e].name})`);
                                return a.linesToString(t)
                            }
                            getMainResultMemoryOptimizedFloats() {
                                const t = ["  index *= 4"];
                                switch (this.returnType) {
                                    case "Number":
                                    case "Integer":
                                    case "Float":
                                        const e = ["r", "g", "b", "a"];
                                        for (let n = 0; n < e.length; n++) {
                                            const i = e[n];
                                            this.getMainResultKernelMemoryOptimizedFloats(t, i), this.getMainResultSubKernelMemoryOptimizedFloats(t, i), n + 1 < e.length && t.push("  index += 1")
                                        }
                                        break;
                                    default:
                                        throw new Error(`optimized output only usable with Numbers, ${this.returnType} specified`)
                                }
                                return a.linesToString(t)
                            }
                            getMainResultKernelMemoryOptimizedFloats(t, e) {
                                t.push("  threadId = indexTo3D(index, uOutputDim)", "  kernel()", `  gl_FragData[0].${e} = kernelResult`)
                            }
                            getMainResultSubKernelMemoryOptimizedFloats(t, e) {
                                if (!this.subKernels) return t;
                                for (let n = 0; n < this.subKernels.length; n++) "Integer" === this.subKernels[n].returnType ? t.push(`  gl_FragData[${n+1}].${e} = float(subKernelResult_${this.subKernels[n].name})`) : t.push(`  gl_FragData[${n+1}].${e} = subKernelResult_${this.subKernels[n].name}`)
                            }
                            getMainResultKernelNumberTexture() {
                                return ["  threadId = indexTo3D(index, uOutputDim)", "  kernel()", "  gl_FragData[0][0] = kernelResult"]
                            }
                            getMainResultSubKernelNumberTexture() {
                                const t = [];
                                if (!this.subKernels) return t;
                                for (let e = 0; e < this.subKernels.length; ++e) {
                                    const n = this.subKernels[e];
                                    "Integer" === n.returnType ? t.push(`  gl_FragData[${e+1}][0] = float(subKernelResult_${n.name})`) : t.push(`  gl_FragData[${e+1}][0] = subKernelResult_${n.name}`)
                                }
                                return t
                            }
                            getMainResultKernelArray2Texture() {
                                return ["  threadId = indexTo3D(index, uOutputDim)", "  kernel()", "  gl_FragData[0][0] = kernelResult[0]", "  gl_FragData[0][1] = kernelResult[1]"]
                            }
                            getMainResultSubKernelArray2Texture() {
                                const t = [];
                                if (!this.subKernels) return t;
                                for (let e = 0; e < this.subKernels.length; ++e) t.push(`  gl_FragData[${e+1}][0] = subKernelResult_${this.subKernels[e].name}[0]`, `  gl_FragData[${e+1}][1] = subKernelResult_${this.subKernels[e].name}[1]`);
                                return t
                            }
                            getMainResultKernelArray3Texture() {
                                return ["  threadId = indexTo3D(index, uOutputDim)", "  kernel()", "  gl_FragData[0][0] = kernelResult[0]", "  gl_FragData[0][1] = kernelResult[1]", "  gl_FragData[0][2] = kernelResult[2]"]
                            }
                            getMainResultSubKernelArray3Texture() {
                                const t = [];
                                if (!this.subKernels) return t;
                                for (let e = 0; e < this.subKernels.length; ++e) t.push(`  gl_FragData[${e+1}][0] = subKernelResult_${this.subKernels[e].name}[0]`, `  gl_FragData[${e+1}][1] = subKernelResult_${this.subKernels[e].name}[1]`, `  gl_FragData[${e+1}][2] = subKernelResult_${this.subKernels[e].name}[2]`);
                                return t
                            }
                            getMainResultKernelArray4Texture() {
                                return ["  threadId = indexTo3D(index, uOutputDim)", "  kernel()", "  gl_FragData[0] = kernelResult"]
                            }
                            getMainResultSubKernelArray4Texture() {
                                const t = [];
                                if (!this.subKernels) return t;
                                switch (this.returnType) {
                                    case "Number":
                                    case "Float":
                                    case "Integer":
                                        for (let e = 0; e < this.subKernels.length; ++e) "Integer" === this.subKernels[e].returnType ? t.push(`  gl_FragData[${e+1}] = float(subKernelResult_${this.subKernels[e].name})`) : t.push(`  gl_FragData[${e+1}] = subKernelResult_${this.subKernels[e].name}`);
                                        break;
                                    case "Array(2)":
                                        for (let e = 0; e < this.subKernels.length; ++e) t.push(`  gl_FragData[${e+1}][0] = subKernelResult_${this.subKernels[e].name}[0]`, `  gl_FragData[${e+1}][1] = subKernelResult_${this.subKernels[e].name}[1]`);
                                        break;
                                    case "Array(3)":
                                        for (let e = 0; e < this.subKernels.length; ++e) t.push(`  gl_FragData[${e+1}][0] = subKernelResult_${this.subKernels[e].name}[0]`, `  gl_FragData[${e+1}][1] = subKernelResult_${this.subKernels[e].name}[1]`, `  gl_FragData[${e+1}][2] = subKernelResult_${this.subKernels[e].name}[2]`);
                                        break;
                                    case "Array(4)":
                                        for (let e = 0; e < this.subKernels.length; ++e) t.push(`  gl_FragData[${e+1}][0] = subKernelResult_${this.subKernels[e].name}[0]`, `  gl_FragData[${e+1}][1] = subKernelResult_${this.subKernels[e].name}[1]`, `  gl_FragData[${e+1}][2] = subKernelResult_${this.subKernels[e].name}[2]`, `  gl_FragData[${e+1}][3] = subKernelResult_${this.subKernels[e].name}[3]`)
                                }
                                return t
                            }
                            replaceArtifacts(t, e) {
                                return t.replace(/[ ]*__([A-Z]+[0-9]*([_]?[A-Z]*[0-9]?)*)__;\n/g, ((t, n) => {
                                    if (e.hasOwnProperty(n)) return e[n];
                                    throw `unhandled artifact ${n}`
                                }))
                            }
                            getFragmentShader(t) {
                                return null !== this.compiledFragmentShader ? this.compiledFragmentShader : this.compiledFragmentShader = this.replaceArtifacts(this.constructor.fragmentShader, this._getFragShaderArtifactMap(t))
                            }
                            getVertexShader(t) {
                                return null !== this.compiledVertexShader ? this.compiledVertexShader : this.compiledVertexShader = this.replaceArtifacts(this.constructor.vertexShader, this._getVertShaderArtifactMap(t))
                            }
                            toString() {
                                const t = a.linesToString(["const gl = context"]);
                                return l(this.constructor, arguments, this, t)
                            }
                            destroy(t) {
                                if (!this.context) return;
                                this.buffer && this.context.deleteBuffer(this.buffer), this.framebuffer && this.context.deleteFramebuffer(this.framebuffer);
                                for (const t in this.rawValueFramebuffers) {
                                    for (const e in this.rawValueFramebuffers[t]) this.context.deleteFramebuffer(this.rawValueFramebuffers[t][e]), delete this.rawValueFramebuffers[t][e];
                                    delete this.rawValueFramebuffers[t]
                                }
                                if (this.vertShader && this.context.deleteShader(this.vertShader), this.fragShader && this.context.deleteShader(this.fragShader), this.program && this.context.deleteProgram(this.program), this.texture) {
                                    this.texture.delete();
                                    const t = this.textureCache.indexOf(this.texture.texture);
                                    t > -1 && this.textureCache.splice(t, 1), this.texture = null
                                }
                                if (this.mappedTextures && this.mappedTextures.length) {
                                    for (let t = 0; t < this.mappedTextures.length; t++) {
                                        const e = this.mappedTextures[t];
                                        e.delete();
                                        const n = this.textureCache.indexOf(e.texture);
                                        n > -1 && this.textureCache.splice(n, 1)
                                    }
                                    this.mappedTextures = null
                                }
                                if (this.kernelArguments)
                                    for (let t = 0; t < this.kernelArguments.length; t++) this.kernelArguments[t].destroy();
                                if (this.kernelConstants)
                                    for (let t = 0; t < this.kernelConstants.length; t++) this.kernelConstants[t].destroy();
                                for (; this.textureCache.length > 0;) {
                                    const t = this.textureCache.pop();
                                    this.context.deleteTexture(t)
                                }
                                if (t) {
                                    const t = x.indexOf(this.canvas);
                                    t >= 0 && (x[t] = null, _[t] = null)
                                }
                                if (this.destroyExtensions(), delete this.context, delete this.canvas, !this.gpu) return;
                                const e = this.gpu.kernels.indexOf(this); - 1 !== e && this.gpu.kernels.splice(e, 1)
                            }
                            destroyExtensions() {
                                this.extensions.OES_texture_float = null, this.extensions.OES_texture_float_linear = null, this.extensions.OES_element_index_uint = null, this.extensions.WEBGL_draw_buffers = null
                            }
                            static destroyContext(t) {
                                const e = t.getExtension("WEBGL_lose_context");
                                e && e.loseContext()
                            }
                            toJSON() {
                                const t = super.toJSON();
                                return t.functionNodes = s.fromKernel(this, r).toJSON(), t.settings.threadDim = this.threadDim, t
                            }
                        }
                    }
                }, {
                    "../../plugins/math-random-uniformly-distributed": 112,
                    "../../utils": 114,
                    "../function-builder": 9,
                    "../gl/kernel": 13,
                    "../gl/kernel-string": 12,
                    "./fragment-shader": 37,
                    "./function-node": 38,
                    "./kernel-value-maps": 39,
                    "./vertex-shader": 71
                }],
                71: [function(t, e, n) {
                    e.exports = {
                        vertexShader: "__FLOAT_TACTIC_DECLARATION__;\n__INT_TACTIC_DECLARATION__;\n__SAMPLER_2D_TACTIC_DECLARATION__;\n\nattribute vec2 aPos;\nattribute vec2 aTexCoord;\n\nvarying vec2 vTexCoord;\nuniform vec2 ratio;\n\nvoid main(void) {\n  gl_Position = vec4((aPos + vec2(1)) * ratio + vec2(-1), 0, 1);\n  vTexCoord = aTexCoord;\n}"
                    }
                }, {}],
                72: [function(t, e, n) {
                    const i = `#version 300 es\n__HEADER__;\n__FLOAT_TACTIC_DECLARATION__;\n__INT_TACTIC_DECLARATION__;\n__SAMPLER_2D_TACTIC_DECLARATION__;\n__SAMPLER_2D_ARRAY_TACTIC_DECLARATION__;\n\nconst int LOOP_MAX = __LOOP_MAX__;\n\n__PLUGINS__;\n__CONSTANTS__;\n\nin vec2 vTexCoord;\n\nfloat atan2(float v1, float v2) {\n  if (v1 == 0.0 || v2 == 0.0) return 0.0;\n  return atan(v1 / v2);\n}\n\nfloat cbrt(float x) {\n  if (x >= 0.0) {\n    return pow(x, 1.0 / 3.0);\n  } else {\n    return -pow(x, 1.0 / 3.0);\n  }\n}\n\nfloat expm1(float x) {\n  return pow(${Math.E}, x) - 1.0; \n}\n\nfloat fround(highp float x) {\n  return x;\n}\n\nfloat imul(float v1, float v2) {\n  return float(int(v1) * int(v2));\n}\n\nfloat log10(float x) {\n  return log2(x) * (1.0 / log2(10.0));\n}\n\nfloat log1p(float x) {\n  return log(1.0 + x);\n}\n\nfloat _pow(float v1, float v2) {\n  if (v2 == 0.0) return 1.0;\n  return pow(v1, v2);\n}\n\nfloat _round(float x) {\n  return floor(x + 0.5);\n}\n\n\nconst int BIT_COUNT = 32;\nint modi(int x, int y) {\n  return x - y * (x / y);\n}\n\nint bitwiseOr(int a, int b) {\n  int result = 0;\n  int n = 1;\n  \n  for (int i = 0; i < BIT_COUNT; i++) {\n    if ((modi(a, 2) == 1) || (modi(b, 2) == 1)) {\n      result += n;\n    }\n    a = a / 2;\n    b = b / 2;\n    n = n * 2;\n    if(!(a > 0 || b > 0)) {\n      break;\n    }\n  }\n  return result;\n}\nint bitwiseXOR(int a, int b) {\n  int result = 0;\n  int n = 1;\n  \n  for (int i = 0; i < BIT_COUNT; i++) {\n    if ((modi(a, 2) == 1) != (modi(b, 2) == 1)) {\n      result += n;\n    }\n    a = a / 2;\n    b = b / 2;\n    n = n * 2;\n    if(!(a > 0 || b > 0)) {\n      break;\n    }\n  }\n  return result;\n}\nint bitwiseAnd(int a, int b) {\n  int result = 0;\n  int n = 1;\n  for (int i = 0; i < BIT_COUNT; i++) {\n    if ((modi(a, 2) == 1) && (modi(b, 2) == 1)) {\n      result += n;\n    }\n    a = a / 2;\n    b = b / 2;\n    n = n * 2;\n    if(!(a > 0 && b > 0)) {\n      break;\n    }\n  }\n  return result;\n}\nint bitwiseNot(int a) {\n  int result = 0;\n  int n = 1;\n  \n  for (int i = 0; i < BIT_COUNT; i++) {\n    if (modi(a, 2) == 0) {\n      result += n;    \n    }\n    a = a / 2;\n    n = n * 2;\n  }\n  return result;\n}\nint bitwiseZeroFillLeftShift(int n, int shift) {\n  int maxBytes = BIT_COUNT;\n  for (int i = 0; i < BIT_COUNT; i++) {\n    if (maxBytes >= n) {\n      break;\n    }\n    maxBytes *= 2;\n  }\n  for (int i = 0; i < BIT_COUNT; i++) {\n    if (i >= shift) {\n      break;\n    }\n    n *= 2;\n  }\n\n  int result = 0;\n  int byteVal = 1;\n  for (int i = 0; i < BIT_COUNT; i++) {\n    if (i >= maxBytes) break;\n    if (modi(n, 2) > 0) { result += byteVal; }\n    n = int(n / 2);\n    byteVal *= 2;\n  }\n  return result;\n}\n\nint bitwiseSignedRightShift(int num, int shifts) {\n  return int(floor(float(num) / pow(2.0, float(shifts))));\n}\n\nint bitwiseZeroFillRightShift(int n, int shift) {\n  int maxBytes = BIT_COUNT;\n  for (int i = 0; i < BIT_COUNT; i++) {\n    if (maxBytes >= n) {\n      break;\n    }\n    maxBytes *= 2;\n  }\n  for (int i = 0; i < BIT_COUNT; i++) {\n    if (i >= shift) {\n      break;\n    }\n    n /= 2;\n  }\n  int result = 0;\n  int byteVal = 1;\n  for (int i = 0; i < BIT_COUNT; i++) {\n    if (i >= maxBytes) break;\n    if (modi(n, 2) > 0) { result += byteVal; }\n    n = int(n / 2);\n    byteVal *= 2;\n  }\n  return result;\n}\n\nvec2 integerMod(vec2 x, float y) {\n  vec2 res = floor(mod(x, y));\n  return res * step(1.0 - floor(y), -res);\n}\n\nvec3 integerMod(vec3 x, float y) {\n  vec3 res = floor(mod(x, y));\n  return res * step(1.0 - floor(y), -res);\n}\n\nvec4 integerMod(vec4 x, vec4 y) {\n  vec4 res = floor(mod(x, y));\n  return res * step(1.0 - floor(y), -res);\n}\n\nfloat integerMod(float x, float y) {\n  float res = floor(mod(x, y));\n  return res * (res > floor(y) - 1.0 ? 0.0 : 1.0);\n}\n\nint integerMod(int x, int y) {\n  return x - (y * int(x/y));\n}\n\n__DIVIDE_WITH_INTEGER_CHECK__;\n\n// Here be dragons!\n// DO NOT OPTIMIZE THIS CODE\n// YOU WILL BREAK SOMETHING ON SOMEBODY'S MACHINE\n// LEAVE IT AS IT IS, LEST YOU WASTE YOUR OWN TIME\nconst vec2 MAGIC_VEC = vec2(1.0, -256.0);\nconst vec4 SCALE_FACTOR = vec4(1.0, 256.0, 65536.0, 0.0);\nconst vec4 SCALE_FACTOR_INV = vec4(1.0, 0.00390625, 0.0000152587890625, 0.0); // 1, 1/256, 1/65536\nfloat decode32(vec4 texel) {\n  __DECODE32_ENDIANNESS__;\n  texel *= 255.0;\n  vec2 gte128;\n  gte128.x = texel.b >= 128.0 ? 1.0 : 0.0;\n  gte128.y = texel.a >= 128.0 ? 1.0 : 0.0;\n  float exponent = 2.0 * texel.a - 127.0 + dot(gte128, MAGIC_VEC);\n  float res = exp2(round(exponent));\n  texel.b = texel.b - 128.0 * gte128.x;\n  res = dot(texel, SCALE_FACTOR) * exp2(round(exponent-23.0)) + res;\n  res *= gte128.y * -2.0 + 1.0;\n  return res;\n}\n\nfloat decode16(vec4 texel, int index) {\n  int channel = integerMod(index, 2);\n  return texel[channel*2] * 255.0 + texel[channel*2 + 1] * 65280.0;\n}\n\nfloat decode8(vec4 texel, int index) {\n  int channel = integerMod(index, 4);\n  return texel[channel] * 255.0;\n}\n\nvec4 legacyEncode32(float f) {\n  float F = abs(f);\n  float sign = f < 0.0 ? 1.0 : 0.0;\n  float exponent = floor(log2(F));\n  float mantissa = (exp2(-exponent) * F);\n  // exponent += floor(log2(mantissa));\n  vec4 texel = vec4(F * exp2(23.0-exponent)) * SCALE_FACTOR_INV;\n  texel.rg = integerMod(texel.rg, 256.0);\n  texel.b = integerMod(texel.b, 128.0);\n  texel.a = exponent*0.5 + 63.5;\n  texel.ba += vec2(integerMod(exponent+127.0, 2.0), sign) * 128.0;\n  texel = floor(texel);\n  texel *= 0.003921569; // 1/255\n  __ENCODE32_ENDIANNESS__;\n  return texel;\n}\n\n// https://github.com/gpujs/gpu.js/wiki/Encoder-details\nvec4 encode32(float value) {\n  if (value == 0.0) return vec4(0, 0, 0, 0);\n\n  float exponent;\n  float mantissa;\n  vec4  result;\n  float sgn;\n\n  sgn = step(0.0, -value);\n  value = abs(value);\n\n  exponent = floor(log2(value));\n\n  mantissa = value*pow(2.0, -exponent)-1.0;\n  exponent = exponent+127.0;\n  result   = vec4(0,0,0,0);\n\n  result.a = floor(exponent/2.0);\n  exponent = exponent - result.a*2.0;\n  result.a = result.a + 128.0*sgn;\n\n  result.b = floor(mantissa * 128.0);\n  mantissa = mantissa - result.b / 128.0;\n  result.b = result.b + exponent*128.0;\n\n  result.g = floor(mantissa*32768.0);\n  mantissa = mantissa - result.g/32768.0;\n\n  result.r = floor(mantissa*8388608.0);\n  return result/255.0;\n}\n// Dragons end here\n\nint index;\nivec3 threadId;\n\nivec3 indexTo3D(int idx, ivec3 texDim) {\n  int z = int(idx / (texDim.x * texDim.y));\n  idx -= z * int(texDim.x * texDim.y);\n  int y = int(idx / texDim.x);\n  int x = int(integerMod(idx, texDim.x));\n  return ivec3(x, y, z);\n}\n\nfloat get32(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\n  int index = x + texDim.x * (y + texDim.y * z);\n  int w = texSize.x;\n  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\n  vec4 texel = texture(tex, st / vec2(texSize));\n  return decode32(texel);\n}\n\nfloat get16(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\n  int index = x + (texDim.x * (y + (texDim.y * z)));\n  int w = texSize.x * 2;\n  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\n  vec4 texel = texture(tex, st / vec2(texSize.x * 2, texSize.y));\n  return decode16(texel, index);\n}\n\nfloat get8(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\n  int index = x + (texDim.x * (y + (texDim.y * z)));\n  int w = texSize.x * 4;\n  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\n  vec4 texel = texture(tex, st / vec2(texSize.x * 4, texSize.y));\n  return decode8(texel, index);\n}\n\nfloat getMemoryOptimized32(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\n  int index = x + (texDim.x * (y + (texDim.y * z)));\n  int channel = integerMod(index, 4);\n  index = index / 4;\n  int w = texSize.x;\n  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\n  index = index / 4;\n  vec4 texel = texture(tex, st / vec2(texSize));\n  return texel[channel];\n}\n\nvec4 getImage2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\n  int index = x + texDim.x * (y + texDim.y * z);\n  int w = texSize.x;\n  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\n  return texture(tex, st / vec2(texSize));\n}\n\nvec4 getImage3D(sampler2DArray tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\n  int index = x + texDim.x * (y + texDim.y * z);\n  int w = texSize.x;\n  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\n  return texture(tex, vec3(st / vec2(texSize), z));\n}\n\nfloat getFloatFromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\n  vec4 result = getImage2D(tex, texSize, texDim, z, y, x);\n  return result[0];\n}\n\nvec2 getVec2FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\n  vec4 result = getImage2D(tex, texSize, texDim, z, y, x);\n  return vec2(result[0], result[1]);\n}\n\nvec2 getMemoryOptimizedVec2(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\n  int index = x + texDim.x * (y + texDim.y * z);\n  int channel = integerMod(index, 2);\n  index = index / 2;\n  int w = texSize.x;\n  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\n  vec4 texel = texture(tex, st / vec2(texSize));\n  if (channel == 0) return vec2(texel.r, texel.g);\n  if (channel == 1) return vec2(texel.b, texel.a);\n  return vec2(0.0, 0.0);\n}\n\nvec3 getVec3FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\n  vec4 result = getImage2D(tex, texSize, texDim, z, y, x);\n  return vec3(result[0], result[1], result[2]);\n}\n\nvec3 getMemoryOptimizedVec3(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\n  int fieldIndex = 3 * (x + texDim.x * (y + texDim.y * z));\n  int vectorIndex = fieldIndex / 4;\n  int vectorOffset = fieldIndex - vectorIndex * 4;\n  int readY = vectorIndex / texSize.x;\n  int readX = vectorIndex - readY * texSize.x;\n  vec4 tex1 = texture(tex, (vec2(readX, readY) + 0.5) / vec2(texSize));\n\n  if (vectorOffset == 0) {\n    return tex1.xyz;\n  } else if (vectorOffset == 1) {\n    return tex1.yzw;\n  } else {\n    readX++;\n    if (readX >= texSize.x) {\n      readX = 0;\n      readY++;\n    }\n    vec4 tex2 = texture(tex, vec2(readX, readY) / vec2(texSize));\n    if (vectorOffset == 2) {\n      return vec3(tex1.z, tex1.w, tex2.x);\n    } else {\n      return vec3(tex1.w, tex2.x, tex2.y);\n    }\n  }\n}\n\nvec4 getVec4FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\n  return getImage2D(tex, texSize, texDim, z, y, x);\n}\n\nvec4 getMemoryOptimizedVec4(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\n  int index = x + texDim.x * (y + texDim.y * z);\n  int channel = integerMod(index, 2);\n  int w = texSize.x;\n  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\n  vec4 texel = texture(tex, st / vec2(texSize));\n  return vec4(texel.r, texel.g, texel.b, texel.a);\n}\n\nvec4 actualColor;\nvoid color(float r, float g, float b, float a) {\n  actualColor = vec4(r,g,b,a);\n}\n\nvoid color(float r, float g, float b) {\n  color(r,g,b,1.0);\n}\n\nfloat modulo(float number, float divisor) {\n  if (number < 0.0) {\n    number = abs(number);\n    if (divisor < 0.0) {\n      divisor = abs(divisor);\n    }\n    return -mod(number, divisor);\n  }\n  if (divisor < 0.0) {\n    divisor = abs(divisor);\n  }\n  return mod(number, divisor);\n}\n\n__INJECTED_NATIVE__;\n__MAIN_CONSTANTS__;\n__MAIN_ARGUMENTS__;\n__KERNEL__;\n\nvoid main(void) {\n  index = int(vTexCoord.s * float(uTexSize.x)) + int(vTexCoord.t * float(uTexSize.y)) * uTexSize.x;\n  __MAIN_RESULT__;\n}`;
                    e.exports = {
                        fragmentShader: i
                    }
                }, {}],
                73: [function(t, e, n) {
                    const {
                        utils: i
                    } = t("../../utils"), {
                        WebGLFunctionNode: s
                    } = t("../web-gl/function-node");
                    e.exports = {
                        WebGL2FunctionNode: class extends s {
                            astIdentifierExpression(t, e) {
                                if ("Identifier" !== t.type) throw this.astErrorOutput("IdentifierExpression - not an Identifier", t);
                                const n = this.getType(t),
                                    s = i.sanitizeName(t.name);
                                return "Infinity" === t.name ? e.push("intBitsToFloat(2139095039)") : "Boolean" === n && this.argumentNames.indexOf(s) > -1 ? e.push(`bool(user_${s})`) : e.push(`user_${s}`), e
                            }
                        }
                    }
                }, {
                    "../../utils": 114,
                    "../web-gl/function-node": 38
                }],
                74: [function(t, e, n) {
                    const {
                        WebGL2KernelValueBoolean: i
                    } = t("./kernel-value/boolean"), {
                        WebGL2KernelValueFloat: s
                    } = t("./kernel-value/float"), {
                        WebGL2KernelValueInteger: r
                    } = t("./kernel-value/integer"), {
                        WebGL2KernelValueHTMLImage: a
                    } = t("./kernel-value/html-image"), {
                        WebGL2KernelValueDynamicHTMLImage: o
                    } = t("./kernel-value/dynamic-html-image"), {
                        WebGL2KernelValueHTMLImageArray: u
                    } = t("./kernel-value/html-image-array"), {
                        WebGL2KernelValueDynamicHTMLImageArray: h
                    } = t("./kernel-value/dynamic-html-image-array"), {
                        WebGL2KernelValueHTMLVideo: l
                    } = t("./kernel-value/html-video"), {
                        WebGL2KernelValueDynamicHTMLVideo: c
                    } = t("./kernel-value/dynamic-html-video"), {
                        WebGL2KernelValueSingleInput: p
                    } = t("./kernel-value/single-input"), {
                        WebGL2KernelValueDynamicSingleInput: d
                    } = t("./kernel-value/dynamic-single-input"), {
                        WebGL2KernelValueUnsignedInput: m
                    } = t("./kernel-value/unsigned-input"), {
                        WebGL2KernelValueDynamicUnsignedInput: g
                    } = t("./kernel-value/dynamic-unsigned-input"), {
                        WebGL2KernelValueMemoryOptimizedNumberTexture: f
                    } = t("./kernel-value/memory-optimized-number-texture"), {
                        WebGL2KernelValueDynamicMemoryOptimizedNumberTexture: y
                    } = t("./kernel-value/dynamic-memory-optimized-number-texture"), {
                        WebGL2KernelValueNumberTexture: x
                    } = t("./kernel-value/number-texture"), {
                        WebGL2KernelValueDynamicNumberTexture: _
                    } = t("./kernel-value/dynamic-number-texture"), {
                        WebGL2KernelValueSingleArray: b
                    } = t("./kernel-value/single-array"), {
                        WebGL2KernelValueDynamicSingleArray: w
                    } = t("./kernel-value/dynamic-single-array"), {
                        WebGL2KernelValueSingleArray1DI: T
                    } = t("./kernel-value/single-array1d-i"), {
                        WebGL2KernelValueDynamicSingleArray1DI: v
                    } = t("./kernel-value/dynamic-single-array1d-i"), {
                        WebGL2KernelValueSingleArray2DI: E
                    } = t("./kernel-value/single-array2d-i"), {
                        WebGL2KernelValueDynamicSingleArray2DI: A
                    } = t("./kernel-value/dynamic-single-array2d-i"), {
                        WebGL2KernelValueSingleArray3DI: I
                    } = t("./kernel-value/single-array3d-i"), {
                        WebGL2KernelValueDynamicSingleArray3DI: S
                    } = t("./kernel-value/dynamic-single-array3d-i"), {
                        WebGL2KernelValueArray2: k
                    } = t("./kernel-value/array2"), {
                        WebGL2KernelValueArray3: D
                    } = t("./kernel-value/array3"), {
                        WebGL2KernelValueArray4: L
                    } = t("./kernel-value/array4"), {
                        WebGL2KernelValueUnsignedArray: C
                    } = t("./kernel-value/unsigned-array"), {
                        WebGL2KernelValueDynamicUnsignedArray: M
                    } = t("./kernel-value/dynamic-unsigned-array"), O = {
                        unsigned: {
                            dynamic: {
                                Boolean: i,
                                Integer: r,
                                Float: s,
                                Array: M,
                                "Array(2)": k,
                                "Array(3)": D,
                                "Array(4)": L,
                                "Array1D(2)": !1,
                                "Array1D(3)": !1,
                                "Array1D(4)": !1,
                                "Array2D(2)": !1,
                                "Array2D(3)": !1,
                                "Array2D(4)": !1,
                                "Array3D(2)": !1,
                                "Array3D(3)": !1,
                                "Array3D(4)": !1,
                                Input: g,
                                NumberTexture: _,
                                "ArrayTexture(1)": _,
                                "ArrayTexture(2)": _,
                                "ArrayTexture(3)": _,
                                "ArrayTexture(4)": _,
                                MemoryOptimizedNumberTexture: y,
                                HTMLCanvas: o,
                                OffscreenCanvas: o,
                                HTMLImage: o,
                                ImageBitmap: o,
                                ImageData: o,
                                HTMLImageArray: h,
                                HTMLVideo: c
                            },
                            static: {
                                Boolean: i,
                                Float: s,
                                Integer: r,
                                Array: C,
                                "Array(2)": k,
                                "Array(3)": D,
                                "Array(4)": L,
                                "Array1D(2)": !1,
                                "Array1D(3)": !1,
                                "Array1D(4)": !1,
                                "Array2D(2)": !1,
                                "Array2D(3)": !1,
                                "Array2D(4)": !1,
                                "Array3D(2)": !1,
                                "Array3D(3)": !1,
                                "Array3D(4)": !1,
                                Input: m,
                                NumberTexture: x,
                                "ArrayTexture(1)": x,
                                "ArrayTexture(2)": x,
                                "ArrayTexture(3)": x,
                                "ArrayTexture(4)": x,
                                MemoryOptimizedNumberTexture: y,
                                HTMLCanvas: a,
                                OffscreenCanvas: a,
                                HTMLImage: a,
                                ImageBitmap: a,
                                ImageData: a,
                                HTMLImageArray: u,
                                HTMLVideo: l
                            }
                        },
                        single: {
                            dynamic: {
                                Boolean: i,
                                Integer: r,
                                Float: s,
                                Array: w,
                                "Array(2)": k,
                                "Array(3)": D,
                                "Array(4)": L,
                                "Array1D(2)": v,
                                "Array1D(3)": v,
                                "Array1D(4)": v,
                                "Array2D(2)": A,
                                "Array2D(3)": A,
                                "Array2D(4)": A,
                                "Array3D(2)": S,
                                "Array3D(3)": S,
                                "Array3D(4)": S,
                                Input: d,
                                NumberTexture: _,
                                "ArrayTexture(1)": _,
                                "ArrayTexture(2)": _,
                                "ArrayTexture(3)": _,
                                "ArrayTexture(4)": _,
                                MemoryOptimizedNumberTexture: y,
                                HTMLCanvas: o,
                                OffscreenCanvas: o,
                                HTMLImage: o,
                                ImageBitmap: o,
                                ImageData: o,
                                HTMLImageArray: h,
                                HTMLVideo: c
                            },
                            static: {
                                Boolean: i,
                                Float: s,
                                Integer: r,
                                Array: b,
                                "Array(2)": k,
                                "Array(3)": D,
                                "Array(4)": L,
                                "Array1D(2)": T,
                                "Array1D(3)": T,
                                "Array1D(4)": T,
                                "Array2D(2)": E,
                                "Array2D(3)": E,
                                "Array2D(4)": E,
                                "Array3D(2)": I,
                                "Array3D(3)": I,
                                "Array3D(4)": I,
                                Input: p,
                                NumberTexture: x,
                                "ArrayTexture(1)": x,
                                "ArrayTexture(2)": x,
                                "ArrayTexture(3)": x,
                                "ArrayTexture(4)": x,
                                MemoryOptimizedNumberTexture: f,
                                HTMLCanvas: a,
                                OffscreenCanvas: a,
                                HTMLImage: a,
                                ImageBitmap: a,
                                ImageData: a,
                                HTMLImageArray: u,
                                HTMLVideo: l
                            }
                        }
                    };
                    e.exports = {
                        kernelValueMaps: O,
                        lookupKernelValueType: function(t, e, n, i) {
                            if (!t) throw new Error("type missing");
                            if (!e) throw new Error("dynamic missing");
                            if (!n) throw new Error("precision missing");
                            i.type && (t = i.type);
                            const s = O[n][e];
                            if (!1 === s[t]) return null;
                            if (void 0 === s[t]) throw new Error(`Could not find a KernelValue for ${t}`);
                            return s[t]
                        }
                    }
                }, {
                    "./kernel-value/array2": 75,
                    "./kernel-value/array3": 76,
                    "./kernel-value/array4": 77,
                    "./kernel-value/boolean": 78,
                    "./kernel-value/dynamic-html-image": 80,
                    "./kernel-value/dynamic-html-image-array": 79,
                    "./kernel-value/dynamic-html-video": 81,
                    "./kernel-value/dynamic-memory-optimized-number-texture": 82,
                    "./kernel-value/dynamic-number-texture": 83,
                    "./kernel-value/dynamic-single-array": 84,
                    "./kernel-value/dynamic-single-array1d-i": 85,
                    "./kernel-value/dynamic-single-array2d-i": 86,
                    "./kernel-value/dynamic-single-array3d-i": 87,
                    "./kernel-value/dynamic-single-input": 88,
                    "./kernel-value/dynamic-unsigned-array": 89,
                    "./kernel-value/dynamic-unsigned-input": 90,
                    "./kernel-value/float": 91,
                    "./kernel-value/html-image": 93,
                    "./kernel-value/html-image-array": 92,
                    "./kernel-value/html-video": 94,
                    "./kernel-value/integer": 95,
                    "./kernel-value/memory-optimized-number-texture": 96,
                    "./kernel-value/number-texture": 97,
                    "./kernel-value/single-array": 98,
                    "./kernel-value/single-array1d-i": 99,
                    "./kernel-value/single-array2d-i": 100,
                    "./kernel-value/single-array3d-i": 101,
                    "./kernel-value/single-input": 102,
                    "./kernel-value/unsigned-array": 103,
                    "./kernel-value/unsigned-input": 104
                }],
                75: [function(t, e, n) {
                    const {
                        WebGLKernelValueArray2: i
                    } = t("../../web-gl/kernel-value/array2");
                    e.exports = {
                        WebGL2KernelValueArray2: class extends i {}
                    }
                }, {
                    "../../web-gl/kernel-value/array2": 41
                }],
                76: [function(t, e, n) {
                    const {
                        WebGLKernelValueArray3: i
                    } = t("../../web-gl/kernel-value/array3");
                    e.exports = {
                        WebGL2KernelValueArray3: class extends i {}
                    }
                }, {
                    "../../web-gl/kernel-value/array3": 42
                }],
                77: [function(t, e, n) {
                    const {
                        WebGLKernelValueArray4: i
                    } = t("../../web-gl/kernel-value/array4");
                    e.exports = {
                        WebGL2KernelValueArray4: class extends i {}
                    }
                }, {
                    "../../web-gl/kernel-value/array4": 43
                }],
                78: [function(t, e, n) {
                    const {
                        WebGLKernelValueBoolean: i
                    } = t("../../web-gl/kernel-value/boolean");
                    e.exports = {
                        WebGL2KernelValueBoolean: class extends i {}
                    }
                }, {
                    "../../web-gl/kernel-value/boolean": 44
                }],
                79: [function(t, e, n) {
                    const {
                        utils: i
                    } = t("../../../utils"), {
                        WebGL2KernelValueHTMLImageArray: s
                    } = t("./html-image-array");
                    e.exports = {
                        WebGL2KernelValueDynamicHTMLImageArray: class extends s {
                            getSource() {
                                const t = this.getVariablePrecisionString();
                                return i.linesToString([`uniform ${t} sampler2DArray ${this.id}`, `uniform ${t} ivec2 ${this.sizeId}`, `uniform ${t} ivec3 ${this.dimensionsId}`])
                            }
                            updateValue(t) {
                                const {
                                    width: e,
                                    height: n
                                } = t[0];
                                this.checkSize(e, n), this.dimensions = [e, n, t.length], this.textureSize = [e, n], this.kernel.setUniform3iv(this.dimensionsId, this.dimensions), this.kernel.setUniform2iv(this.sizeId, this.textureSize), super.updateValue(t)
                            }
                        }
                    }
                }, {
                    "../../../utils": 114,
                    "./html-image-array": 92
                }],
                80: [function(t, e, n) {
                    const {
                        utils: i
                    } = t("../../../utils"), {
                        WebGLKernelValueDynamicHTMLImage: s
                    } = t("../../web-gl/kernel-value/dynamic-html-image");
                    e.exports = {
                        WebGL2KernelValueDynamicHTMLImage: class extends s {
                            getSource() {
                                const t = this.getVariablePrecisionString();
                                return i.linesToString([`uniform ${t} sampler2D ${this.id}`, `uniform ${t} ivec2 ${this.sizeId}`, `uniform ${t} ivec3 ${this.dimensionsId}`])
                            }
                        }
                    }
                }, {
                    "../../../utils": 114,
                    "../../web-gl/kernel-value/dynamic-html-image": 45
                }],
                81: [function(t, e, n) {
                    const {
                        utils: i
                    } = t("../../../utils"), {
                        WebGL2KernelValueDynamicHTMLImage: s
                    } = t("./dynamic-html-image");
                    e.exports = {
                        WebGL2KernelValueDynamicHTMLVideo: class extends s {}
                    }
                }, {
                    "../../../utils": 114,
                    "./dynamic-html-image": 80
                }],
                82: [function(t, e, n) {
                    const {
                        utils: i
                    } = t("../../../utils"), {
                        WebGLKernelValueDynamicMemoryOptimizedNumberTexture: s
                    } = t("../../web-gl/kernel-value/dynamic-memory-optimized-number-texture");
                    e.exports = {
                        WebGL2KernelValueDynamicMemoryOptimizedNumberTexture: class extends s {
                            getSource() {
                                return i.linesToString([`uniform sampler2D ${this.id}`, `uniform ivec2 ${this.sizeId}`, `uniform ivec3 ${this.dimensionsId}`])
                            }
                        }
                    }
                }, {
                    "../../../utils": 114,
                    "../../web-gl/kernel-value/dynamic-memory-optimized-number-texture": 47
                }],
                83: [function(t, e, n) {
                    const {
                        utils: i
                    } = t("../../../utils"), {
                        WebGLKernelValueDynamicNumberTexture: s
                    } = t("../../web-gl/kernel-value/dynamic-number-texture");
                    e.exports = {
                        WebGL2KernelValueDynamicNumberTexture: class extends s {
                            getSource() {
                                const t = this.getVariablePrecisionString();
                                return i.linesToString([`uniform ${t} sampler2D ${this.id}`, `uniform ${t} ivec2 ${this.sizeId}`, `uniform ${t} ivec3 ${this.dimensionsId}`])
                            }
                        }
                    }
                }, {
                    "../../../utils": 114,
                    "../../web-gl/kernel-value/dynamic-number-texture": 48
                }],
                84: [function(t, e, n) {
                    const {
                        utils: i
                    } = t("../../../utils"), {
                        WebGL2KernelValueSingleArray: s
                    } = t("../../web-gl2/kernel-value/single-array");
                    e.exports = {
                        WebGL2KernelValueDynamicSingleArray: class extends s {
                            getSource() {
                                const t = this.getVariablePrecisionString();
                                return i.linesToString([`uniform ${t} sampler2D ${this.id}`, `uniform ${t} ivec2 ${this.sizeId}`, `uniform ${t} ivec3 ${this.dimensionsId}`])
                            }
                            updateValue(t) {
                                this.dimensions = i.getDimensions(t, !0), this.textureSize = i.getMemoryOptimizedFloatTextureSize(this.dimensions, this.bitRatio), this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio, this.checkSize(this.textureSize[0], this.textureSize[1]), this.uploadValue = new Float32Array(this.uploadArrayLength), this.kernel.setUniform3iv(this.dimensionsId, this.dimensions), this.kernel.setUniform2iv(this.sizeId, this.textureSize), super.updateValue(t)
                            }
                        }
                    }
                }, {
                    "../../../utils": 114,
                    "../../web-gl2/kernel-value/single-array": 98
                }],
                85: [function(t, e, n) {
                    const {
                        utils: i
                    } = t("../../../utils"), {
                        WebGL2KernelValueSingleArray1DI: s
                    } = t("../../web-gl2/kernel-value/single-array1d-i");
                    e.exports = {
                        WebGL2KernelValueDynamicSingleArray1DI: class extends s {
                            getSource() {
                                const t = this.getVariablePrecisionString();
                                return i.linesToString([`uniform ${t} sampler2D ${this.id}`, `uniform ${t} ivec2 ${this.sizeId}`, `uniform ${t} ivec3 ${this.dimensionsId}`])
                            }
                            updateValue(t) {
                                this.setShape(t), this.kernel.setUniform3iv(this.dimensionsId, this.dimensions), this.kernel.setUniform2iv(this.sizeId, this.textureSize), super.updateValue(t)
                            }
                        }
                    }
                }, {
                    "../../../utils": 114,
                    "../../web-gl2/kernel-value/single-array1d-i": 99
                }],
                86: [function(t, e, n) {
                    const {
                        utils: i
                    } = t("../../../utils"), {
                        WebGL2KernelValueSingleArray2DI: s
                    } = t("../../web-gl2/kernel-value/single-array2d-i");
                    e.exports = {
                        WebGL2KernelValueDynamicSingleArray2DI: class extends s {
                            getSource() {
                                const t = this.getVariablePrecisionString();
                                return i.linesToString([`uniform ${t} sampler2D ${this.id}`, `uniform ${t} ivec2 ${this.sizeId}`, `uniform ${t} ivec3 ${this.dimensionsId}`])
                            }
                            updateValue(t) {
                                this.setShape(t), this.kernel.setUniform3iv(this.dimensionsId, this.dimensions), this.kernel.setUniform2iv(this.sizeId, this.textureSize), super.updateValue(t)
                            }
                        }
                    }
                }, {
                    "../../../utils": 114,
                    "../../web-gl2/kernel-value/single-array2d-i": 100
                }],
                87: [function(t, e, n) {
                    const {
                        utils: i
                    } = t("../../../utils"), {
                        WebGL2KernelValueSingleArray3DI: s
                    } = t("../../web-gl2/kernel-value/single-array3d-i");
                    e.exports = {
                        WebGL2KernelValueDynamicSingleArray3DI: class extends s {
                            getSource() {
                                const t = this.getVariablePrecisionString();
                                return i.linesToString([`uniform ${t} sampler2D ${this.id}`, `uniform ${t} ivec2 ${this.sizeId}`, `uniform ${t} ivec3 ${this.dimensionsId}`])
                            }
                            updateValue(t) {
                                this.setShape(t), this.kernel.setUniform3iv(this.dimensionsId, this.dimensions), this.kernel.setUniform2iv(this.sizeId, this.textureSize), super.updateValue(t)
                            }
                        }
                    }
                }, {
                    "../../../utils": 114,
                    "../../web-gl2/kernel-value/single-array3d-i": 101
                }],
                88: [function(t, e, n) {
                    const {
                        utils: i
                    } = t("../../../utils"), {
                        WebGL2KernelValueSingleInput: s
                    } = t("../../web-gl2/kernel-value/single-input");
                    e.exports = {
                        WebGL2KernelValueDynamicSingleInput: class extends s {
                            getSource() {
                                const t = this.getVariablePrecisionString();
                                return i.linesToString([`uniform ${t} sampler2D ${this.id}`, `uniform ${t} ivec2 ${this.sizeId}`, `uniform ${t} ivec3 ${this.dimensionsId}`])
                            }
                            updateValue(t) {
                                let [e, n, s] = t.size;
                                this.dimensions = new Int32Array([e || 1, n || 1, s || 1]), this.textureSize = i.getMemoryOptimizedFloatTextureSize(this.dimensions, this.bitRatio), this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio, this.checkSize(this.textureSize[0], this.textureSize[1]), this.uploadValue = new Float32Array(this.uploadArrayLength), this.kernel.setUniform3iv(this.dimensionsId, this.dimensions), this.kernel.setUniform2iv(this.sizeId, this.textureSize), super.updateValue(t)
                            }
                        }
                    }
                }, {
                    "../../../utils": 114,
                    "../../web-gl2/kernel-value/single-input": 102
                }],
                89: [function(t, e, n) {
                    const {
                        utils: i
                    } = t("../../../utils"), {
                        WebGLKernelValueDynamicUnsignedArray: s
                    } = t("../../web-gl/kernel-value/dynamic-unsigned-array");
                    e.exports = {
                        WebGL2KernelValueDynamicUnsignedArray: class extends s {
                            getSource() {
                                const t = this.getVariablePrecisionString();
                                return i.linesToString([`uniform ${t} sampler2D ${this.id}`, `uniform ${t} ivec2 ${this.sizeId}`, `uniform ${t} ivec3 ${this.dimensionsId}`])
                            }
                        }
                    }
                }, {
                    "../../../utils": 114,
                    "../../web-gl/kernel-value/dynamic-unsigned-array": 54
                }],
                90: [function(t, e, n) {
                    const {
                        utils: i
                    } = t("../../../utils"), {
                        WebGLKernelValueDynamicUnsignedInput: s
                    } = t("../../web-gl/kernel-value/dynamic-unsigned-input");
                    e.exports = {
                        WebGL2KernelValueDynamicUnsignedInput: class extends s {
                            getSource() {
                                const t = this.getVariablePrecisionString();
                                return i.linesToString([`uniform ${t} sampler2D ${this.id}`, `uniform ${t} ivec2 ${this.sizeId}`, `uniform ${t} ivec3 ${this.dimensionsId}`])
                            }
                        }
                    }
                }, {
                    "../../../utils": 114,
                    "../../web-gl/kernel-value/dynamic-unsigned-input": 55
                }],
                91: [function(t, e, n) {
                    const {
                        utils: i
                    } = t("../../../utils"), {
                        WebGLKernelValueFloat: s
                    } = t("../../web-gl/kernel-value/float");
                    e.exports = {
                        WebGL2KernelValueFloat: class extends s {}
                    }
                }, {
                    "../../../utils": 114,
                    "../../web-gl/kernel-value/float": 56
                }],
                92: [function(t, e, n) {
                    const {
                        utils: i
                    } = t("../../../utils"), {
                        WebGLKernelArray: s
                    } = t("../../web-gl/kernel-value/array");
                    e.exports = {
                        WebGL2KernelValueHTMLImageArray: class extends s {
                            constructor(t, e) {
                                super(t, e), this.checkSize(t[0].width, t[0].height), this.dimensions = [t[0].width, t[0].height, t.length], this.textureSize = [t[0].width, t[0].height]
                            }
                            defineTexture() {
                                const {
                                    context: t
                                } = this;
                                t.activeTexture(this.contextHandle), t.bindTexture(t.TEXTURE_2D_ARRAY, this.texture), t.texParameteri(t.TEXTURE_2D_ARRAY, t.TEXTURE_MAG_FILTER, t.NEAREST), t.texParameteri(t.TEXTURE_2D_ARRAY, t.TEXTURE_MIN_FILTER, t.NEAREST)
                            }
                            getStringValueHandler() {
                                return `const uploadValue_${this.name} = ${this.varName};\n`
                            }
                            getSource() {
                                const t = this.getVariablePrecisionString();
                                return i.linesToString([`uniform ${t} sampler2DArray ${this.id}`, `${t} ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`, `${t} ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`])
                            }
                            updateValue(t) {
                                const {
                                    context: e
                                } = this;
                                e.activeTexture(this.contextHandle), e.bindTexture(e.TEXTURE_2D_ARRAY, this.texture), e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, !0), e.texImage3D(e.TEXTURE_2D_ARRAY, 0, e.RGBA, t[0].width, t[0].height, t.length, 0, e.RGBA, e.UNSIGNED_BYTE, null);
                                for (let n = 0; n < t.length; n++) {
                                    const i = 0,
                                        s = 0,
                                        r = 1;
                                    e.texSubImage3D(e.TEXTURE_2D_ARRAY, 0, i, s, n, t[n].width, t[n].height, r, e.RGBA, e.UNSIGNED_BYTE, this.uploadValue = t[n])
                                }
                                this.kernel.setUniform1i(this.id, this.index)
                            }
                        }
                    }
                }, {
                    "../../../utils": 114,
                    "../../web-gl/kernel-value/array": 40
                }],
                93: [function(t, e, n) {
                    const {
                        utils: i
                    } = t("../../../utils"), {
                        WebGLKernelValueHTMLImage: s
                    } = t("../../web-gl/kernel-value/html-image");
                    e.exports = {
                        WebGL2KernelValueHTMLImage: class extends s {
                            getSource() {
                                const t = this.getVariablePrecisionString();
                                return i.linesToString([`uniform ${t} sampler2D ${this.id}`, `${t} ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`, `${t} ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`])
                            }
                        }
                    }
                }, {
                    "../../../utils": 114,
                    "../../web-gl/kernel-value/html-image": 57
                }],
                94: [function(t, e, n) {
                    const {
                        utils: i
                    } = t("../../../utils"), {
                        WebGL2KernelValueHTMLImage: s
                    } = t("./html-image");
                    e.exports = {
                        WebGL2KernelValueHTMLVideo: class extends s {}
                    }
                }, {
                    "../../../utils": 114,
                    "./html-image": 93
                }],
                95: [function(t, e, n) {
                    const {
                        WebGLKernelValueInteger: i
                    } = t("../../web-gl/kernel-value/integer");
                    e.exports = {
                        WebGL2KernelValueInteger: class extends i {
                            getSource(t) {
                                const e = this.getVariablePrecisionString();
                                return "constants" === this.origin ? `const ${e} int ${this.id} = ${parseInt(t)};\n` : `uniform ${e} int ${this.id};\n`
                            }
                            updateValue(t) {
                                "constants" !== this.origin && this.kernel.setUniform1i(this.id, this.uploadValue = t)
                            }
                        }
                    }
                }, {
                    "../../web-gl/kernel-value/integer": 60
                }],
                96: [function(t, e, n) {
                    const {
                        utils: i
                    } = t("../../../utils"), {
                        WebGLKernelValueMemoryOptimizedNumberTexture: s
                    } = t("../../web-gl/kernel-value/memory-optimized-number-texture");
                    e.exports = {
                        WebGL2KernelValueMemoryOptimizedNumberTexture: class extends s {
                            getSource() {
                                const {
                                    id: t,
                                    sizeId: e,
                                    textureSize: n,
                                    dimensionsId: s,
                                    dimensions: r
                                } = this, a = this.getVariablePrecisionString();
                                return i.linesToString([`uniform sampler2D ${t}`, `${a} ivec2 ${e} = ivec2(${n[0]}, ${n[1]})`, `${a} ivec3 ${s} = ivec3(${r[0]}, ${r[1]}, ${r[2]})`])
                            }
                        }
                    }
                }, {
                    "../../../utils": 114,
                    "../../web-gl/kernel-value/memory-optimized-number-texture": 61
                }],
                97: [function(t, e, n) {
                    const {
                        utils: i
                    } = t("../../../utils"), {
                        WebGLKernelValueNumberTexture: s
                    } = t("../../web-gl/kernel-value/number-texture");
                    e.exports = {
                        WebGL2KernelValueNumberTexture: class extends s {
                            getSource() {
                                const {
                                    id: t,
                                    sizeId: e,
                                    textureSize: n,
                                    dimensionsId: s,
                                    dimensions: r
                                } = this, a = this.getVariablePrecisionString();
                                return i.linesToString([`uniform ${a} sampler2D ${t}`, `${a} ivec2 ${e} = ivec2(${n[0]}, ${n[1]})`, `${a} ivec3 ${s} = ivec3(${r[0]}, ${r[1]}, ${r[2]})`])
                            }
                        }
                    }
                }, {
                    "../../../utils": 114,
                    "../../web-gl/kernel-value/number-texture": 62
                }],
                98: [function(t, e, n) {
                    const {
                        utils: i
                    } = t("../../../utils"), {
                        WebGLKernelValueSingleArray: s
                    } = t("../../web-gl/kernel-value/single-array");
                    e.exports = {
                        WebGL2KernelValueSingleArray: class extends s {
                            getSource() {
                                const t = this.getVariablePrecisionString();
                                return i.linesToString([`uniform ${t} sampler2D ${this.id}`, `${t} ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`, `${t} ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`])
                            }
                            updateValue(t) {
                                if (t.constructor !== this.initialValueConstructor) return void this.onUpdateValueMismatch(t.constructor);
                                const {
                                    context: e
                                } = this;
                                i.flattenTo(t, this.uploadValue), e.activeTexture(this.contextHandle), e.bindTexture(e.TEXTURE_2D, this.texture), e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, !1), e.texImage2D(e.TEXTURE_2D, 0, e.RGBA32F, this.textureSize[0], this.textureSize[1], 0, e.RGBA, e.FLOAT, this.uploadValue), this.kernel.setUniform1i(this.id, this.index)
                            }
                        }
                    }
                }, {
                    "../../../utils": 114,
                    "../../web-gl/kernel-value/single-array": 63
                }],
                99: [function(t, e, n) {
                    const {
                        utils: i
                    } = t("../../../utils"), {
                        WebGLKernelValueSingleArray1DI: s
                    } = t("../../web-gl/kernel-value/single-array1d-i");
                    e.exports = {
                        WebGL2KernelValueSingleArray1DI: class extends s {
                            updateValue(t) {
                                if (t.constructor !== this.initialValueConstructor) return void this.onUpdateValueMismatch(t.constructor);
                                const {
                                    context: e
                                } = this;
                                i.flattenTo(t, this.uploadValue), e.activeTexture(this.contextHandle), e.bindTexture(e.TEXTURE_2D, this.texture), e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, !1), e.texImage2D(e.TEXTURE_2D, 0, e.RGBA32F, this.textureSize[0], this.textureSize[1], 0, e.RGBA, e.FLOAT, this.uploadValue), this.kernel.setUniform1i(this.id, this.index)
                            }
                        }
                    }
                }, {
                    "../../../utils": 114,
                    "../../web-gl/kernel-value/single-array1d-i": 64
                }],
                100: [function(t, e, n) {
                    const {
                        utils: i
                    } = t("../../../utils"), {
                        WebGLKernelValueSingleArray2DI: s
                    } = t("../../web-gl/kernel-value/single-array2d-i");
                    e.exports = {
                        WebGL2KernelValueSingleArray2DI: class extends s {
                            updateValue(t) {
                                if (t.constructor !== this.initialValueConstructor) return void this.onUpdateValueMismatch(t.constructor);
                                const {
                                    context: e
                                } = this;
                                i.flattenTo(t, this.uploadValue), e.activeTexture(this.contextHandle), e.bindTexture(e.TEXTURE_2D, this.texture), e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, !1), e.texImage2D(e.TEXTURE_2D, 0, e.RGBA32F, this.textureSize[0], this.textureSize[1], 0, e.RGBA, e.FLOAT, this.uploadValue), this.kernel.setUniform1i(this.id, this.index)
                            }
                        }
                    }
                }, {
                    "../../../utils": 114,
                    "../../web-gl/kernel-value/single-array2d-i": 65
                }],
                101: [function(t, e, n) {
                    const {
                        utils: i
                    } = t("../../../utils"), {
                        WebGLKernelValueSingleArray3DI: s
                    } = t("../../web-gl/kernel-value/single-array3d-i");
                    e.exports = {
                        WebGL2KernelValueSingleArray3DI: class extends s {
                            updateValue(t) {
                                if (t.constructor !== this.initialValueConstructor) return void this.onUpdateValueMismatch(t.constructor);
                                const {
                                    context: e
                                } = this;
                                i.flattenTo(t, this.uploadValue), e.activeTexture(this.contextHandle), e.bindTexture(e.TEXTURE_2D, this.texture), e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, !1), e.texImage2D(e.TEXTURE_2D, 0, e.RGBA32F, this.textureSize[0], this.textureSize[1], 0, e.RGBA, e.FLOAT, this.uploadValue), this.kernel.setUniform1i(this.id, this.index)
                            }
                        }
                    }
                }, {
                    "../../../utils": 114,
                    "../../web-gl/kernel-value/single-array3d-i": 66
                }],
                102: [function(t, e, n) {
                    const {
                        utils: i
                    } = t("../../../utils"), {
                        WebGLKernelValueSingleInput: s
                    } = t("../../web-gl/kernel-value/single-input");
                    e.exports = {
                        WebGL2KernelValueSingleInput: class extends s {
                            getSource() {
                                const t = this.getVariablePrecisionString();
                                return i.linesToString([`uniform ${t} sampler2D ${this.id}`, `${t} ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`, `${t} ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`])
                            }
                            updateValue(t) {
                                const {
                                    context: e
                                } = this;
                                i.flattenTo(t.value, this.uploadValue), e.activeTexture(this.contextHandle), e.bindTexture(e.TEXTURE_2D, this.texture), e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, !1), e.texImage2D(e.TEXTURE_2D, 0, e.RGBA32F, this.textureSize[0], this.textureSize[1], 0, e.RGBA, e.FLOAT, this.uploadValue), this.kernel.setUniform1i(this.id, this.index)
                            }
                        }
                    }
                }, {
                    "../../../utils": 114,
                    "../../web-gl/kernel-value/single-input": 67
                }],
                103: [function(t, e, n) {
                    const {
                        utils: i
                    } = t("../../../utils"), {
                        WebGLKernelValueUnsignedArray: s
                    } = t("../../web-gl/kernel-value/unsigned-array");
                    e.exports = {
                        WebGL2KernelValueUnsignedArray: class extends s {
                            getSource() {
                                const t = this.getVariablePrecisionString();
                                return i.linesToString([`uniform ${t} sampler2D ${this.id}`, `${t} ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`, `${t} ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`])
                            }
                        }
                    }
                }, {
                    "../../../utils": 114,
                    "../../web-gl/kernel-value/unsigned-array": 68
                }],
                104: [function(t, e, n) {
                    const {
                        utils: i
                    } = t("../../../utils"), {
                        WebGLKernelValueUnsignedInput: s
                    } = t("../../web-gl/kernel-value/unsigned-input");
                    e.exports = {
                        WebGL2KernelValueUnsignedInput: class extends s {
                            getSource() {
                                const t = this.getVariablePrecisionString();
                                return i.linesToString([`uniform ${t} sampler2D ${this.id}`, `${t} ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`, `${t} ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`])
                            }
                        }
                    }
                }, {
                    "../../../utils": 114,
                    "../../web-gl/kernel-value/unsigned-input": 69
                }],
                105: [function(t, e, n) {
                    const {
                        WebGLKernel: i
                    } = t("../web-gl/kernel"), {
                        WebGL2FunctionNode: s
                    } = t("./function-node"), {
                        FunctionBuilder: r
                    } = t("../function-builder"), {
                        utils: a
                    } = t("../../utils"), {
                        fragmentShader: o
                    } = t("./fragment-shader"), {
                        vertexShader: u
                    } = t("./vertex-shader"), {
                        lookupKernelValueType: h
                    } = t("./kernel-value-maps");
                    let l = null,
                        c = null,
                        p = null,
                        d = null,
                        m = null;
                    e.exports = {
                        WebGL2Kernel: class extends i {
                            static get isSupported() {
                                return null !== l || (this.setupFeatureChecks(), l = this.isContextMatch(p)), l
                            }
                            static setupFeatureChecks() {
                                "undefined" != typeof document ? c = document.createElement("canvas") : "undefined" != typeof OffscreenCanvas && (c = new OffscreenCanvas(0, 0)), c && (p = c.getContext("webgl2"), p && p.getExtension && (d = {
                                    EXT_color_buffer_float: p.getExtension("EXT_color_buffer_float"),
                                    OES_texture_float_linear: p.getExtension("OES_texture_float_linear")
                                }, m = this.getFeatures()))
                            }
                            static isContextMatch(t) {
                                return "undefined" != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext
                            }
                            static getFeatures() {
                                const t = this.testContext;
                                return Object.freeze({
                                    isFloatRead: this.getIsFloatRead(),
                                    isIntegerDivisionAccurate: this.getIsIntegerDivisionAccurate(),
                                    isSpeedTacticSupported: this.getIsSpeedTacticSupported(),
                                    kernelMap: !0,
                                    isTextureFloat: !0,
                                    isDrawBuffers: !0,
                                    channelCount: this.getChannelCount(),
                                    maxTextureSize: this.getMaxTextureSize(),
                                    lowIntPrecision: t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.LOW_INT),
                                    lowFloatPrecision: t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.LOW_FLOAT),
                                    mediumIntPrecision: t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.MEDIUM_INT),
                                    mediumFloatPrecision: t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.MEDIUM_FLOAT),
                                    highIntPrecision: t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_INT),
                                    highFloatPrecision: t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT)
                                })
                            }
                            static getIsTextureFloat() {
                                return !0
                            }
                            static getChannelCount() {
                                return p.getParameter(p.MAX_DRAW_BUFFERS)
                            }
                            static getMaxTextureSize() {
                                return p.getParameter(p.MAX_TEXTURE_SIZE)
                            }
                            static lookupKernelValueType(t, e, n, i) {
                                return h(t, e, n, i)
                            }
                            static get testCanvas() {
                                return c
                            }
                            static get testContext() {
                                return p
                            }
                            static get features() {
                                return m
                            }
                            static get fragmentShader() {
                                return o
                            }
                            static get vertexShader() {
                                return u
                            }
                            initContext() {
                                return this.canvas.getContext("webgl2", {
                                    alpha: !1,
                                    depth: !1,
                                    antialias: !1
                                })
                            }
                            initExtensions() {
                                this.extensions = {
                                    EXT_color_buffer_float: this.context.getExtension("EXT_color_buffer_float"),
                                    OES_texture_float_linear: this.context.getExtension("OES_texture_float_linear")
                                }
                            }
                            validateSettings(t) {
                                if (!this.validate) return void(this.texSize = a.getKernelTextureSize({
                                    optimizeFloatMemory: this.optimizeFloatMemory,
                                    precision: this.precision
                                }, this.output));
                                const {
                                    features: e
                                } = this.constructor;
                                if ("single" === this.precision && !e.isFloatRead) throw new Error("Float texture outputs are not supported");
                                if (this.graphical || null !== this.precision || (this.precision = e.isFloatRead ? "single" : "unsigned"), null === this.fixIntegerDivisionAccuracy ? this.fixIntegerDivisionAccuracy = !e.isIntegerDivisionAccurate : this.fixIntegerDivisionAccuracy && e.isIntegerDivisionAccurate && (this.fixIntegerDivisionAccuracy = !1), this.checkOutput(), !this.output || 0 === this.output.length) {
                                    if (1 !== t.length) throw new Error("Auto output only supported for kernels with only one input");
                                    const e = a.getVariableType(t[0], this.strictIntegers);
                                    switch (e) {
                                        case "Array":
                                            this.output = a.getDimensions(e);
                                            break;
                                        case "NumberTexture":
                                        case "MemoryOptimizedNumberTexture":
                                        case "ArrayTexture(1)":
                                        case "ArrayTexture(2)":
                                        case "ArrayTexture(3)":
                                        case "ArrayTexture(4)":
                                            this.output = t[0].output;
                                            break;
                                        default:
                                            throw new Error("Auto output not supported for input type: " + e)
                                    }
                                }
                                if (this.graphical) {
                                    if (2 !== this.output.length) throw new Error("Output must have 2 dimensions on graphical mode");
                                    return "single" === this.precision && (console.warn("Cannot use graphical mode and single precision at the same time"), this.precision = "unsigned"), void(this.texSize = a.clone(this.output))
                                }!this.graphical && null === this.precision && e.isTextureFloat && (this.precision = "single"), this.texSize = a.getKernelTextureSize({
                                    optimizeFloatMemory: this.optimizeFloatMemory,
                                    precision: this.precision
                                }, this.output), this.checkTextureSize()
                            }
                            translateSource() {
                                const t = r.fromKernel(this, s, {
                                    fixIntegerDivisionAccuracy: this.fixIntegerDivisionAccuracy
                                });
                                this.translatedSource = t.getPrototypeString("kernel"), this.setupReturnTypes(t)
                            }
                            drawBuffers() {
                                this.context.drawBuffers(this.drawBuffersMap)
                            }
                            getTextureFormat() {
                                const {
                                    context: t
                                } = this;
                                switch (this.getInternalFormat()) {
                                    case t.R32F:
                                        return t.RED;
                                    case t.RG32F:
                                        return t.RG;
                                    case t.RGBA32F:
                                    case t.RGBA:
                                        return t.RGBA;
                                    default:
                                        throw new Error("Unknown internal format")
                                }
                            }
                            getInternalFormat() {
                                const {
                                    context: t
                                } = this;
                                if ("single" === this.precision) {
                                    if (this.pipeline) switch (this.returnType) {
                                        case "Number":
                                        case "Float":
                                        case "Integer":
                                            return this.optimizeFloatMemory ? t.RGBA32F : t.R32F;
                                        case "Array(2)":
                                            return t.RG32F;
                                        case "Array(3)":
                                        case "Array(4)":
                                            return t.RGBA32F;
                                        default:
                                            throw new Error("Unhandled return type")
                                    }
                                    return t.RGBA32F
                                }
                                return t.RGBA
                            }
                            _setupOutputTexture() {
                                const t = this.context;
                                if (this.texture) return void t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, this.texture.texture, 0);
                                t.bindFramebuffer(t.FRAMEBUFFER, this.framebuffer);
                                const e = t.createTexture(),
                                    n = this.texSize;
                                t.activeTexture(t.TEXTURE0 + this.constantTextureCount + this.argumentTextureCount), t.bindTexture(t.TEXTURE_2D, e), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.REPEAT), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.REPEAT), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.NEAREST), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t.NEAREST);
                                const i = this.getInternalFormat();
                                "single" === this.precision ? t.texStorage2D(t.TEXTURE_2D, 1, i, n[0], n[1]) : t.texImage2D(t.TEXTURE_2D, 0, i, n[0], n[1], 0, i, t.UNSIGNED_BYTE, null), t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, e, 0), this.texture = new this.TextureConstructor({
                                    texture: e,
                                    size: n,
                                    dimensions: this.threadDim,
                                    output: this.output,
                                    context: this.context,
                                    internalFormat: this.getInternalFormat(),
                                    textureFormat: this.getTextureFormat(),
                                    kernel: this
                                })
                            }
                            _setupSubOutputTextures() {
                                const t = this.context;
                                if (this.mappedTextures) {
                                    for (let e = 0; e < this.subKernels.length; e++) t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0 + e + 1, t.TEXTURE_2D, this.mappedTextures[e].texture, 0);
                                    return
                                }
                                const e = this.texSize;
                                this.drawBuffersMap = [t.COLOR_ATTACHMENT0], this.mappedTextures = [];
                                for (let n = 0; n < this.subKernels.length; n++) {
                                    const i = this.createTexture();
                                    this.drawBuffersMap.push(t.COLOR_ATTACHMENT0 + n + 1), t.activeTexture(t.TEXTURE0 + this.constantTextureCount + this.argumentTextureCount + n), t.bindTexture(t.TEXTURE_2D, i), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.NEAREST), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t.NEAREST);
                                    const s = this.getInternalFormat();
                                    "single" === this.precision ? t.texStorage2D(t.TEXTURE_2D, 1, s, e[0], e[1]) : t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, e[0], e[1], 0, t.RGBA, t.UNSIGNED_BYTE, null), t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0 + n + 1, t.TEXTURE_2D, i, 0), this.mappedTextures.push(new this.TextureConstructor({
                                        texture: i,
                                        size: e,
                                        dimensions: this.threadDim,
                                        output: this.output,
                                        context: this.context,
                                        internalFormat: this.getInternalFormat(),
                                        textureFormat: this.getTextureFormat(),
                                        kernel: this
                                    }))
                                }
                            }
                            _getHeaderString() {
                                return ""
                            }
                            _getTextureCoordinate() {
                                const t = this.subKernels,
                                    e = this.getVariablePrecisionString(this.texSize, this.tactic);
                                return null === t || t.length < 1 ? `in ${e} vec2 vTexCoord;\n` : `out ${e} vec2 vTexCoord;\n`
                            }
                            _getMainArgumentsString(t) {
                                const e = [],
                                    n = this.argumentNames;
                                for (let i = 0; i < n.length; i++) e.push(this.kernelArguments[i].getSource(t[i]));
                                return e.join("")
                            }
                            getKernelString() {
                                const t = [this.getKernelResultDeclaration()],
                                    e = this.subKernels;
                                if (null !== e) switch (t.push("layout(location = 0) out vec4 data0"), this.returnType) {
                                    case "Number":
                                    case "Float":
                                    case "Integer":
                                        for (let n = 0; n < e.length; n++) {
                                            const i = e[n];
                                            t.push("Integer" === i.returnType ? `int subKernelResult_${i.name} = 0` : `float subKernelResult_${i.name} = 0.0`, `layout(location = ${n+1}) out vec4 data${n+1}`)
                                        }
                                        break;
                                    case "Array(2)":
                                        for (let n = 0; n < e.length; n++) t.push(`vec2 subKernelResult_${e[n].name}`, `layout(location = ${n+1}) out vec4 data${n+1}`);
                                        break;
                                    case "Array(3)":
                                        for (let n = 0; n < e.length; n++) t.push(`vec3 subKernelResult_${e[n].name}`, `layout(location = ${n+1}) out vec4 data${n+1}`);
                                        break;
                                    case "Array(4)":
                                        for (let n = 0; n < e.length; n++) t.push(`vec4 subKernelResult_${e[n].name}`, `layout(location = ${n+1}) out vec4 data${n+1}`)
                                } else t.push("out vec4 data0");
                                return a.linesToString(t) + this.translatedSource
                            }
                            getMainResultGraphical() {
                                return a.linesToString(["  threadId = indexTo3D(index, uOutputDim)", "  kernel()", "  data0 = actualColor"])
                            }
                            getMainResultPackedPixels() {
                                switch (this.returnType) {
                                    case "LiteralInteger":
                                    case "Number":
                                    case "Integer":
                                    case "Float":
                                        return this.getMainResultKernelPackedPixels() + this.getMainResultSubKernelPackedPixels();
                                    default:
                                        throw new Error(`packed output only usable with Numbers, "${this.returnType}" specified`)
                                }
                            }
                            getMainResultKernelPackedPixels() {
                                return a.linesToString(["  threadId = indexTo3D(index, uOutputDim)", "  kernel()", `  data0 = ${this.useLegacyEncoder?"legacyEncode32":"encode32"}(kernelResult)`])
                            }
                            getMainResultSubKernelPackedPixels() {
                                const t = [];
                                if (!this.subKernels) return "";
                                for (let e = 0; e < this.subKernels.length; e++) "Integer" === this.subKernels[e].returnType ? t.push(`  data${e+1} = ${this.useLegacyEncoder?"legacyEncode32":"encode32"}(float(subKernelResult_${this.subKernels[e].name}))`) : t.push(`  data${e+1} = ${this.useLegacyEncoder?"legacyEncode32":"encode32"}(subKernelResult_${this.subKernels[e].name})`);
                                return a.linesToString(t)
                            }
                            getMainResultKernelMemoryOptimizedFloats(t, e) {
                                t.push("  threadId = indexTo3D(index, uOutputDim)", "  kernel()", `  data0.${e} = kernelResult`)
                            }
                            getMainResultSubKernelMemoryOptimizedFloats(t, e) {
                                if (!this.subKernels) return t;
                                for (let n = 0; n < this.subKernels.length; n++) {
                                    const i = this.subKernels[n];
                                    "Integer" === i.returnType ? t.push(`  data${n+1}.${e} = float(subKernelResult_${i.name})`) : t.push(`  data${n+1}.${e} = subKernelResult_${i.name}`)
                                }
                            }
                            getMainResultKernelNumberTexture() {
                                return ["  threadId = indexTo3D(index, uOutputDim)", "  kernel()", "  data0[0] = kernelResult"]
                            }
                            getMainResultSubKernelNumberTexture() {
                                const t = [];
                                if (!this.subKernels) return t;
                                for (let e = 0; e < this.subKernels.length; ++e) {
                                    const n = this.subKernels[e];
                                    "Integer" === n.returnType ? t.push(`  data${e+1}[0] = float(subKernelResult_${n.name})`) : t.push(`  data${e+1}[0] = subKernelResult_${n.name}`)
                                }
                                return t
                            }
                            getMainResultKernelArray2Texture() {
                                return ["  threadId = indexTo3D(index, uOutputDim)", "  kernel()", "  data0[0] = kernelResult[0]", "  data0[1] = kernelResult[1]"]
                            }
                            getMainResultSubKernelArray2Texture() {
                                const t = [];
                                if (!this.subKernels) return t;
                                for (let e = 0; e < this.subKernels.length; ++e) {
                                    const n = this.subKernels[e];
                                    t.push(`  data${e+1}[0] = subKernelResult_${n.name}[0]`, `  data${e+1}[1] = subKernelResult_${n.name}[1]`)
                                }
                                return t
                            }
                            getMainResultKernelArray3Texture() {
                                return ["  threadId = indexTo3D(index, uOutputDim)", "  kernel()", "  data0[0] = kernelResult[0]", "  data0[1] = kernelResult[1]", "  data0[2] = kernelResult[2]"]
                            }
                            getMainResultSubKernelArray3Texture() {
                                const t = [];
                                if (!this.subKernels) return t;
                                for (let e = 0; e < this.subKernels.length; ++e) {
                                    const n = this.subKernels[e];
                                    t.push(`  data${e+1}[0] = subKernelResult_${n.name}[0]`, `  data${e+1}[1] = subKernelResult_${n.name}[1]`, `  data${e+1}[2] = subKernelResult_${n.name}[2]`)
                                }
                                return t
                            }
                            getMainResultKernelArray4Texture() {
                                return ["  threadId = indexTo3D(index, uOutputDim)", "  kernel()", "  data0 = kernelResult"]
                            }
                            getMainResultSubKernelArray4Texture() {
                                const t = [];
                                if (!this.subKernels) return t;
                                for (let e = 0; e < this.subKernels.length; ++e) t.push(`  data${e+1} = subKernelResult_${this.subKernels[e].name}`);
                                return t
                            }
                            destroyExtensions() {
                                this.extensions.EXT_color_buffer_float = null, this.extensions.OES_texture_float_linear = null
                            }
                            toJSON() {
                                const t = super.toJSON();
                                return t.functionNodes = r.fromKernel(this, s).toJSON(), t.settings.threadDim = this.threadDim, t
                            }
                        }
                    }
                }, {
                    "../../utils": 114,
                    "../function-builder": 9,
                    "../web-gl/kernel": 70,
                    "./fragment-shader": 72,
                    "./function-node": 73,
                    "./kernel-value-maps": 74,
                    "./vertex-shader": 106
                }],
                106: [function(t, e, n) {
                    e.exports = {
                        vertexShader: "#version 300 es\n__FLOAT_TACTIC_DECLARATION__;\n__INT_TACTIC_DECLARATION__;\n__SAMPLER_2D_TACTIC_DECLARATION__;\n\nin vec2 aPos;\nin vec2 aTexCoord;\n\nout vec2 vTexCoord;\nuniform vec2 ratio;\n\nvoid main(void) {\n  gl_Position = vec4((aPos + vec2(1)) * ratio + vec2(-1), 0, 1);\n  vTexCoord = aTexCoord;\n}"
                    }
                }, {}],
                107: [function(t, e, n) {
                    const i = t("./index"),
                        s = i.GPU;
                    for (const t in i) i.hasOwnProperty(t) && "GPU" !== t && (s[t] = i[t]);

                    function r(t) {
                        t.GPU || Object.defineProperty(t, "GPU", {
                            get: () => s
                        })
                    }
                    "undefined" != typeof window && r(window), "undefined" != typeof self && r(self), e.exports = i
                }, {
                    "./index": 109
                }],
                108: [function(t, e, n) {
                    const {
                        gpuMock: i
                    } = t("gpu-mock.js"), {
                        utils: s
                    } = t("./utils"), {
                        Kernel: r
                    } = t("./backend/kernel"), {
                        CPUKernel: a
                    } = t("./backend/cpu/kernel"), {
                        HeadlessGLKernel: o
                    } = t("./backend/headless-gl/kernel"), {
                        WebGL2Kernel: u
                    } = t("./backend/web-gl2/kernel"), {
                        WebGLKernel: h
                    } = t("./backend/web-gl/kernel"), {
                        kernelRunShortcut: l
                    } = t("./kernel-run-shortcut"), c = [o, u, h], p = ["gpu", "cpu"], d = {
                        headlessgl: o,
                        webgl2: u,
                        webgl: h
                    };
                    let m = !0;

                    function g(t) {
                        if (!t) return {};
                        const e = Object.assign({}, t);
                        return t.hasOwnProperty("floatOutput") && (s.warnDeprecated("setting", "floatOutput", "precision"), e.precision = t.floatOutput ? "single" : "unsigned"), t.hasOwnProperty("outputToTexture") && (s.warnDeprecated("setting", "outputToTexture", "pipeline"), e.pipeline = Boolean(t.outputToTexture)), t.hasOwnProperty("outputImmutable") && (s.warnDeprecated("setting", "outputImmutable", "immutable"), e.immutable = Boolean(t.outputImmutable)), t.hasOwnProperty("floatTextures") && (s.warnDeprecated("setting", "floatTextures", "optimizeFloatMemory"), e.optimizeFloatMemory = Boolean(t.floatTextures)), e
                    }
                    e.exports = {
                        GPU: class {
                            static disableValidation() {
                                m = !1
                            }
                            static enableValidation() {
                                m = !0
                            }
                            static get isGPUSupported() {
                                return c.some((t => t.isSupported))
                            }
                            static get isKernelMapSupported() {
                                return c.some((t => t.isSupported && t.features.kernelMap))
                            }
                            static get isOffscreenCanvasSupported() {
                                return "undefined" != typeof Worker && "undefined" != typeof OffscreenCanvas || "undefined" != typeof importScripts
                            }
                            static get isWebGLSupported() {
                                return h.isSupported
                            }
                            static get isWebGL2Supported() {
                                return u.isSupported
                            }
                            static get isHeadlessGLSupported() {
                                return o.isSupported
                            }
                            static get isCanvasSupported() {
                                return "undefined" != typeof HTMLCanvasElement
                            }
                            static get isGPUHTMLImageArraySupported() {
                                return u.isSupported
                            }
                            static get isSinglePrecisionSupported() {
                                return c.some((t => t.isSupported && t.features.isFloatRead && t.features.isTextureFloat))
                            }
                            constructor(t) {
                                if (t = t || {}, this.canvas = t.canvas || null, this.context = t.context || null, this.mode = t.mode, this.Kernel = null, this.kernels = [], this.functions = [], this.nativeFunctions = [], this.injectedNative = null, "dev" !== this.mode) {
                                    if (this.chooseKernel(), t.functions)
                                        for (let e = 0; e < t.functions.length; e++) this.addFunction(t.functions[e]);
                                    if (t.nativeFunctions)
                                        for (const e in t.nativeFunctions) {
                                            if (!t.nativeFunctions.hasOwnProperty(e)) continue;
                                            const n = t.nativeFunctions[e],
                                                {
                                                    name: i,
                                                    source: s
                                                } = n;
                                            this.addNativeFunction(i, s, n)
                                        }
                                }
                            }
                            chooseKernel() {
                                if (this.Kernel) return;
                                let t = null;
                                if (this.context) {
                                    for (let e = 0; e < c.length; e++) {
                                        const n = c[e];
                                        if (n.isContextMatch(this.context)) {
                                            if (!n.isSupported) throw new Error(`Kernel type ${n.name} not supported`);
                                            t = n;
                                            break
                                        }
                                    }
                                    if (null === t) throw new Error("unknown Context")
                                } else if (this.mode) {
                                    if (this.mode in d) m && !d[this.mode].isSupported || (t = d[this.mode]);
                                    else if ("gpu" === this.mode) {
                                        for (let e = 0; e < c.length; e++)
                                            if (c[e].isSupported) {
                                                t = c[e];
                                                break
                                            }
                                    } else "cpu" === this.mode && (t = a);
                                    if (!t) throw new Error(`A requested mode of "${this.mode}" and is not supported`)
                                } else {
                                    for (let e = 0; e < c.length; e++)
                                        if (c[e].isSupported) {
                                            t = c[e];
                                            break
                                        } t || (t = a)
                                }
                                this.mode || (this.mode = t.mode), this.Kernel = t
                            }
                            createKernel(t, e) {
                                if (void 0 === t) throw new Error("Missing source parameter");
                                if ("object" != typeof t && !s.isFunction(t) && "string" != typeof t) throw new Error("source parameter not a function");
                                const n = this.kernels;
                                if ("dev" === this.mode) {
                                    const s = i(t, g(e));
                                    return n.push(s), s
                                }
                                t = "function" == typeof t ? t.toString() : t;
                                const r = {},
                                    o = g(e) || {};

                                function u(e) {
                                    console.warn("Falling back to CPU");
                                    const n = new a(t, {
                                        argumentTypes: p.argumentTypes,
                                        constantTypes: p.constantTypes,
                                        graphical: p.graphical,
                                        loopMaxIterations: p.loopMaxIterations,
                                        constants: p.constants,
                                        dynamicOutput: p.dynamicOutput,
                                        dynamicArgument: p.dynamicArguments,
                                        output: p.output,
                                        precision: p.precision,
                                        pipeline: p.pipeline,
                                        immutable: p.immutable,
                                        optimizeFloatMemory: p.optimizeFloatMemory,
                                        fixIntegerDivisionAccuracy: p.fixIntegerDivisionAccuracy,
                                        functions: p.functions,
                                        nativeFunctions: p.nativeFunctions,
                                        injectedNative: p.injectedNative,
                                        subKernels: p.subKernels,
                                        strictIntegers: p.strictIntegers,
                                        debug: p.debug
                                    });
                                    n.build.apply(n, e);
                                    const i = n.run.apply(n, e);
                                    return p.replaceKernel(n), i
                                }
                                e && "object" == typeof e.argumentTypes && (o.argumentTypes = Object.keys(e.argumentTypes).map((t => e.argumentTypes[t])));
                                const h = Object.assign({
                                        context: this.context,
                                        canvas: this.canvas,
                                        functions: this.functions,
                                        nativeFunctions: this.nativeFunctions,
                                        injectedNative: this.injectedNative,
                                        gpu: this,
                                        validate: m,
                                        onRequestFallback: u,
                                        onRequestSwitchKernel: function e(i, s, a) {
                                            a.debug && console.warn("Switching kernels");
                                            let o = null;
                                            if (a.signature && !r[a.signature] && (r[a.signature] = a), a.dynamicOutput)
                                                for (let t = i.length - 1; t >= 0; t--) {
                                                    const e = i[t];
                                                    "outputPrecisionMismatch" === e.type && (o = e.needed)
                                                }
                                            const h = a.constructor,
                                                l = h.getArgumentTypes(a, s),
                                                c = h.getSignature(a, l),
                                                d = r[c];
                                            if (d) return d.onActivate(a), d;
                                            const g = r[c] = new h(t, {
                                                argumentTypes: l,
                                                constantTypes: a.constantTypes,
                                                graphical: a.graphical,
                                                loopMaxIterations: a.loopMaxIterations,
                                                constants: a.constants,
                                                dynamicOutput: a.dynamicOutput,
                                                dynamicArgument: a.dynamicArguments,
                                                context: a.context,
                                                canvas: a.canvas,
                                                output: o || a.output,
                                                precision: a.precision,
                                                pipeline: a.pipeline,
                                                immutable: a.immutable,
                                                optimizeFloatMemory: a.optimizeFloatMemory,
                                                fixIntegerDivisionAccuracy: a.fixIntegerDivisionAccuracy,
                                                functions: a.functions,
                                                nativeFunctions: a.nativeFunctions,
                                                injectedNative: a.injectedNative,
                                                subKernels: a.subKernels,
                                                strictIntegers: a.strictIntegers,
                                                debug: a.debug,
                                                gpu: a.gpu,
                                                validate: m,
                                                returnType: a.returnType,
                                                tactic: a.tactic,
                                                onRequestFallback: u,
                                                onRequestSwitchKernel: e,
                                                texture: a.texture,
                                                mappedTextures: a.mappedTextures,
                                                drawBuffersMap: a.drawBuffersMap
                                            });
                                            return g.build.apply(g, s), p.replaceKernel(g), n.push(g), g
                                        }
                                    }, o),
                                    c = new this.Kernel(t, h),
                                    p = l(c);
                                return this.canvas || (this.canvas = c.canvas), this.context || (this.context = c.context), n.push(c), p
                            }
                            createKernelMap() {
                                let t, e;
                                const n = typeof arguments[arguments.length - 2];
                                if ("function" === n || "string" === n ? (t = arguments[arguments.length - 2], e = arguments[arguments.length - 1]) : t = arguments[arguments.length - 1], "dev" !== this.mode && (!this.Kernel.isSupported || !this.Kernel.features.kernelMap) && this.mode && p.indexOf(this.mode) < 0) throw new Error(`kernelMap not supported on ${this.Kernel.name}`);
                                const i = g(e);
                                if (e && "object" == typeof e.argumentTypes && (i.argumentTypes = Object.keys(e.argumentTypes).map((t => e.argumentTypes[t]))), Array.isArray(arguments[0])) {
                                    i.subKernels = [];
                                    const t = arguments[0];
                                    for (let e = 0; e < t.length; e++) {
                                        const n = t[e].toString(),
                                            r = s.getFunctionNameFromString(n);
                                        i.subKernels.push({
                                            name: r,
                                            source: n,
                                            property: e
                                        })
                                    }
                                } else {
                                    i.subKernels = [];
                                    const t = arguments[0];
                                    for (let e in t) {
                                        if (!t.hasOwnProperty(e)) continue;
                                        const n = t[e].toString(),
                                            r = s.getFunctionNameFromString(n);
                                        i.subKernels.push({
                                            name: r || e,
                                            source: n,
                                            property: e
                                        })
                                    }
                                }
                                return this.createKernel(t, i)
                            }
                            combineKernels() {
                                const t = arguments[arguments.length - 1];
                                if ("cpu" === arguments[0].kernel.constructor.mode) return t;
                                const e = arguments[0].canvas,
                                    n = arguments[0].context,
                                    i = arguments.length - 1;
                                for (let t = 0; t < i; t++) arguments[t].setCanvas(e).setContext(n).setPipeline(!0);
                                return function() {
                                    const e = t.apply(this, arguments);
                                    return e.toArray ? e.toArray() : e
                                }
                            }
                            setFunctions(t) {
                                return this.functions = t, this
                            }
                            setNativeFunctions(t) {
                                return this.nativeFunctions = t, this
                            }
                            addFunction(t, e) {
                                return this.functions.push({
                                    source: t,
                                    settings: e
                                }), this
                            }
                            addNativeFunction(t, e, n) {
                                if (this.kernels.length > 0) throw new Error('Cannot call "addNativeFunction" after "createKernels" has been called.');
                                return this.nativeFunctions.push(Object.assign({
                                    name: t,
                                    source: e
                                }, n)), this
                            }
                            injectNative(t) {
                                return this.injectedNative = t, this
                            }
                            destroy() {
                                return new Promise(((t, e) => {
                                    this.kernels || t(), setTimeout((() => {
                                        try {
                                            for (let t = 0; t < this.kernels.length; t++) this.kernels[t].destroy(!0);
                                            let t = this.kernels[0];
                                            t && (t.kernel && (t = t.kernel), t.constructor.destroyContext && t.constructor.destroyContext(this.context))
                                        } catch (t) {
                                            e(t)
                                        }
                                        t()
                                    }), 0)
                                }))
                            }
                        },
                        kernelOrder: c,
                        kernelTypes: p
                    }
                }, {
                    "./backend/cpu/kernel": 8,
                    "./backend/headless-gl/kernel": 34,
                    "./backend/kernel": 36,
                    "./backend/web-gl/kernel": 70,
                    "./backend/web-gl2/kernel": 105,
                    "./kernel-run-shortcut": 111,
                    "./utils": 114,
                    "gpu-mock.js": 4
                }],
                109: [function(t, e, n) {
                    const {
                        GPU: i
                    } = t("./gpu"), {
                        alias: s
                    } = t("./alias"), {
                        utils: r
                    } = t("./utils"), {
                        Input: a,
                        input: o
                    } = t("./input"), {
                        Texture: u
                    } = t("./texture"), {
                        FunctionBuilder: h
                    } = t("./backend/function-builder"), {
                        FunctionNode: l
                    } = t("./backend/function-node"), {
                        CPUFunctionNode: c
                    } = t("./backend/cpu/function-node"), {
                        CPUKernel: p
                    } = t("./backend/cpu/kernel"), {
                        HeadlessGLKernel: d
                    } = t("./backend/headless-gl/kernel"), {
                        WebGLFunctionNode: m
                    } = t("./backend/web-gl/function-node"), {
                        WebGLKernel: g
                    } = t("./backend/web-gl/kernel"), {
                        kernelValueMaps: f
                    } = t("./backend/web-gl/kernel-value-maps"), {
                        WebGL2FunctionNode: y
                    } = t("./backend/web-gl2/function-node"), {
                        WebGL2Kernel: x
                    } = t("./backend/web-gl2/kernel"), {
                        kernelValueMaps: _
                    } = t("./backend/web-gl2/kernel-value-maps"), {
                        GLKernel: b
                    } = t("./backend/gl/kernel"), {
                        Kernel: w
                    } = t("./backend/kernel"), {
                        FunctionTracer: T
                    } = t("./backend/function-tracer"), v = t("./plugins/math-random-uniformly-distributed");
                    e.exports = {
                        alias: s,
                        CPUFunctionNode: c,
                        CPUKernel: p,
                        GPU: i,
                        FunctionBuilder: h,
                        FunctionNode: l,
                        HeadlessGLKernel: d,
                        Input: a,
                        input: o,
                        Texture: u,
                        utils: r,
                        WebGL2FunctionNode: y,
                        WebGL2Kernel: x,
                        webGL2KernelValueMaps: _,
                        WebGLFunctionNode: m,
                        WebGLKernel: g,
                        webGLKernelValueMaps: f,
                        GLKernel: b,
                        Kernel: w,
                        FunctionTracer: T,
                        plugins: {
                            mathRandom: v
                        }
                    }
                }, {
                    "./alias": 5,
                    "./backend/cpu/function-node": 6,
                    "./backend/cpu/kernel": 8,
                    "./backend/function-builder": 9,
                    "./backend/function-node": 10,
                    "./backend/function-tracer": 11,
                    "./backend/gl/kernel": 13,
                    "./backend/headless-gl/kernel": 34,
                    "./backend/kernel": 36,
                    "./backend/web-gl/function-node": 38,
                    "./backend/web-gl/kernel": 70,
                    "./backend/web-gl/kernel-value-maps": 39,
                    "./backend/web-gl2/function-node": 73,
                    "./backend/web-gl2/kernel": 105,
                    "./backend/web-gl2/kernel-value-maps": 74,
                    "./gpu": 108,
                    "./input": 110,
                    "./plugins/math-random-uniformly-distributed": 112,
                    "./texture": 113,
                    "./utils": 114
                }],
                110: [function(t, e, n) {
                    class i {
                        constructor(t, e) {
                            this.value = t, Array.isArray(e) ? this.size = e : (this.size = new Int32Array(3), e.z ? this.size = new Int32Array([e.x, e.y, e.z]) : e.y ? this.size = new Int32Array([e.x, e.y]) : this.size = new Int32Array([e.x]));
                            const [n, i, s] = this.size;
                            if (s) {
                                if (this.value.length !== n * i * s) throw new Error(`Input size ${this.value.length} does not match ${n} * ${i} * ${s} = ${i*n*s}`)
                            } else if (i) {
                                if (this.value.length !== n * i) throw new Error(`Input size ${this.value.length} does not match ${n} * ${i} = ${i*n}`)
                            } else if (this.value.length !== n) throw new Error(`Input size ${this.value.length} does not match ${n}`)
                        }
                        toArray() {
                            const {
                                utils: e
                            } = t("./utils"), [n, i, s] = this.size;
                            return s ? e.erectMemoryOptimized3DFloat(this.value.subarray ? this.value : new Float32Array(this.value), n, i, s) : i ? e.erectMemoryOptimized2DFloat(this.value.subarray ? this.value : new Float32Array(this.value), n, i) : this.value
                        }
                    }
                    e.exports = {
                        Input: i,
                        input: function(t, e) {
                            return new i(t, e)
                        }
                    }
                }, {
                    "./utils": 114
                }],
                111: [function(t, e, n) {
                    const {
                        utils: i
                    } = t("./utils");

                    function s(t, e) {
                        if (e.kernel) return void(e.kernel = t);
                        const n = i.allPropertiesOf(t);
                        for (let i = 0; i < n.length; i++) {
                            const s = n[i];
                            "_" === s[0] && "_" === s[1] || ("function" == typeof t[s] ? "add" === s.substring(0, 3) || "set" === s.substring(0, 3) ? e[s] = function() {
                                return e.kernel[s].apply(e.kernel, arguments), e
                            } : e[s] = function() {
                                return e.kernel[s].apply(e.kernel, arguments)
                            } : (e.__defineGetter__(s, (() => e.kernel[s])), e.__defineSetter__(s, (t => {
                                e.kernel[s] = t
                            }))))
                        }
                        e.kernel = t
                    }
                    e.exports = {
                        kernelRunShortcut: function(t) {
                            let e = function() {
                                return t.build.apply(t, arguments), e = function() {
                                    let e = t.run.apply(t, arguments);
                                    if (t.switchingKernels) {
                                        const i = t.resetSwitchingKernels(),
                                            s = t.onRequestSwitchKernel(i, arguments, t);
                                        n.kernel = t = s, e = s.run.apply(s, arguments)
                                    }
                                    return t.renderKernels ? t.renderKernels() : t.renderOutput ? t.renderOutput() : e
                                }, e.apply(t, arguments)
                            };
                            const n = function() {
                                return e.apply(t, arguments)
                            };
                            return n.exec = function() {
                                return new Promise(((t, n) => {
                                    try {
                                        t(e.apply(this, arguments))
                                    } catch (t) {
                                        n(t)
                                    }
                                }))
                            }, n.replaceKernel = function(e) {
                                s(t = e, n)
                            }, s(t, n), n
                        }
                    }
                }, {
                    "./utils": 114
                }],
                112: [function(t, e, n) {
                    const i = {
                        name: "math-random-uniformly-distributed",
                        onBeforeRun: t => {
                            t.setUniform1f("randomSeed1", Math.random()), t.setUniform1f("randomSeed2", Math.random())
                        },
                        functionMatch: "Math.random()",
                        functionReplace: "nrand(vTexCoord)",
                        functionReturnType: "Number",
                        source: "// https://www.shadertoy.com/view/4t2SDh\n//note: uniformly distributed, normalized rand, [0,1]\nhighp float randomSeedShift = 1.0;\nhighp float slide = 1.0;\nuniform highp float randomSeed1;\nuniform highp float randomSeed2;\n\nhighp float nrand(highp vec2 n) {\n  highp float result = fract(sin(dot((n.xy + 1.0) * vec2(randomSeed1 * slide, randomSeed2 * randomSeedShift), vec2(12.9898, 78.233))) * 43758.5453);\n  randomSeedShift = result;\n  if (randomSeedShift > 0.5) {\n    slide += 0.00009; \n  } else {\n    slide += 0.0009;\n  }\n  return result;\n}"
                    };
                    e.exports = i
                }, {}],
                113: [function(t, e, n) {
                    e.exports = {
                        Texture: class {
                            constructor(t) {
                                const {
                                    texture: e,
                                    size: n,
                                    dimensions: i,
                                    output: s,
                                    context: r,
                                    type: a = "NumberTexture",
                                    kernel: o,
                                    internalFormat: u,
                                    textureFormat: h
                                } = t;
                                if (!s) throw new Error('settings property "output" required.');
                                if (!r) throw new Error('settings property "context" required.');
                                if (!e) throw new Error('settings property "texture" required.');
                                if (!o) throw new Error('settings property "kernel" required.');
                                this.texture = e, e._refs ? e._refs++ : e._refs = 1, this.size = n, this.dimensions = i, this.output = s, this.context = r, this.kernel = o, this.type = a, this._deleted = !1, this.internalFormat = u, this.textureFormat = h
                            }
                            toArray() {
                                throw new Error(`Not implemented on ${this.constructor.name}`)
                            }
                            clone() {
                                throw new Error(`Not implemented on ${this.constructor.name}`)
                            }
                            delete() {
                                throw new Error(`Not implemented on ${this.constructor.name}`)
                            }
                            clear() {
                                throw new Error(`Not implemented on ${this.constructor.name}`)
                            }
                        }
                    }
                }, {}],
                114: [function(t, e, n) {
                    const i = t("acorn"),
                        {
                            Input: s
                        } = t("./input"),
                        {
                            Texture: r
                        } = t("./texture"),
                        a = /function ([^(]*)/,
                        o = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm,
                        u = /([^\s,]+)/g,
                        h = {
                            systemEndianness: () => d,
                            getSystemEndianness() {
                                const t = new ArrayBuffer(4),
                                    e = new Uint32Array(t),
                                    n = new Uint8Array(t);
                                if (e[0] = 3735928559, 239 === n[0]) return "LE";
                                if (222 === n[0]) return "BE";
                                throw new Error("unknown endianness")
                            },
                            isFunction: t => "function" == typeof t,
                            isFunctionString: t => "string" == typeof t && "function" === t.slice(0, "function".length).toLowerCase(),
                            getFunctionNameFromString(t) {
                                const e = a.exec(t);
                                return e && 0 !== e.length ? e[1].trim() : null
                            },
                            getFunctionBodyFromString: t => t.substring(t.indexOf("{") + 1, t.lastIndexOf("}")),
                            getArgumentNamesFromString(t) {
                                const e = t.replace(o, "");
                                let n = e.slice(e.indexOf("(") + 1, e.indexOf(")")).match(u);
                                return null === n && (n = []), n
                            },
                            clone(t) {
                                if (null === t || "object" != typeof t || t.hasOwnProperty("isActiveClone")) return t;
                                const e = t.constructor();
                                for (let n in t) Object.prototype.hasOwnProperty.call(t, n) && (t.isActiveClone = null, e[n] = h.clone(t[n]), delete t.isActiveClone);
                                return e
                            },
                            isArray: t => !isNaN(t.length),
                            getVariableType(t, e) {
                                if (h.isArray(t)) return t.length > 0 && "IMG" === t[0].nodeName ? "HTMLImageArray" : "Array";
                                switch (t.constructor) {
                                    case Boolean:
                                        return "Boolean";
                                    case Number:
                                        return e && Number.isInteger(t) ? "Integer" : "Float";
                                    case r:
                                        return t.type;
                                    case s:
                                        return "Input"
                                }
                                if ("nodeName" in t) switch (t.nodeName) {
                                    case "IMG":
                                    case "CANVAS":
                                        return "HTMLImage";
                                    case "VIDEO":
                                        return "HTMLVideo"
                                } else {
                                    if (t.hasOwnProperty("type")) return t.type;
                                    if ("undefined" != typeof OffscreenCanvas && t instanceof OffscreenCanvas) return "OffscreenCanvas";
                                    if ("undefined" != typeof ImageBitmap && t instanceof ImageBitmap) return "ImageBitmap";
                                    if ("undefined" != typeof ImageData && t instanceof ImageData) return "ImageData"
                                }
                                return "Unknown"
                            },
                            getKernelTextureSize(t, e) {
                                let [n, i, s] = e, r = (n || 1) * (i || 1) * (s || 1);
                                return t.optimizeFloatMemory && "single" === t.precision && (n = r = Math.ceil(r / 4)), i > 1 && n * i === r ? new Int32Array([n, i]) : h.closestSquareDimensions(r)
                            },
                            closestSquareDimensions(t) {
                                const e = Math.sqrt(t);
                                let n = Math.ceil(e),
                                    i = Math.floor(e);
                                for (; n * i < t;) n--, i = Math.ceil(t / n);
                                return new Int32Array([i, Math.ceil(t / i)])
                            },
                            getMemoryOptimizedFloatTextureSize(t, e) {
                                const n = h.roundTo((t[0] || 1) * (t[1] || 1) * (t[2] || 1) * (t[3] || 1), 4) / e;
                                return h.closestSquareDimensions(n)
                            },
                            getMemoryOptimizedPackedTextureSize(t, e) {
                                const [n, i, s] = t, r = h.roundTo((n || 1) * (i || 1) * (s || 1), 4) / (4 / e);
                                return h.closestSquareDimensions(r)
                            },
                            roundTo: (t, e) => Math.floor((t + e - 1) / e) * e,
                            getDimensions(t, e) {
                                let n;
                                if (h.isArray(t)) {
                                    const e = [];
                                    let i = t;
                                    for (; h.isArray(i);) e.push(i.length), i = i[0];
                                    n = e.reverse()
                                } else if (t instanceof r) n = t.output;
                                else {
                                    if (!(t instanceof s)) throw new Error(`Unknown dimensions of ${t}`);
                                    n = t.size
                                }
                                if (e)
                                    for (n = Array.from(n); n.length < 3;) n.push(1);
                                return new Int32Array(n)
                            },
                            flatten2dArrayTo(t, e) {
                                let n = 0;
                                for (let i = 0; i < t.length; i++) e.set(t[i], n), n += t[i].length
                            },
                            flatten3dArrayTo(t, e) {
                                let n = 0;
                                for (let i = 0; i < t.length; i++)
                                    for (let s = 0; s < t[i].length; s++) e.set(t[i][s], n), n += t[i][s].length
                            },
                            flatten4dArrayTo(t, e) {
                                let n = 0;
                                for (let i = 0; i < t.length; i++)
                                    for (let s = 0; s < t[i].length; s++)
                                        for (let r = 0; r < t[i][s].length; r++) e.set(t[i][s][r], n), n += t[i][s][r].length
                            },
                            flattenTo(t, e) {
                                h.isArray(t[0]) ? h.isArray(t[0][0]) ? h.isArray(t[0][0][0]) ? h.flatten4dArrayTo(t, e) : h.flatten3dArrayTo(t, e) : h.flatten2dArrayTo(t, e) : e.set(t)
                            },
                            splitArray(t, e) {
                                const n = [];
                                for (let i = 0; i < t.length; i += e) n.push(new t.constructor(t.buffer, 4 * i + t.byteOffset, e));
                                return n
                            },
                            getAstString(t, e) {
                                const n = Array.isArray(t) ? t : t.split(/\r?\n/g),
                                    i = e.loc.start,
                                    s = e.loc.end,
                                    r = [];
                                if (i.line === s.line) r.push(n[i.line - 1].substring(i.column, s.column));
                                else {
                                    r.push(n[i.line - 1].slice(i.column));
                                    for (let t = i.line; t < s.line; t++) r.push(n[t]);
                                    r.push(n[s.line - 1].slice(0, s.column))
                                }
                                return r.join("\n")
                            },
                            allPropertiesOf(t) {
                                const e = [];
                                do {
                                    e.push.apply(e, Object.getOwnPropertyNames(t))
                                } while (t = Object.getPrototypeOf(t));
                                return e
                            },
                            linesToString: t => t.length > 0 ? t.join(";\n") + ";\n" : "\n",
                            warnDeprecated(t, e, n) {
                                n ? console.warn(`You are using a deprecated ${t} "${e}". It has been replaced with "${n}". Fixing, but please upgrade as it will soon be removed.`) : console.warn(`You are using a deprecated ${t} "${e}". It has been removed. Fixing, but please upgrade as it will soon be removed.`)
                            },
                            flipPixels: (t, e, n) => {
                                const i = n / 2 | 0,
                                    s = 4 * e,
                                    r = new Uint8ClampedArray(4 * e),
                                    a = t.slice(0);
                                for (let t = 0; t < i; ++t) {
                                    const e = t * s,
                                        i = (n - t - 1) * s;
                                    r.set(a.subarray(e, e + s)), a.copyWithin(e, i, i + s), a.set(r, i)
                                }
                                return a
                            },
                            erectPackedFloat: (t, e) => t.subarray(0, e),
                            erect2DPackedFloat: (t, e, n) => {
                                const i = new Array(n);
                                for (let s = 0; s < n; s++) {
                                    const n = s * e,
                                        r = n + e;
                                    i[s] = t.subarray(n, r)
                                }
                                return i
                            },
                            erect3DPackedFloat: (t, e, n, i) => {
                                const s = new Array(i);
                                for (let r = 0; r < i; r++) {
                                    const i = new Array(n);
                                    for (let s = 0; s < n; s++) {
                                        const a = r * n * e + s * e,
                                            o = a + e;
                                        i[s] = t.subarray(a, o)
                                    }
                                    s[r] = i
                                }
                                return s
                            },
                            erectMemoryOptimizedFloat: (t, e) => t.subarray(0, e),
                            erectMemoryOptimized2DFloat: (t, e, n) => {
                                const i = new Array(n);
                                for (let s = 0; s < n; s++) {
                                    const n = s * e;
                                    i[s] = t.subarray(n, n + e)
                                }
                                return i
                            },
                            erectMemoryOptimized3DFloat: (t, e, n, i) => {
                                const s = new Array(i);
                                for (let r = 0; r < i; r++) {
                                    const i = new Array(n);
                                    for (let s = 0; s < n; s++) {
                                        const a = r * n * e + s * e;
                                        i[s] = t.subarray(a, a + e)
                                    }
                                    s[r] = i
                                }
                                return s
                            },
                            erectFloat: (t, e) => {
                                const n = new Float32Array(e);
                                let i = 0;
                                for (let s = 0; s < e; s++) n[s] = t[i], i += 4;
                                return n
                            },
                            erect2DFloat: (t, e, n) => {
                                const i = new Array(n);
                                let s = 0;
                                for (let r = 0; r < n; r++) {
                                    const n = new Float32Array(e);
                                    for (let i = 0; i < e; i++) n[i] = t[s], s += 4;
                                    i[r] = n
                                }
                                return i
                            },
                            erect3DFloat: (t, e, n, i) => {
                                const s = new Array(i);
                                let r = 0;
                                for (let a = 0; a < i; a++) {
                                    const i = new Array(n);
                                    for (let s = 0; s < n; s++) {
                                        const n = new Float32Array(e);
                                        for (let i = 0; i < e; i++) n[i] = t[r], r += 4;
                                        i[s] = n
                                    }
                                    s[a] = i
                                }
                                return s
                            },
                            erectArray2: (t, e) => {
                                const n = new Array(e),
                                    i = 4 * e;
                                let s = 0;
                                for (let e = 0; e < i; e += 4) n[s++] = t.subarray(e, e + 2);
                                return n
                            },
                            erect2DArray2: (t, e, n) => {
                                const i = new Array(n),
                                    s = 4 * e;
                                for (let r = 0; r < n; r++) {
                                    const n = new Array(e),
                                        a = r * s;
                                    let o = 0;
                                    for (let e = 0; e < s; e += 4) n[o++] = t.subarray(e + a, e + a + 2);
                                    i[r] = n
                                }
                                return i
                            },
                            erect3DArray2: (t, e, n, i) => {
                                const s = 4 * e,
                                    r = new Array(i);
                                for (let a = 0; a < i; a++) {
                                    const i = new Array(n);
                                    for (let r = 0; r < n; r++) {
                                        const o = new Array(e),
                                            u = a * s * n + r * s;
                                        let h = 0;
                                        for (let e = 0; e < s; e += 4) o[h++] = t.subarray(e + u, e + u + 2);
                                        i[r] = o
                                    }
                                    r[a] = i
                                }
                                return r
                            },
                            erectArray3: (t, e) => {
                                const n = new Array(e),
                                    i = 4 * e;
                                let s = 0;
                                for (let e = 0; e < i; e += 4) n[s++] = t.subarray(e, e + 3);
                                return n
                            },
                            erect2DArray3: (t, e, n) => {
                                const i = 4 * e,
                                    s = new Array(n);
                                for (let r = 0; r < n; r++) {
                                    const n = new Array(e),
                                        a = r * i;
                                    let o = 0;
                                    for (let e = 0; e < i; e += 4) n[o++] = t.subarray(e + a, e + a + 3);
                                    s[r] = n
                                }
                                return s
                            },
                            erect3DArray3: (t, e, n, i) => {
                                const s = 4 * e,
                                    r = new Array(i);
                                for (let a = 0; a < i; a++) {
                                    const i = new Array(n);
                                    for (let r = 0; r < n; r++) {
                                        const o = new Array(e),
                                            u = a * s * n + r * s;
                                        let h = 0;
                                        for (let e = 0; e < s; e += 4) o[h++] = t.subarray(e + u, e + u + 3);
                                        i[r] = o
                                    }
                                    r[a] = i
                                }
                                return r
                            },
                            erectArray4: (t, e) => {
                                const n = new Array(t),
                                    i = 4 * e;
                                let s = 0;
                                for (let e = 0; e < i; e += 4) n[s++] = t.subarray(e, e + 4);
                                return n
                            },
                            erect2DArray4: (t, e, n) => {
                                const i = 4 * e,
                                    s = new Array(n);
                                for (let r = 0; r < n; r++) {
                                    const n = new Array(e),
                                        a = r * i;
                                    let o = 0;
                                    for (let e = 0; e < i; e += 4) n[o++] = t.subarray(e + a, e + a + 4);
                                    s[r] = n
                                }
                                return s
                            },
                            erect3DArray4: (t, e, n, i) => {
                                const s = 4 * e,
                                    r = new Array(i);
                                for (let a = 0; a < i; a++) {
                                    const i = new Array(n);
                                    for (let r = 0; r < n; r++) {
                                        const o = new Array(e),
                                            u = a * s * n + r * s;
                                        let h = 0;
                                        for (let e = 0; e < s; e += 4) o[h++] = t.subarray(e + u, e + u + 4);
                                        i[r] = o
                                    }
                                    r[a] = i
                                }
                                return r
                            },
                            flattenFunctionToString: (t, e) => {
                                const {
                                    findDependency: n,
                                    thisLookup: s,
                                    doNotDefine: r
                                } = e;
                                let a = e.flattened;
                                a || (a = e.flattened = {});
                                const o = i.parse(t),
                                    u = [];
                                let l = 0;
                                const c = function t(e) {
                                    if (Array.isArray(e)) {
                                        const n = [];
                                        for (let i = 0; i < e.length; i++) n.push(t(e[i]));
                                        return n.join("")
                                    }
                                    switch (e.type) {
                                        case "Program":
                                            return t(e.body) + ("VariableDeclaration" === e.body[0].type ? ";" : "");
                                        case "FunctionDeclaration":
                                            return `function ${e.id.name}(${e.params.map(t).join(", ")}) ${t(e.body)}`;
                                        case "BlockStatement": {
                                            const n = [];
                                            l += 2;
                                            for (let i = 0; i < e.body.length; i++) {
                                                const s = t(e.body[i]);
                                                s && n.push(" ".repeat(l) + s, ";\n")
                                            }
                                            return l -= 2, `{\n${n.join("")}}`
                                        }
                                        case "VariableDeclaration":
                                            const i = h.normalizeDeclarations(e).map(t).filter((t => null !== t));
                                            return i.length < 1 ? "" : `${e.kind} ${i.join(",")}`;
                                        case "VariableDeclarator":
                                            return e.init.object && "ThisExpression" === e.init.object.type ? s(e.init.property.name, !0) ? `${e.id.name} = ${t(e.init)}` : null : `${e.id.name} = ${t(e.init)}`;
                                        case "CallExpression":
                                            if ("subarray" === e.callee.property.name) return `${t(e.callee.object)}.${t(e.callee.property)}(${e.arguments.map((e=>t(e))).join(", ")})`;
                                            if ("gl" === e.callee.object.name || "context" === e.callee.object.name) return `${t(e.callee.object)}.${t(e.callee.property)}(${e.arguments.map((e=>t(e))).join(", ")})`;
                                            if ("ThisExpression" === e.callee.object.type) return u.push(n("this", e.callee.property.name)), `${e.callee.property.name}(${e.arguments.map((e=>t(e))).join(", ")})`;
                                            if (e.callee.object.name) {
                                                const i = n(e.callee.object.name, e.callee.property.name);
                                                return null === i ? `${e.callee.object.name}.${e.callee.property.name}(${e.arguments.map((e=>t(e))).join(", ")})` : (u.push(i), `${e.callee.property.name}(${e.arguments.map((e=>t(e))).join(", ")})`)
                                            }
                                            if ("MemberExpression" === e.callee.object.type) return `${t(e.callee.object)}.${e.callee.property.name}(${e.arguments.map((e=>t(e))).join(", ")})`;
                                            throw new Error("unknown ast.callee");
                                        case "ReturnStatement":
                                            return `return ${t(e.argument)}`;
                                        case "BinaryExpression":
                                            return `(${t(e.left)}${e.operator}${t(e.right)})`;
                                        case "UnaryExpression":
                                            return e.prefix ? `${e.operator} ${t(e.argument)}` : `${t(e.argument)} ${e.operator}`;
                                        case "ExpressionStatement":
                                            return `${t(e.expression)}`;
                                        case "SequenceExpression":
                                            return `(${t(e.expressions)})`;
                                        case "ArrowFunctionExpression":
                                            return `(${e.params.map(t).join(", ")}) => ${t(e.body)}`;
                                        case "Literal":
                                            return e.raw;
                                        case "Identifier":
                                            return e.name;
                                        case "MemberExpression":
                                            return "ThisExpression" === e.object.type ? s(e.property.name) : e.computed ? `${t(e.object)}[${t(e.property)}]` : t(e.object) + "." + t(e.property);
                                        case "ThisExpression":
                                            return "this";
                                        case "NewExpression":
                                            return `new ${t(e.callee)}(${e.arguments.map((e=>t(e))).join(", ")})`;
                                        case "ForStatement":
                                            return `for (${t(e.init)};${t(e.test)};${t(e.update)}) ${t(e.body)}`;
                                        case "AssignmentExpression":
                                            return `${t(e.left)}${e.operator}${t(e.right)}`;
                                        case "UpdateExpression":
                                            return `${t(e.argument)}${e.operator}`;
                                        case "IfStatement":
                                            return `if (${t(e.test)}) ${t(e.consequent)}`;
                                        case "ThrowStatement":
                                            return `throw ${t(e.argument)}`;
                                        case "ObjectPattern":
                                            return e.properties.map(t).join(", ");
                                        case "ArrayPattern":
                                            return e.elements.map(t).join(", ");
                                        case "DebuggerStatement":
                                            return "debugger;";
                                        case "ConditionalExpression":
                                            return `${t(e.test)}?${t(e.consequent)}:${t(e.alternate)}`;
                                        case "Property":
                                            if ("init" === e.kind) return t(e.key)
                                    }
                                    throw new Error(`unhandled ast.type of ${e.type}`)
                                }(o);
                                if (u.length > 0) {
                                    const t = [];
                                    for (let n = 0; n < u.length; n++) {
                                        const i = u[n];
                                        a[i] || (a[i] = !0), i && t.push(h.flattenFunctionToString(i, e) + "\n")
                                    }
                                    return t.join("") + c
                                }
                                return c
                            },
                            normalizeDeclarations: t => {
                                if ("VariableDeclaration" !== t.type) throw new Error('Ast is not of type "VariableDeclaration"');
                                const e = [];
                                for (let n = 0; n < t.declarations.length; n++) {
                                    const i = t.declarations[n];
                                    if (i.id && "ObjectPattern" === i.id.type && i.id.properties) {
                                        const {
                                            properties: t
                                        } = i.id;
                                        for (let n = 0; n < t.length; n++) {
                                            const s = t[n];
                                            if ("ObjectPattern" === s.value.type && s.value.properties)
                                                for (let t = 0; t < s.value.properties.length; t++) {
                                                    const n = s.value.properties[t];
                                                    if ("Property" !== n.type) throw new Error("unexpected state");
                                                    e.push({
                                                        type: "VariableDeclarator",
                                                        id: {
                                                            type: "Identifier",
                                                            name: n.key.name
                                                        },
                                                        init: {
                                                            type: "MemberExpression",
                                                            object: {
                                                                type: "MemberExpression",
                                                                object: i.init,
                                                                property: {
                                                                    type: "Identifier",
                                                                    name: s.key.name
                                                                },
                                                                computed: !1
                                                            },
                                                            property: {
                                                                type: "Identifier",
                                                                name: n.key.name
                                                            },
                                                            computed: !1
                                                        }
                                                    })
                                                } else {
                                                    if ("Identifier" !== s.value.type) throw new Error("unexpected state");
                                                    e.push({
                                                        type: "VariableDeclarator",
                                                        id: {
                                                            type: "Identifier",
                                                            name: s.value && s.value.name ? s.value.name : s.key.name
                                                        },
                                                        init: {
                                                            type: "MemberExpression",
                                                            object: i.init,
                                                            property: {
                                                                type: "Identifier",
                                                                name: s.key.name
                                                            },
                                                            computed: !1
                                                        }
                                                    })
                                                }
                                        }
                                    } else if (i.id && "ArrayPattern" === i.id.type && i.id.elements) {
                                        const {
                                            elements: t
                                        } = i.id;
                                        for (let n = 0; n < t.length; n++) {
                                            const s = t[n];
                                            if ("Identifier" !== s.type) throw new Error("unexpected state");
                                            e.push({
                                                type: "VariableDeclarator",
                                                id: {
                                                    type: "Identifier",
                                                    name: s.name
                                                },
                                                init: {
                                                    type: "MemberExpression",
                                                    object: i.init,
                                                    property: {
                                                        type: "Literal",
                                                        value: n,
                                                        raw: n.toString(),
                                                        start: s.start,
                                                        end: s.end
                                                    },
                                                    computed: !0
                                                }
                                            })
                                        }
                                    } else e.push(i)
                                }
                                return e
                            },
                            splitHTMLImageToRGB: (t, e) => {
                                const n = t.createKernel((function(t) {
                                        return 255 * t[this.thread.y][this.thread.x].r
                                    }), {
                                        output: [e.width, e.height],
                                        precision: "unsigned",
                                        argumentTypes: {
                                            a: "HTMLImage"
                                        }
                                    }),
                                    i = t.createKernel((function(t) {
                                        return 255 * t[this.thread.y][this.thread.x].g
                                    }), {
                                        output: [e.width, e.height],
                                        precision: "unsigned",
                                        argumentTypes: {
                                            a: "HTMLImage"
                                        }
                                    }),
                                    s = t.createKernel((function(t) {
                                        return 255 * t[this.thread.y][this.thread.x].b
                                    }), {
                                        output: [e.width, e.height],
                                        precision: "unsigned",
                                        argumentTypes: {
                                            a: "HTMLImage"
                                        }
                                    }),
                                    r = t.createKernel((function(t) {
                                        return 255 * t[this.thread.y][this.thread.x].a
                                    }), {
                                        output: [e.width, e.height],
                                        precision: "unsigned",
                                        argumentTypes: {
                                            a: "HTMLImage"
                                        }
                                    }),
                                    a = [n(e), i(e), s(e), r(e)];
                                return a.rKernel = n, a.gKernel = i, a.bKernel = s, a.aKernel = r, a.gpu = t, a
                            },
                            splitRGBAToCanvases: (t, e, n, i) => {
                                const s = t.createKernel((function(t) {
                                    const e = t[this.thread.y][this.thread.x];
                                    this.color(e.r / 255, 0, 0, 255)
                                }), {
                                    output: [n, i],
                                    graphical: !0,
                                    argumentTypes: {
                                        v: "Array2D(4)"
                                    }
                                });
                                s(e);
                                const r = t.createKernel((function(t) {
                                    const e = t[this.thread.y][this.thread.x];
                                    this.color(0, e.g / 255, 0, 255)
                                }), {
                                    output: [n, i],
                                    graphical: !0,
                                    argumentTypes: {
                                        v: "Array2D(4)"
                                    }
                                });
                                r(e);
                                const a = t.createKernel((function(t) {
                                    const e = t[this.thread.y][this.thread.x];
                                    this.color(0, 0, e.b / 255, 255)
                                }), {
                                    output: [n, i],
                                    graphical: !0,
                                    argumentTypes: {
                                        v: "Array2D(4)"
                                    }
                                });
                                a(e);
                                const o = t.createKernel((function(t) {
                                    const e = t[this.thread.y][this.thread.x];
                                    this.color(255, 255, 255, e.a / 255)
                                }), {
                                    output: [n, i],
                                    graphical: !0,
                                    argumentTypes: {
                                        v: "Array2D(4)"
                                    }
                                });
                                return o(e), [s.canvas, r.canvas, a.canvas, o.canvas]
                            },
                            getMinifySafeName: t => {
                                try {
                                    const e = i.parse(`const value = ${t.toString()}`),
                                        {
                                            init: n
                                        } = e.body[0].declarations[0];
                                    return n.body.name || n.body.body[0].argument.name
                                } catch (t) {
                                    throw new Error("Unrecognized function type.  Please use `() => yourFunctionVariableHere` or function() { return yourFunctionVariableHere; }")
                                }
                            },
                            sanitizeName: function(t) {
                                return l.test(t) && (t = t.replace(l, "S_S")), c.test(t) ? t = t.replace(c, "U_U") : p.test(t) && (t = t.replace(p, "u_u")), t
                            }
                        },
                        l = /\$/,
                        c = /__/,
                        p = /_/,
                        d = h.getSystemEndianness();
                    e.exports = {
                        utils: h
                    }
                }, {
                    "./input": 110,
                    "./texture": 113,
                    acorn: 1
                }]
            }, {}, [107])(107)
        },
        205: (t, e, n) => {
            var i, s;
            t.exports = (i = {
                BlockLocation: () => __WEBPACK_EXTERNAL_MODULE__minecraft_server_fb7572af__.BlockLocation,
                ChatEvent: () => __WEBPACK_EXTERNAL_MODULE__minecraft_server_fb7572af__.ChatEvent,
                EntityDamageCause: () => __WEBPACK_EXTERNAL_MODULE__minecraft_server_fb7572af__.EntityDamageCause,
                EntityHealthComponent: () => __WEBPACK_EXTERNAL_MODULE__minecraft_server_fb7572af__.EntityHealthComponent,
                EntityHurtEvent: () => __WEBPACK_EXTERNAL_MODULE__minecraft_server_fb7572af__.EntityHurtEvent,
                EntityInventoryComponent: () => __WEBPACK_EXTERNAL_MODULE__minecraft_server_fb7572af__.EntityInventoryComponent,
                EntityIsBabyComponent: () => __WEBPACK_EXTERNAL_MODULE__minecraft_server_fb7572af__.EntityIsBabyComponent,
                EntityIsChargedComponent: () => __WEBPACK_EXTERNAL_MODULE__minecraft_server_fb7572af__.EntityIsChargedComponent,
                EntityMarkVariantComponent: () => __WEBPACK_EXTERNAL_MODULE__minecraft_server_fb7572af__.EntityMarkVariantComponent,
                EntitySpawnEvent: () => __WEBPACK_EXTERNAL_MODULE__minecraft_server_fb7572af__.EntitySpawnEvent,
                EntityVariantComponent: () => __WEBPACK_EXTERNAL_MODULE__minecraft_server_fb7572af__.EntityVariantComponent,
                GameMode: () => __WEBPACK_EXTERNAL_MODULE__minecraft_server_fb7572af__.GameMode,
                ItemEnchantsComponent: () => __WEBPACK_EXTERNAL_MODULE__minecraft_server_fb7572af__.ItemEnchantsComponent,
                ItemStack: () => __WEBPACK_EXTERNAL_MODULE__minecraft_server_fb7572af__.ItemStack,
                Items: () => __WEBPACK_EXTERNAL_MODULE__minecraft_server_fb7572af__.Items,
                Location: () => __WEBPACK_EXTERNAL_MODULE__minecraft_server_fb7572af__.Location,
                MinecraftBlockTypes: () => __WEBPACK_EXTERNAL_MODULE__minecraft_server_fb7572af__.MinecraftBlockTypes,
                MinecraftDimensionTypes: () => __WEBPACK_EXTERNAL_MODULE__minecraft_server_fb7572af__.MinecraftDimensionTypes,
                MinecraftEffectTypes: () => __WEBPACK_EXTERNAL_MODULE__minecraft_server_fb7572af__.MinecraftEffectTypes,
                MinecraftEntityTypes: () => __WEBPACK_EXTERNAL_MODULE__minecraft_server_fb7572af__.MinecraftEntityTypes,
                MinecraftItemTypes: () => __WEBPACK_EXTERNAL_MODULE__minecraft_server_fb7572af__.MinecraftItemTypes,
                MolangVariableMap: () => __WEBPACK_EXTERNAL_MODULE__minecraft_server_fb7572af__.MolangVariableMap,
                Player: () => __WEBPACK_EXTERNAL_MODULE__minecraft_server_fb7572af__.Player,
                PlayerJoinEvent: () => __WEBPACK_EXTERNAL_MODULE__minecraft_server_fb7572af__.PlayerJoinEvent,
                PlayerLeaveEvent: () => __WEBPACK_EXTERNAL_MODULE__minecraft_server_fb7572af__.PlayerLeaveEvent,
                TickEvent: () => __WEBPACK_EXTERNAL_MODULE__minecraft_server_fb7572af__.TickEvent,
                Vector: () => __WEBPACK_EXTERNAL_MODULE__minecraft_server_fb7572af__.Vector,
                system: () => __WEBPACK_EXTERNAL_MODULE__minecraft_server_fb7572af__.system,
                world: () => __WEBPACK_EXTERNAL_MODULE__minecraft_server_fb7572af__.world
            }, s = {}, n.d(s, i), s)
        },
        985: (t, e, n) => {
            var i, s;
            t.exports = (i = {
                ActionFormData: () => __WEBPACK_EXTERNAL_MODULE__minecraft_server_ui_f6791859__.ActionFormData,
                MessageFormData: () => __WEBPACK_EXTERNAL_MODULE__minecraft_server_ui_f6791859__.MessageFormData,
                ModalFormData: () => __WEBPACK_EXTERNAL_MODULE__minecraft_server_ui_f6791859__.ModalFormData
            }, s = {}, n.d(s, i), s)
        }
    },
    __webpack_module_cache__ = {};

function __webpack_require__(t) {
    var e = __webpack_module_cache__[t];
    if (void 0 !== e) return e.exports;
    var n = __webpack_module_cache__[t] = {
        exports: {}
    };
    return __webpack_modules__[t].call(n.exports, n, n.exports, __webpack_require__), n.exports
}
__webpack_require__.n = t => {
    var e = t && t.__esModule ? () => t.default : () => t;
    return __webpack_require__.d(e, {
        a: e
    }), e
}, __webpack_require__.d = (t, e) => {
    for (var n in e) __webpack_require__.o(e, n) && !__webpack_require__.o(t, n) && Object.defineProperty(t, n, {
        enumerable: !0,
        get: e[n]
    })
}, __webpack_require__.g = function() {
    if ("object" == typeof globalThis) return globalThis;
    try {
        return this || new Function("return this")()
    } catch (t) {
        if ("object" == typeof window) return window
    }
}(), __webpack_require__.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e);
var __webpack_exports__ = {};
(() => {
    var t = __webpack_require__(205),
        e = __webpack_require__(721),
        n = __webpack_require__(724),
        i = __webpack_require__(215),
        s = __webpack_require__(801);
    class r {
        constructor(e) {
            if (this.exEvents = {
                    onLongTick: {
                        subscribe: t => {
                            this._subscribe("onLongTick", t)
                        },
                        unsubscribe: t => {
                            this._unsubscribe("onLongTick", t)
                        },
                        pattern: () => {
                            this.events.tick.subscribe((t => {
                                var e;
                                if (this.tickTime += t.deltaTime, t.currentTick % 5 == 0) {
                                    this.tickNum++;
                                    let t = {
                                        currentTick: this.tickNum,
                                        deltaTime: this.tickTime
                                    };
                                    null === (e = r.monitorMap.get("onLongTick")) || void 0 === e || e.forEach((e => {
                                        e(t)
                                    })), this.tickTime = 0
                                }
                            }))
                        }
                    }
                }, this.tickNum = 0, this.tickTime = 0, this.init = !1, this._server = e, this.events = t.world.events, !this.init) {
                this.init = !0;
                for (let t in this.exEvents) this.exEvents[t].pattern()
            }
        }
        _subscribe(t, e) {
            let n = r.monitorMap.get(t);
            void 0 === n && (n = [], r.monitorMap.set(t, n)), n.push(e)
        }
        _unsubscribe(t, e) {
            var n;
            let i = null !== (n = r.monitorMap.get(t)) && void 0 !== n ? n : [];
            i.splice(i.findIndex(((t, n) => {
                if (t === e) return !0
            })), 1)
        }
        cancelAll() {
            throw new Error("Method not implemented.")
        }
        register(t, e) {
            let n = e;
            return t in this.events ? this.events[t].subscribe(n) : t in this.exEvents ? this.exEvents[t].subscribe(n) : void console.warn("No event registered for name " + t)
        }
        cancel(t, e) {
            return t in this.events ? this.events[t].unsubscribe(e) : t in this.exEvents ? this.exEvents[t].unsubscribe(e) : void 0
        }
    }
    r.monitorMap = new Map;
    var a = __webpack_require__(242),
        o = __webpack_require__(361),
        u = __webpack_require__(484);
    class h {
        static push(t) {
            return this.queue.push(t), this
        }
        static init(t) {
            this.delay = new u.Z(t.getEvents(), (() => {
                var t;
                this.queue.length > 0 && (null === (t = this.queue.shift()) || void 0 === t || t())
            })).delay(60), this.delay.start()
        }
    }
    h.queue = [];
    var l, c = __webpack_require__(960),
        p = __webpack_require__(654),
        d = __webpack_require__(782),
        m = __webpack_require__(710),
        g = __webpack_require__(513);
    class f {
        constructor(t) {
            this.exEvents = {
                itemUse: new y(this, "itemUse"),
                tick: new y(this, "tick"),
                entityHit: new y(this, "entityHit"),
                onHitEntity: new y(this, "onHitEntity"),
                onHurt: new y(this, "onHurt"),
                itemOnHandChange: new y(this, "itemOnHandChange"),
                onLongTick: new y(this, "onLongTick"),
                blockBreak: new y(this, "blockBreak")
            }, this._ctrl = t, console.warn("regist events")
        }
        _subscribe(t, e) {
            f.eventHandlers.subscribe(this._ctrl.entity, t, e)
        }
        _unsubscribe(t, e) {
            f.eventHandlers.unsubscribe(this._ctrl.entity, t, e)
        }
        cancelAll() {
            console.warn("destroy all events"), f.eventHandlers.unsubscribeAll(this._ctrl.entity)
        }
        static init(t) {
            this.eventHandlers.setEventLiseners(this.exEventSetting), this.eventHandlers.init(t)
        }
        register(t, e) {
            let n = e;
            if (t in this.exEvents) return this.exEvents[t].subscribe(n);
            console.warn("No event registered for name " + t)
        }
        cancel(t, e) {
            if (t in this.exEvents) return this.exEvents[t].unsubscribe(e)
        }
    }
    l = f, f.eventHandlers = new m.Z, f.exEventSetting = {
        itemUse: {
            pattern: f.eventHandlers.registerToServerByEntity,
            filter: {
                name: "source"
            }
        },
        tick: {
            pattern: f.eventHandlers.registerToServerByServerEvent
        },
        entityHit: {
            pattern: f.eventHandlers.registerToServerByEntity,
            filter: {
                name: "entity"
            }
        },
        onHitEntity: {
            pattern: f.eventHandlers.registerToServerByEntity,
            filter: {
                name: "damageSource.damagingEntity"
            },
            name: "entityHurt"
        },
        onHurt: {
            pattern: f.eventHandlers.registerToServerByEntity,
            filter: {
                name: "hurtEntity"
            },
            name: "entityHurt"
        },
        itemOnHandChange: {
            pattern: (t, e) => {
                l.onHandItemMap = new Map, f.eventHandlers.server.getEvents().register(t, (t => {
                    for (let t of f.eventHandlers.monitorMap[e]) {
                        let e = l.onHandItemMap.get(t[0]),
                            n = null == e ? void 0 : e[0],
                            i = d.Z.getInstance(t[0]).getBag().getItemOnHand();
                        (null == n ? void 0 : n.typeId) === (null == i ? void 0 : i.typeId) && t[0].selectedSlot === (null == e ? void 0 : e[1]) || (t[1].forEach((e => {
                            e(new g.a(n, d.Z.getInstance(t[0]).getBag().getItemOnHand(), t[0]))
                        })), l.onHandItemMap.set(t[0], [i, t[0].selectedSlot]))
                    }
                }))
            },
            name: "onLongTick"
        },
        onLongTick: {
            pattern: f.eventHandlers.registerToServerByServerEvent
        },
        blockBreak: {
            pattern: f.eventHandlers.registerToServerByEntity,
            filter: {
                name: "player"
            }
        }
    }, f.onHandItemMap = new Map, f.onceItemUseOnMap = new Map;
    class y {
        constructor(t, e) {
            this.subscribe = n => {
                t._subscribe(e, n)
            }, this.unsubscribe = n => {
                t._unsubscribe(e, n)
            }
        }
    }
    __webpack_require__(855);
    var x = __webpack_require__(478),
        _ = __webpack_require__(632),
        b = function(t, e, n, i) {
            var s, r = arguments.length,
                a = r < 3 ? e : null === i ? i = Object.getOwnPropertyDescriptor(e, n) : i;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(t, e, n, i);
            else
                for (var o = t.length - 1; o >= 0; o--)(s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, n, a) : s(e, n)) || a);
            return r > 3 && a && Object.defineProperty(e, n, a), a
        },
        w = function(t, e) {
            if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(t, e)
        };
    class T {
        constructor(e) {
            this.entityControllers = new Map, this.clients = new Map, this.clients_nameMap = new Map, this._events = new r(this), T.isInitialized || (T.isInitialized = !0, s.Z.config = e, e.watchDog || t.system.events.beforeWatchdogTerminate.subscribe((t => {
                t.cancel = !0
            })), s.Z.console = function(t) {
                const e = "c",
                    n = "5",
                    i = (t = "f", e = "") => Array.isArray(e) ? (e[0] = t + e[0], e[e.length - 1] += "r", e) : t + e + "r",
                    s = e => t.runCommandAsync(`tellraw @a[tag=debugger] {"rawtext": [{"text": "${e}"}]}`),
                    r = t => {
                        let e = "{\n";
                        for (const s in Object.keys(t)) {
                            const r = t[s];
                            null === r && (e += `${s}: null\n`), e += "object" != typeof r ? `${s}: ${"number"==typeof r?i(n,r):r}\n` : `${s}: {...}\n`
                        }
                        return e + "}"
                    },
                    a = (() => {
                        const t = (t, e) => t.replace("%s", e && "string" == typeof e ? e : e.toString()),
                            e = (t, e) => t.replace("%d", i("b", e && "number" == typeof e ? Math.floor(e) : "string" == typeof e ? Math.floor(parseInt(e)) : NaN)),
                            a = (t, e) => t.replace("%f", i(n, "number" == typeof e ? e : "string" == typeof e ? Math.floor(parseFloat(e)) : NaN)),
                            o = (t, e) => t.replace("%o", r(e));
                        return (n, ...i) => {
                            for (let s = 0; s < i.length; s++) {
                                let r = /(%[s|d|f|o])/.exec(n)[1];
                                "%s" === r && (n = t(n, i[s])) || "%d" === r && (n = e(n, i[s])) || "%f" === r && (n = a(n, i[s])) || "%o" !== r || (n = o(n, i[s]))
                            }
                            return s(n)
                        }
                    })();

                function o(...t) {
                    let e = new Array(h).fill("    ").join("");
                    return /%[s|d|f|o]/.test(t[0]) ? a(e + t.shift(), ...t) : (t = t.map((t => "number" == typeof t ? i(n, t) : "object" == typeof t ? r(t) : t)).join("\n"), s(e + t))
                }
                let u = 0,
                    h = 0,
                    l = {},
                    c = [];
                return new class {
                    constructor() {
                        this.log = o, this.info = o
                    }
                    countReset(t) {}
                    debug(...t) {}
                    dir(t, e) {}
                    dirxml(...t) {}
                    groupCollapsed(...t) {}
                    table(t, e) {}
                    timeLog(t, ...e) {}
                    timeStamp(t) {}
                    assert(t, n) {
                        return !t && o(i(e, n))
                    }
                    clear() {
                        o("\n\n\n\n\n\n\n\n\n\n")
                    }
                    error(...t) {
                        return c.length > 0 && o(i(e, c.join(" > ") + "\n")), o(...i(e, t))
                    }
                    warn(...t) {
                        return o(...i("e", t))
                    }
                    count(t) {
                        return o(t + ": " + u++)
                    }
                    group(t = `${h}`) {
                        let e = o(` ${t}`);
                        return h++, e
                    }
                    groupEnd() {
                        h > 0 && h--
                    }
                    time(t = "default") {
                        l[t] = (new Date).getTime()
                    }
                    timeEnd(t = "default") {
                        if (l[t]) {
                            let e = ((new Date).getTime() - l[t]) / 1e3;
                            l[t] = null, o(`${t}: ${e} s`)
                        }
                    }
                    trace() {
                        o(c.join("\n\n"))
                    }
                    setTracePoint(t) {
                        let e = this.name || "anonymous";
                        t && (e += ` at line: ${t}`), c.push(e)
                    }
                }
            }(s.Z), o.Z.init(this), h.init(this), c.Z.init(this), p.Z.init(this), f.init(this)), (0, x.B)(this.getEvents(), this)
        }
        say(e) {
            t.world.say(e)
        }
        addEntityController(t, e) {
            this.entityControllers.set(t, e)
        }
        onEntitySpawn(t) {
            const e = this.entityControllers.get(t.entity.typeId);
            e && new e(t.entity, this)
        }
        getDimension(e) {
            return t.world.getDimension(e)
        }
        getExDimension(t) {
            return n.Z.getInstance(this.getDimension(t))
        }
        getEvents() {
            return this._events
        }
        getClients() {
            return this.clients.values()
        }
        getPlayers() {
            let t = [];
            for (let e of this.clients) t.push(e[1].player);
            return t
        }
        findClientByName(t) {
            return this.clients_nameMap.get(t)
        }
        findClientByPlayer(t) {
            for (let e of this.clients)
                if (e[1].player == t) return e[1]
        }
        onClientJoin(e) {
            const n = e.playerName;
            (0, _.Z)(this, (() => -1 !== t.world.getAllPlayers().findIndex((t => t.name === n))), (() => {
                let e = t.world.getAllPlayers().find((t => t.name === n));
                if (!e) throw new Error(`Player ${n} not found`);
                let i = a.Z.randomUUID(),
                    s = this.newClient(i, e);
                this.clients.set(i, s), this.clients_nameMap.set(e.name, s)
            }))
        }
        onClientLeave(t) {
            let e = this.findClientByName(t.playerName);
            void 0 !== e ? (e.onLeave(), this.clients.delete(e.clientId), this.clients_nameMap.delete(t.playerName)) : s.Z.console.error(t.playerName + "client is not exists")
        }
        newClient(t, e) {
            return new i.Z(this, t, e)
        }
        setTimeout(t, e) {
            let n = 0,
                i = s => {
                    n += 1e3 * s.deltaTime, n > e && (this.getEvents().events.tick.unsubscribe(i), t())
                };
            this.getEvents().events.tick.subscribe(i)
        }
    }
    b([(0, x.K)("entitySpawn"), w("design:type", Function), w("design:paramtypes", [t.EntitySpawnEvent]), w("design:returntype", void 0)], T.prototype, "onEntitySpawn", null), b([(0, x.K)("playerJoin"), w("design:type", Function), w("design:paramtypes", [t.PlayerJoinEvent]), w("design:returntype", void 0)], T.prototype, "onClientJoin", null), b([(0, x.K)("playerLeave"), w("design:type", Function), w("design:paramtypes", [t.PlayerLeaveEvent]), w("design:returntype", void 0)], T.prototype, "onClientLeave", null);
    var v = __webpack_require__(475);
    class E {
        constructor(t, n, i) {
            if (this._width = new e.Z, this._tmpA = new e.Z, this._tmpC = new e.Z, this._judgeWidth = new e.Z, this._tmpD = new e.Z, this.start = t.clone(), this.end = n.clone(), i) this.start.x > this.end.x && ([this.start.x, this.end.x] = [this.end.x, this.start.x]), this.start.y > this.end.y && ([this.start.y, this.end.y] = [this.end.y, this.start.y]), this.start.z > this.end.z && ([this.start.z, this.end.z] = [this.end.z, this.start.z]), this.end.add(1, 1, 1);
            else {
                if (this.end.x < 0 || this.end.y < 0 || this.end.z < 0) throw new Error("Invalid value (x,y,z < 0)");
                this.end.add(this.start)
            }
            this.resetRotation()
        }
        center() {
            return this.end.clone().sub(this.start).scl(.5).add(this.start)
        }
        contains(t) {
            return this.start.x <= t.x && this.start.z <= t.z && t.x <= this.end.x && t.z <= this.end.z && this.start.y <= t.y && t.y <= this.end.y
        }
        resetRotation() {
            this.setMatrix4(new v.Z([
                [1, 0, 0, 0],
                [0, 1, 0, 0],
                [0, 0, 1, 0],
                [0, 0, 0, 1]
            ]))
        }
        turnUp() {
            this.setMatrix4(this.mat.mul(new v.Z([
                [1, 0, 0, 0],
                [0, 0, -1, 0],
                [0, 1, 0, 0],
                [0, 0, 0, 1]
            ])))
        }
        turnRight() {
            this.setMatrix4(this.mat = this.mat.mul(new v.Z([
                [0, 0, -1, 0],
                [0, 1, 0, 0],
                [1, 0, 0, 0],
                [0, 0, 0, 1]
            ])))
        }
        turnFrontClockwise() {
            this.setMatrix4(this.mat.mul(new v.Z([
                [0, -1, 0, 0],
                [1, 0, 0, 0],
                [0, 0, 1, 0],
                [0, 0, 0, 1]
            ])))
        }
        pointAtStart(t) {
            this.end.sub(this.start).add(t), this.start.set(t)
        }
        calculateWidth() {
            return this._width.set(this.end).sub(this.start).mul(this.mat).abs(), this._judgeWidth.set(1, 1, 1).mul(this.mat), this.getWidth()
        }
        getWidth() {
            return this._width
        }
        calculateAbsPos(t, e = this._tmpA) {
            return this.calculateRelPos(this._tmpC.sub(this.start), e).add(this.start)
        }
        calculateRelPos(t, e = this._tmpA) {
            e.set(t).mul(this.mat);
            const n = this.getWidth();
            return e.x = this._judgeWidth.x < 0 ? n.x + e.x - 1 : e.x, e.y = this._judgeWidth.y < 0 ? n.y + e.y - 1 : e.y, e.z = this._judgeWidth.z < 0 ? n.z + e.z - 1 : e.z, e
        }
        forEachArea(t, e) {
            const n = t.clone();
            n.pointAtStart(this._tmpD.set(0, 0, 0));
            const i = this.getWidth(),
                s = n.getWidth();
            for (let t = 0; t <= i.x - s.x; t++)
                for (let r = 0; r <= i.y - s.y; r++)
                    for (let a = 0; a <= i.z - s.z; a++) n.pointAtStart(this._tmpD.set(t, r, a).add(this.start)), e(n)
        }
        clone() {
            const t = new E(this.start.clone(), this.end.clone().sub(1, 1, 1), !0);
            return t.setMatrix4(this.mat.clone()), t
        }
        setMatrix4(t) {
            this.mat = t, this.calculateWidth()
        }
        static randomPoint(t, e = 0) {
            if (0 === t.length) throw new Error("empty array");
            let n = t[Math.floor(Math.random() * t.length)];
            if (E.tempV.set(n.start).add(e, e, e), E.tempP.set(n.end).sub(e, e, e), E.tempP.sub(this.tempV), E.tempP.x < 0 || E.tempP.y < 0 || E.tempP.z < 0) throw new Error("Bound is too large");
            return E.tempP.set(E.tempP.x * Math.random(), E.tempP.y * Math.random(), E.tempP.z * Math.random()), E.tempV.add(E.tempP).clone()
        }
    }
    E.tempV = new e.Z, E.tempP = new e.Z;
    class A {
        constructor() {
            this.direction = A.DIRECTION_AROUND | A.DIRECTION_LAY
        }
        clone() {
            let t = new A;
            return t.dimension = this.dimension, t.structure = this.structure, t.analysisMap = this.analysisMap, t.direction = this.direction, t.area = this.area, t
        }
        setDimension(t) {
            return this.dimension = n.Z.getInstance(t), this
        }
        find() {
            if (void 0 === this.dimension) throw new Error("dimension is undefined");
            if (void 0 === this.structure) throw new Error("structure is undefined");
            if (void 0 === this.analysisMap) throw new Error("analysisMap is undefined");
            if (void 0 === this.area) throw new Error("area is undefined");
            const t = new E(new e.Z, new e.Z(this.structure[0][0].length, this.structure[0].length, this.structure.length));
            let n, i = t.clone();
            if (this.direction >> 0 & 1)
                if (this.direction >> 6 & 1) {
                    if (i.turnFrontClockwise(), n = this.searchOnce(i)) return n;
                    if (i.turnFrontClockwise(), n = this.searchOnce(i)) return n;
                    if (i.turnFrontClockwise(), n = this.searchOnce(i)) return n;
                    if (i.turnFrontClockwise(), n = this.searchOnce(i)) return n
                } else if (n = this.searchOnce(i)) return n;
            if (i = t.clone(), i.turnRight(), i.turnRight(), this.direction >> 1 & 1)
                if (this.direction >> 6 & 1) {
                    if (i.turnFrontClockwise(), n = this.searchOnce(i)) return n;
                    if (i.turnFrontClockwise(), n = this.searchOnce(i)) return n;
                    if (i.turnFrontClockwise(), n = this.searchOnce(i)) return n;
                    if (i.turnFrontClockwise(), n = this.searchOnce(i)) return n
                } else if (n = this.searchOnce(i)) return n;
            if (i = t.clone(), i.turnRight(), this.direction >> 2 & 1)
                if (this.direction >> 6 & 1) {
                    if (i.turnFrontClockwise(), n = this.searchOnce(i)) return n;
                    if (i.turnFrontClockwise(), n = this.searchOnce(i)) return n;
                    if (i.turnFrontClockwise(), n = this.searchOnce(i)) return n;
                    if (i.turnFrontClockwise(), n = this.searchOnce(i)) return n
                } else if (n = this.searchOnce(i)) return n;
            if (i = t.clone(), i.turnRight(), i.turnRight(), i.turnRight(), this.direction >> 3 & 1)
                if (this.direction >> 6 & 1) {
                    if (i.turnFrontClockwise(), n = this.searchOnce(i)) return n;
                    if (i.turnFrontClockwise(), n = this.searchOnce(i)) return n;
                    if (i.turnFrontClockwise(), n = this.searchOnce(i)) return n;
                    if (i.turnFrontClockwise(), n = this.searchOnce(i)) return n
                } else if (n = this.searchOnce(i)) return n;
            if (i = t.clone(), i.turnUp(), this.direction >> 4 & 1) {
                if (i.turnFrontClockwise(), n = this.searchOnce(i)) return n;
                if (i.turnFrontClockwise(), n = this.searchOnce(i)) return n;
                if (i.turnFrontClockwise(), n = this.searchOnce(i)) return n;
                if (i.turnFrontClockwise(), n = this.searchOnce(i)) return n
            }
            if (i = t.clone(), i.turnUp(), i.turnUp(), i.turnUp(), this.direction >> 5 & 1) {
                if (i.turnFrontClockwise(), n = this.searchOnce(i)) return n;
                if (i.turnFrontClockwise(), n = this.searchOnce(i)) return n;
                if (i.turnFrontClockwise(), n = this.searchOnce(i)) return n;
                if (i.turnFrontClockwise(), n = this.searchOnce(i)) return n
            }
            return n
        }
        searchOnce(n) {
            var i, s;
            const r = null !== (i = this.structure) && void 0 !== i ? i : [
                    [""]
                ],
                a = new e.Z,
                o = new e.Z,
                u = this.dimension;
            let h;
            return null === (s = this.area) || void 0 === s || s.forEachArea(n, (e => {
                var n, i, s;
                for (o.z = 0; o.z < r.length; o.z++)
                    for (o.y = 0; o.y < r[o.z].length; o.y++) {
                        const h = r[o.z][o.y];
                        for (o.x = 0; o.x < h.length; o.x++) {
                            const r = h.charAt(o.x);
                            if (" " != r && (e.calculateRelPos(o, a).add(e.start), (null === (n = null == u ? void 0 : u.getBlock(a)) || void 0 === n ? void 0 : n.typeId) !== (null !== (s = null === (i = this.analysisMap) || void 0 === i ? void 0 : i.get(r)) && void 0 !== s ? s : t.MinecraftBlockTypes.air.id))) return
                        }
                    }
                h = e.clone()
            })), h
        }
        setStructure(t) {
            return this.structure = t, this.structure.forEach((t => {
                t.reverse()
            })), this
        }
        analysis(t) {
            if (t instanceof Map) this.analysisMap = t;
            else {
                const e = new Map;
                for (const n in t) e.set(n, t[n]);
                this.analysisMap = e
            }
            return this
        }
        putStructure(n) {
            if (void 0 === this.dimension) throw new Error("dimension is undefined");
            if (void 0 === this.analysisMap) throw new Error("analysisMap is undefined");
            if (void 0 === this.structure) throw new Error("structure is undefined");
            const i = new e.Z,
                s = new e.Z;
            for (s.z = 0; s.z < this.structure.length; s.z++)
                for (s.y = 0; s.y < this.structure[s.z].length; s.y++) {
                    const e = this.structure[s.z][s.y];
                    for (s.x = 0; s.x < e.length; s.x++) {
                        const r = e.charAt(s.x);
                        if (" " == r) continue;
                        n.calculateRelPos(s, i).add(n.start);
                        let a = this.analysisMap.get(r),
                            o = 0,
                            u = null == a ? void 0 : a.indexOf("|");
                        a && u && -1 !== u && (o = parseInt(null == a ? void 0 : a.slice(u + 1))), this.dimension.setBlock(i, null != a ? a : t.MinecraftBlockTypes.air.id, o)
                    }
                }
            return this
        }
        setArea(t) {
            return this.area = t, this
        }
        setDirection(t) {
            return this.direction = t, this
        }
    }
    A.DIRECTION_SOUTH = Math.pow(2, 0), A.DIRECTION_NORTH = Math.pow(2, 1), A.DIRECTION_EAST = Math.pow(2, 2), A.DIRECTION_WEST = Math.pow(2, 3), A.DIRECTION_UP = Math.pow(2, 4), A.DIRECTION_BUTTOM = Math.pow(2, 5), A.DIRECTION_ALLOW_ROTATE = Math.pow(2, 6), A.DIRECTION_AROUND = A.DIRECTION_WEST | A.DIRECTION_EAST | A.DIRECTION_SOUTH | A.DIRECTION_NORTH, A.DIRECTION_AROUND_MIRROR = A.DIRECTION_EAST | A.DIRECTION_NORTH, A.DIRECTION_LAY = A.DIRECTION_UP | A.DIRECTION_BUTTOM, A.DIRECTION_LAY_MIRROR = A.DIRECTION_UP;
    var I = __webpack_require__(703),
        S = __webpack_require__(418),
        k = __webpack_require__(409),
        D = __webpack_require__(647);
    class L {
        constructor(t, e) {
            this.time = 1e3, this.timeOut = t, this.looper = e
        }
        getDelay() {
            return this.time
        }
        delay(t) {
            return this.time = t, this
        }
        isStarted() {
            return void 0 !== this.func
        }
        startOnce() {
            let t = 0;
            this.isStarted() || (this.func = e => {
                t += 1e3 * e.deltaTime, t >= this.time && (this.stop(), this.looper())
            }, this.timeOut.register("tick", this.func))
        }
        start() {
            let t = 0;
            this.isStarted() || (this.func = e => {
                t += 1e3 * e.deltaTime, t >= this.time && (this.looper(), t = 0)
            }, this.timeOut.register("tick", this.func))
        }
        stop() {
            this.func && (this.timeOut.cancel("tick", this.func), this.func = void 0)
        }
    }
    var C = __webpack_require__(516);
    class M {
        static createServer(t, e) {
            let n = new t(e);
            this.serverMap.set(t, n)
        }
        static postMessageBetweenServer() {}
        static postMessageBetweenClient(t, e, n, i) {
            let s = this.serverMap.get(e);
            if (!s) return;
            let r = s.findClientByPlayer(t.player);
            if (r)
                for (let t of C.Z.keys(r)) Reflect.getMetadata("exportName", r, t) === n && Reflect.get(r, t).apply(r, i)
        }
    }

    function O(t) {
        return function(e, n, i) {
            Reflect.defineMetadata("exportName", t, e, n)
        }
    }
    M.serverMap = new Map;
    class R {
        static from(t, e) {
            let n;
            try {
                n = JSON.parse(t)
            } catch (t) {
                n = e
            }
            return n
        }
        static to(t) {
            return JSON.stringify(t)
        }
    }
    class N {
        constructor(t) {
            this.manager = t
        }
        load() {
            for (const t of this.manager.getTags())
                if (t.startsWith("__cache:")) return this.tagFrom = t, t.substring("__cache:".length)
        }
        get(t) {
            if (this.cache) return this.cache; {
                let e = this.load();
                return e ? (this.cache = R.from(e, t), this.cache) : (this.cache = t, this.tagFrom = "__cache:" + JSON.stringify(this.cache), this.manager.addTag(this.tagFrom), t)
            }
        }
        save() {
            let t = "__cache:" + R.to(this.cache);
            t !== this.tagFrom && (this.manager.removeTag(this.tagFrom), this.manager.addTag(t), this.tagFrom = t)
        }
    }
    var P = __webpack_require__(344);
    class $ {
        constructor(t) {
            this.entity = new P.Z(""), this.objective = t, t.create("cache:" + t.name), $.varMap.has(t.name) || $.varMap.set(t.name, new Map), this.useMap = $.varMap.get(t.name)
        }
        debug() {
            this.objective.setDisplay()
        }
        setBoolean(t, e) {
            this.setNumber(t, e ? 1 : 0)
        }
        getBoolean(t) {
            return 1 === this.getNumber(t)
        }
        setNumber(t, e) {
            this.entity.nameTag = t, this.entity.getScoresManager().setScoreAsync(this.objective, e), this.useMap.set(t, e)
        }
        getNumber(t) {
            return this.entity.nameTag = t, this.useMap.has(t) || this.useMap.set(t, this.entity.getScoresManager().getScore(this.objective)), this.useMap.get(t)
        }
        deleteNumber(t) {
            return this.entity.nameTag = t, this.useMap.delete(t), this.entity.getScoresManager().deleteScoreAsync(this.objective)
        }
    }
    $.varMap = new Map;
    class U extends $ {
        get playerCanTp() {
            return this.getBoolean("playerCanTp")
        }
        set playerCanTp(t) {
            this.setBoolean("playerCanTp", t)
        }
        get tpNeedItem() {
            return this.getBoolean("tpNeedItem")
        }
        set tpNeedItem(t) {
            this.setBoolean("tpNeedItem", t)
        }
        get entityCleaner() {
            return this.getBoolean("entityCleaner")
        }
        set entityCleaner(t) {
            this.setBoolean("entityCleaner", t)
        }
        get deathRecord() {
            return this.getBoolean("deathRecord")
        }
        set deathRecord(t) {
            this.setBoolean("deathRecord", t)
        }
        get tpPointRecord() {
            return this.getBoolean("tpPointRecord")
        }
        set tpPointRecord(t) {
            this.setBoolean("tpPointRecord", t)
        }
        get damageShow() {
            return this.getBoolean("damageShow")
        }
        set damageShow(t) {
            this.setBoolean("damageShow", t)
        }
        get ownerExists() {
            return this.getBoolean("ownerExists")
        }
        set ownerExists(t) {
            this.setBoolean("ownerExists", t)
        }
        get entityCleanerLeastNum() {
            return this.getNumber("entityCleanerLeastNum") || 200
        }
        set entityCleanerLeastNum(t) {
            this.setNumber("entityCleanerLeastNum", t)
        }
        get entityCleanerStrength() {
            return this.getNumber("entityCleanerStrength") || 5
        }
        set entityCleanerStrength(t) {
            this.setNumber("entityCleanerStrength", t)
        }
        get entityCleanerDelay() {
            return this.getNumber("entityCleanerDelay") || 30
        }
        set entityCleanerDelay(t) {
            this.setNumber("entityCleanerDelay", t)
        }
        get worldSeed() {
            return Math.abs(this.getNumber("worldSeed") || (this.worldSeed = Math.floor(Math.random() * D.Z.MAX_VALUE)))
        }
        set worldSeed(t) {
            this.setNumber("worldSeed", t)
        }
        get ruinsExsitsData() {
            return this.getNumber("ruinsExsitsData") || 0
        }
        set ruinsExsitsData(t) {
            this.setNumber("ruinsExsitsData", t)
        }
    }
    class F {
        static clamp(t, e, n) {
            return Math.max(e, Math.min(n, t))
        }
        static IEEEremainder(t, e) {
            return t - e * Math.round(t / e)
        }
        static isNumber(t) {
            return /^\d+(\.\d+)?$/.test(t) && /^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$/.test(t)
        }
        static zeroIfNaN(t) {
            return "string" == typeof t && (t = parseFloat(t)), void 0 === t || isNaN(t) ? 0 : t
        }
        static randomInteger(t, e) {
            return t + Math.floor(Math.random() * (e - t + 1))
        }
    }
    var B = __webpack_require__(38);
    class z {
        constructor(t) {
            this.item = t
        }
        append(t) {
            let e = this.getLore();
            e.push(t), this.setLore(e)
        }
        insert(t, e) {
            let n = this.getLore();
            n.splice(t, 0, e), this.setLore(n)
        }
        getLore() {
            return this.item.getLore()
        }
        setLore(t) {
            this.item.setLore(t)
        }
        search(t) {
            let e = this.getLore();
            for (let n = 0; n < e.length; n++)
                if (e[n].startsWith(t + " : ")) return new V(this.item, n)
        }
        getValueUseDefault(t) {
            let e = this.search(t);
            if (e) return e.get().substring(t.length + 3)
        }
        hasTag(t) {
            let e = this.getLore();
            for (let n of e)
                if (n.startsWith(t)) return !0;
            return !1
        }
        getValueUseRepeat(t) {
            let e = this.getValueUseDefault(t);
            return e ? e.length : 0
        }
        getValueUseMap(t, e) {
            let n = "  ",
                i = this.search(t);
            if (i)
                for (; i.hasNext() && (i.next(), i.get().startsWith(n));)
                    if (i.get().startsWith(n + e + " : ")) return i.get().substring(n.length + 3 + e.length)
        }
        setValueUseDefault(t, e) {
            let n = this.search(t);
            n ? n.revise(t + " : " + e).set() : this.append(t + " : " + e)
        }
        setTag(t) {
            this.hasTag(t) || this.append(t)
        }
        setValueUseRepeat(t, e, n) {
            this.setValueUseDefault(t, new Array(n).fill(e).join(""))
        }* entries(t) {
            if (t) {
                let e = "  ",
                    n = this.search(t);
                if (!n) return;
                for (; n.hasNext() && (n.next(), n.get().startsWith(e));) yield [...n.get().trim().split(" : ")]
            } else
                for (let t of this.getLore()) yield [...t.trim().split(" : ")]
        }
        setValueUseMap(t, e, n) {
            let i = "  ",
                r = this.search(t);
            if (!r) return this.append(t + " : "), void this.append(i + e + " : " + n);
            for (; r.hasNext() && (r.next(), r.get().startsWith(i));)
                if (r.get().startsWith(i + e + " : ")) return void r.revise(i + e + " : " + n).set();
            r = this.search(t), r ? this.insert(r.index + 1, i + e + " : " + n) : s.Z.console.error("Could not find " + t + " : " + n + " in lore")
        }
        delete(t) {
            let e = this.search(t);
            if (!e) return;
            let n = 1,
                i = e.index;
            for (; e.hasNext() && (e.next(), e.get().startsWith("  "));) n++;
            let s = this.getLore();
            s.splice(i, n), this.setLore(s)
        }
    }
    class V {
        constructor(t, e) {
            this.item = t, this.lore = t.getLore(), this.index = e
        }
        set() {
            this.item.setLore(this.lore)
        }
        revise(t) {
            return this.lore[this.index] = t, this
        }
        get() {
            return this.lore[this.index]
        }
        hasNext() {
            return this.index + 1 < this.lore.length
        }
        next() {
            this.index++
        }
    }
    class K extends z {
        setTag(t) {
            super.setTag("rn6" + t)
        }
        hasTag(t) {
            return super.hasTag(t.startsWith("") ? t : "rn6" + t)
        }
        getValueUseMap(t, e) {
            let n = super.getValueUseMap("rlf" + t, "rob" + e);
            return (null == n ? void 0 : n.startsWith("")) ? n.substring(6) : n
        }
        setValueUseMap(t, e, n) {
            super.setValueUseMap("rlf" + t, "rob" + e, "roe" + n)
        }* entries(t) {
            for (let e of super.entries(t)) yield [e[0].startsWith("") ? e[0].substring(6) : e[0], e[1].startsWith("") ? e[1].substring(6) : e[1]]
        }
        search(t) {
            let e = this.getLore();
            t = t.startsWith("") ? t.substring(6) : t;
            for (let n = 0; n < e.length; n++)
                if ((e[n].startsWith("") ? e[n].substring(6) : e[n]).startsWith(t + " : ")) return new V(this.item, n)
        }
    }
    class G {
        constructor() {
            this.pointUsed = 0, this.occupation = W.EMPTY, this.talents = []
        }
        static getDescription(t, e, n, i) {
            let s = G.calculateTalent(e, n, i);
            switch (n) {
                case j.VIENTIANE:
                    return (0, B.Z)(t.talentWanxiangDesc, `oe${s}r`);
                case j.CLOAD_PIERCING:
                    return (0, B.Z)(t.talentChuanyunDesc, `ob${s}r`);
                case j.ARMOR_BREAKING:
                    return (0, B.Z)(t.talentChuanjiaDesc, `ob${s}r`);
                case j.SANCTION:
                    return (0, B.Z)(t.talentZhicaiDesc, `ob${s}r`);
                case j.DEFENSE:
                    return (0, B.Z)(t.talentFangyuDesc, `ob${s}r`);
                case j.CHARGING:
                    return (0, B.Z)(t.talentChongnengDesc, `ob${s}r`);
                case j.RELOAD:
                    return (0, B.Z)(t.talentChongzhuangDesc, `ob${s}r`);
                case j.SOURCE:
                    return (0, B.Z)(t.talentYuanquanDesc, `ob${s}r`);
                case j.SUDDEN_STRIKE:
                    return (0, B.Z)(t.talentTuxiDesc, `ob${s}r`);
                case j.REGENERATE:
                    return (0, B.Z)(t.talentZaishengDesc, `oe${s}r`);
                default:
                    return ""
            }
        }
        static getLevel(t, e) {
            for (let n of t.talents)
                if (n.id === e) return n.level;
            return 0
        }
        static hasOccupation(t) {
            return t.occupation.id !== W.EMPTY.id
        }
        static chooseOccupation(t, e) {
            t.occupation = e;
            let n = new Set([j.VIENTIANE, j.CLOAD_PIERCING, j.ARMOR_BREAKING, j.SANCTION, j.DEFENSE, j.CHARGING, j.RELOAD, j.SOURCE]);
            for (let t of e.talentId) n.add(t);
            n.forEach((e => {
                t.talents.push(new j(e, 0))
            }))
        }
        static calculateTalent(t, e, n) {
            switch (e) {
                case j.VIENTIANE:
                    return n * (G.isOccupationTalent(t, e) ? 20 : 10) / 40;
                case j.CLOAD_PIERCING:
                    return n * (G.isOccupationTalent(t, e) ? 80 : 40) / 40;
                case j.ARMOR_BREAKING:
                    return n * (G.isOccupationTalent(t, e) ? 20 : 10) / 40;
                case j.SANCTION:
                    return n * (G.isOccupationTalent(t, e) ? 50 : 25) / 40;
                case j.DEFENSE:
                    return n * (G.isOccupationTalent(t, e) ? 45 : 25) / 40;
                case j.CHARGING:
                case j.RELOAD:
                    return n * (G.isOccupationTalent(t, e) ? 35 : 15) / 40;
                case j.SOURCE:
                    return n * (G.isOccupationTalent(t, e) ? 100 : 40) / 40;
                case j.SUDDEN_STRIKE:
                    return n * (G.isOccupationTalent(t, e) ? 80 : 0) / 40;
                case j.REGENERATE:
                    return n * (G.isOccupationTalent(t, e) ? 20 : 0) / 40;
                default:
                    return 0
            }
        }
        static calculateTalentToLore(t, e, n, i) {
            let s = new K(n);
            s.delete("addition");
            for (let n of t) {
                let t = 0,
                    r = F.zeroIfNaN(s.getValueUseMap("enchanting", j.getCharacter(i, n.id))) + n.level;
                t = G.calculateTalent(e, n.id, r);
                let a = F.zeroIfNaN(s.getValueUseMap("enchanting", j.getCharacter(i, n.id))),
                    o = Math.round(a + 10 * t) / 10;
                0 !== o && s.setValueUseMap("addition", j.getCharacter(i, n.id), a + " -> " + o)
            }
        }
        static isOccupationTalent(t, e) {
            return -1 !== t.talentId.indexOf(e)
        }
    }
    class j {
        constructor(t, e) {
            this.id = t, this.level = e
        }
        static getCharacter(t, e) {
            switch (e) {
                case j.VIENTIANE:
                    return t.talentWanxiang;
                case j.CLOAD_PIERCING:
                    return t.talentChuanyun;
                case j.ARMOR_BREAKING:
                    return t.talentChuanjia;
                case j.SANCTION:
                    return t.talentZhicai;
                case j.DEFENSE:
                    return t.talentFangyu;
                case j.CHARGING:
                    return t.talentChongneng;
                case j.RELOAD:
                    return t.talentChongzhuang;
                case j.SOURCE:
                    return t.talentYuanquan;
                case j.SUDDEN_STRIKE:
                    return t.talentTuxi;
                case j.REGENERATE:
                    return t.talentZaisheng;
                default:
                    return t.talentWeizhi
            }
        }
    }
    j.VIENTIANE = 1, j.CLOAD_PIERCING = 2, j.ARMOR_BREAKING = 3, j.SANCTION = 4, j.DEFENSE = 5, j.CHARGING = 6, j.RELOAD = 7, j.SOURCE = 8, j.SUDDEN_STRIKE = 9, j.REGENERATE = 10;
    class W {
        constructor(t, e) {
            this.id = t, this.talentId = e
        }
        getCharacter(t) {
            switch (this.id) {
                case 0:
                    return t.occupationEmpty;
                case 1:
                    return t.occupationGuard;
                case 2:
                    return t.occupationWarrior;
                case 3:
                    return t.occupationAssassin;
                case 4:
                    return t.occupationArcher;
                case 5:
                    return t.occupationWarlock;
                case 6:
                    return t.occupationPriest
            }
            return ""
        }
    }
    W.EMPTY = new W(0, []), W.GUARD = new W(1, [j.VIENTIANE, j.ARMOR_BREAKING]), W.WARRIOR = new W(2, [j.SANCTION, j.DEFENSE]), W.ASSASSIN = new W(3, [j.SANCTION, j.SUDDEN_STRIKE]), W.ARCHER = new W(4, [j.CLOAD_PIERCING, j.ARMOR_BREAKING]), W.WARLOCK = new W(5, [j.RELOAD, j.SOURCE, j.CHARGING]), W.PRIEST = new W(6, [j.SOURCE, j.REGENERATE]), W.keys = [W.GUARD, W.WARRIOR, W.ASSASSIN, W.ARCHER, W.WARLOCK, W.PRIEST];
    class H {
        constructor() {
            this.talent = new G
        }
    }
    const X = '\n\nAdd-Ons()(LiLeyi)\n\n\n\n\n\n1."MineCraft"  /\n\n2.\n\n3.\n\n\n1.\n1).MCPEDL//\n2).\n3)./BUG\n2.\n1).    \n2).\n\n\n1.\n2.MineCraft\n3. \n\n\n\n1 In order to protect the fun and interests of players and the interests of developers, we need these end-user license terms to formulate some rules for the download and use of winter chronicles add ons (hereinafter referred to as this work). This license is an agreement between you and the developers of this work (including but not limited to AA swordsman, LiLeyi and other people not listed or who will join the development in the future, hereinafter referred to as US). It describes the terms and conditions of using the game. These terms shall be applied to the maximum extent permitted by Chinese laws.\n2 Due to the particularity of network services, you agree that this agreement is signed in the form of electronic agreement. Once you express your consent in any form, it shall be deemed that you agree and have accepted all the terms of this Agreement;\n3 The conclusion, performance, interpretation and dispute settlement of this Agreement shall be governed by the laws of the people\'s Republic of China, excluding the application of other conflict laws. If you have any questions about the contents of this agreement or its implementation, please contact us. Any dispute arising from your use of our services and related to this Agreement shall be settled through friendly negotiation between us and you; If the negotiation fails, either party may bring a lawsuit to the people\'s court with jurisdiction at the place where the contract is signed.\nYou understand and agree that:\n1 Intellectual property\n1. This work is a free content expansion module created based on the game "minecraft". You may not use this work for commercial purposes / profits without our permission.\n2. It is allowed to read the code of this work to learn and communicate, but without our permission, you shall not steal the code, art, music, documents and other contents of this work in any way, and then copy, distribute, distribute, rent, exhibit, perform, broadcast, modify, adapt, sell, operate, sublicense, and disseminate them through the information network.\n3. You can make suggestions to us about this work, but this does not mean that your suggestions will be adopted. We can use or not use your suggestions in any way we need, and do not need to pay you any remuneration. If you think that we should pay for your proposal, please explain this requirement in advance and submit the proposal after we reply in writing. Otherwise, you will bear the losses caused by submitting the proposal.\n2 Our rights and obligations\n1. Provision of download\n1) . you can directly obtain this work from mcpedl and other websites / platforms / channels authorized by us\n2). If you have never obtained this work or the content with the same name as this work from a third party authorized by us, we cannot guarantee the normal use of this software and will not be responsible for the losses caused to you.\n3). We will constantly enrich the content, terminal and form of this work. When you use this service, you should select a work / game version that matches your terminal, system, etc., otherwise, you may not be able to use this work normally; We may release the test version before the completion of this work, so it may contain bugs, which is unavoidable.\n2. Update of works\n1). In order to improve the player\'s experience and improve the content of the work, we may constantly strive to develop new services and provide you with work updates from time to time.\n2). In order to improve the user experience, improve the service security and ensure the consistency of functions, we have the right to update the work, or change some of the functional effects and service contents of the work.\n3 Other\n1. When exposed to specific light and shadow patterns or flash light, a small part of the population will cause epilepsy. This situation may be caused by some undetected epileptic symptoms. Even if the person has no history of epilepsy, it may cause such symptoms. If your family or any family member has similar symptoms, please consult your doctor or physician before playing the game. If you have any symptoms during the game, including dizziness, dizziness, eye or muscle convulsions, loss of consciousness, loss of direction, convulsions, or any movement beyond your control, please stop the game immediately and consult your doctor or physician before continuing the game. Otherwise, you will bear all the consequences.\n2. Your archives in the game minecraft may be damaged due to loading the updates of this work. Please back up your archives before updating, otherwise you will bear all the consequences.\n3. The contents of this agreement also include the agreements or rules in the annexes to this agreement, and other relevant agreements and rules on this service that we may continuously publish. Once the above contents are officially released, they shall be an integral part of this agreement, and you shall also abide by them.\n',
        Z = {
            zh: {
                ruinDesertCmd_SELF: "",
                ruinDesertCmd_TP: "",
                ruinDesertCmd_BLAST: "",
                ruinDesertCmd_EFFECT: "",
                ruinDesertCmd_DAMAGE: "",
                ruinDesertCmd_HEALTH_ADD: "",
                ruinDesertCmd_HEALTH_REMOVE: "",
                ruinDesertCmd_FACING_ADD_2: "+2",
                ruinDesertCmd_FACING_ADD_4: "+4",
                ruinDesertCmd_FACING_ADD_6: "+6",
                ruinDesertCmd_FACING_ADD_8: "+8",
                ruinDesertCmd_FACING_ADD_10: "+10",
                ruinDesertCmd_FACING_ADD_12: "+12",
                ruinDesertCmd_FACING_ADD_16: "+16",
                ruinDesertCmd_FACING_ADD_20: "+20",
                ruinDesertCmd_FACING_ADD_28: "+28",
                ruinDesertCmd_FACING_ADD_32: "+32",
                ruinDesertCmd_Y_ADD_4: "Y+4",
                ruinDesertCmd_Y_ADD_8: "Y+8",
                ruinDesertCmd_Y_ADD_16: "Y+16",
                ruinDesertCmd_Y_ADD_32: "Y+32",
                ruinDesertCmd_Y_REMOVE_4: "Y-4",
                ruinDesertCmd_Y_REMOVE_8: "Y-8",
                ruinDesertCmd_Y_REMOVE_16: "Y-16",
                ruinDesertCmd_Y_REMOVE_32: "Y-32",
                ruinDesertCmd_WEAKNESS: "",
                ruinDesertCmd_STRENGTH: "",
                ruinDesertCmd_BLIND: "",
                ruinDesertCmd_SPEED: "",
                ruinDesertCmd_DEFENSE: "",
                ruinDesertCmd_WITHER: "",
                ruinDesertCmd_EXECUTE: "",
                ruinDesertCmd_VALUE_1: ": 1",
                ruinDesertCmd_VALUE_2: ": 2",
                ruinDesertCmd_VALUE_4: ": 4",
                ruinDesertCmd_VALUE_8: ": 8",
                ruinDesertCmd_VALUE_16: ": 16",
                ruinDesertCmd_VALUE_32: ": 32",
                ruinDesertCmd_VALUE_3: ": 3",
                ruinDesertCmd_VALUE_5: ": 5",
                ruinDesertCmd_VALUE_10: ": 4",
                ruinDesertCmd_VALUE_64: ": 64",
                ruinDesertCmd_GUARD_POS: "",
                maxSingleDamage: "",
                maxSecondaryDamage: "",
                talentWanxiang: "",
                talentChuanyun: "",
                talentChuanjia: "",
                talentZhicai: "",
                talentFangyu: "",
                talentChongneng: "",
                talentChongzhuang: "",
                talentYuanquan: "",
                talentTuxi: "",
                talentZaisheng: "",
                talentWeizhi: "",
                talentWanxiangDesc: " {0} ",
                talentChuanyunDesc: "0 ~ 64 {0} ",
                talentChuanjiaDesc: " {0} * () ",
                talentZhicaiDesc: "0 ~ 16 {0} ",
                talentFangyuDesc: " {0} ",
                talentChongnengDesc: " {0}",
                talentChongzhuangDesc: " {0}",
                talentYuanquanDesc: " {0}",
                talentTuxiDesc: " {0} 10s",
                talentZaishengDesc: "10s18 {0} ",
                talentWeizhiDesc: "",
                occupationEmpty: "",
                occupationGuard: "",
                occupationWarrior: "",
                occupationAssassin: "",
                occupationArcher: "",
                occupationWarlock: "",
                occupationPriest: "",
                menuUISubtitleGonggao: "",
                menuUIMsgGonggao1: "boss",
                menuUISubtitleHuodong: "",
                menuUISubtitleBanben: "",
                menuUIMsgBanben1: "",
                menuUIMsgBanben2: "Addon: ",
                menuUIMsgBanben3: "",
                menuUIMsgBanben4: "",
                menuUIMsgBanben6: "",
                menuUIMsgBanben5: "/tag @s add owner",
                menuUIMsgBailan1: "",
                menuUIMsgBailan2: "",
                menuUIMsgBailan3: "",
                menuUIMsgBailan4: "",
                menuUIMsgBailan5: "",
                menuUIMsgBailan6: "",
                menuUIMsgBailan7: "BOSS",
                menuUIMsgBailan8: "bossBOSS  boss",
                menuUIMsgBailan9: "",
                menuUIMsgBailan10: "  owner tag350",
                menuUIMsgBailan11: "",
                menuUIMsgBailan12: "",
                menuUIMsgBailan13: "",
                menuUIMsgBailan14: "",
                menuUIMsgBailan15: "",
                menuUIMsgBailan16: "",
                menuUIMsgBailan17: "",
                menuUIMsgBailan18: "",
                menuUIMsgBailan19: "",
                menuUIMsgBailan20: "",
                menuUIMsgBailan21: "",
                menuUIMsgBailan22: " ",
                menuUIMsgBailan23: "",
                menuUIMsgBailan24: "",
                menuUIMsgBailan25: "",
                menuUIMsgBailan26: "",
                menuUIMsgBailan27: "",
                menuUIMsgBailan28: "",
                menuUIMsgBailan29: "",
                menuUIMsgBailan30: "  ",
                menuUIMsgBailan31: "",
                menuUIMsgBailan32: "",
                menuUIMsgBailan33: "",
                menuUIMsgBailan34: "",
                menuUIMsgBailan35: "",
                menuUIMsgBailan36: "b",
                menuUIMsgBailan37: "b",
                menuUIMsgBailan38: "",
                menuUIMsgBailan39: "",
                menuUIMsgBailan40: "",
                menuUIMsgBailan41: "",
                menuUIMsgBailan42: "",
                menuUIMsgBailan43: "",
                menuUIMsgBailan44: "",
                menuUIMsgBailan45: "",
                menuUIMsgBailan46: "",
                menuUIMsgBailan47: "",
                menuUIMsgBailan48: "",
                menuUIMsgBailan49: "  ",
                menuUIMsgBailan50: "",
                menuUIMsgBailan51: "",
                menuUIMsgBailan52: "",
                menuUIMsgBailan53: "",
                menuUIMsgBailan54: "",
                menuUIMsgBailan55: "",
                menuUIMsgBailan56: "b",
                menuUIMsgBailan57: "b",
                menuUIMsgBailan58: "",
                menuUIMsgBailan59: "",
                menuUIMsgBailan60: "b",
                menuUIMsgBailan61: "b",
                menuUIMsgBailan62: "",
                menuUIMsgBailan63: "b",
                menuUIMsgBailan64: "b",
                menuUIMsgBailan65: "",
                menuUIMsgBailan66: "b",
                menuUIMsgBailan67: "b",
                menuUIMsgBailan68: "",
                menuUIMsgBailan69: "",
                menuUIMsgBailan70: "b",
                menuUIMsgBailan71: "b",
                menuUIMsgBailan72: "",
                menuUIMsgBailan73: "b",
                menuUIMsgBailan74: "b",
                menuUIMsgBailan75: "",
                menuUIMsgBailan76: "",
                menuUIMsgBailan77: "",
                menuUIMsgBailan78: "",
                menuUIMsgBailan79: "",
                menuUIMsgBailan80: "",
                menuUIMsgBailan81: "",
                menuUIMsgBailan82: "",
                menuUIMsgBailan83: " op /tag @s add owner ",
                menuUIMsgBailan84: "",
                menuUIMsgBailan85: "",
                menuUIMsgBailan86: "",
                menuUIMsgBailan87: "()",
                menuUIMsgBailan88: "()",
                menuUIMsgBailan89: "()",
                menuUIMsgBailan90: " op /tag @s add owner ",
                menuUIMsgBailan91: "()",
                menuUIMsgBailan92: "()",
                menuUIMsgBailan93: "()",
                menuUIMsgBailan94: "ID",
                menuUIMsgBailan95: "",
                menuUIMsgBailan96: "",
                menuUIMsgBailan97: "",
                menuUIMsgBailan98: "",
                menuUIMsgBailan99: "",
                menuUIMsgBailan100: "",
                menuUIMsgBailan101: "",
                menuUIMsgBailan102: "",
                menuUIMsgBailan103: "",
                menuUIMsgBailan104: "qqBilibiliLiLeyi  aa"
            },
            en: {
                ruinDesertCmd_SELF: "",
                ruinDesertCmd_TP: "TP",
                ruinDesertCmd_BLAST: "BLAST",
                ruinDesertCmd_EFFECT: "EFFECT",
                ruinDesertCmd_DAMAGE: "DAMAGE",
                ruinDesertCmd_HEALTH_ADD: "HEALTH_ADD",
                ruinDesertCmd_HEALTH_REMOVE: "HEALTH_REMOVE",
                ruinDesertCmd_FACING_ADD_2: "facing+2",
                ruinDesertCmd_FACING_ADD_4: "facing+4",
                ruinDesertCmd_FACING_ADD_6: "facing+6",
                ruinDesertCmd_FACING_ADD_8: "facing+8",
                ruinDesertCmd_FACING_ADD_10: "facing+10",
                ruinDesertCmd_FACING_ADD_12: "facing+12",
                ruinDesertCmd_FACING_ADD_16: "facing+16",
                ruinDesertCmd_FACING_ADD_20: "facing+20",
                ruinDesertCmd_FACING_ADD_28: "facing+28",
                ruinDesertCmd_FACING_ADD_32: "facing+32",
                ruinDesertCmd_Y_ADD_4: "Y+4",
                ruinDesertCmd_Y_ADD_8: "Y+8",
                ruinDesertCmd_Y_ADD_16: "Y+16",
                ruinDesertCmd_Y_ADD_32: "Y+32",
                ruinDesertCmd_Y_REMOVE_4: "Y-4",
                ruinDesertCmd_Y_REMOVE_8: "Y-8",
                ruinDesertCmd_Y_REMOVE_16: "Y-16",
                ruinDesertCmd_Y_REMOVE_32: "Y-32",
                ruinDesertCmd_WEAKNESS: "WEAKNESS",
                ruinDesertCmd_STRENGTH: "STRENGTH",
                ruinDesertCmd_BLIND: "BLIND",
                ruinDesertCmd_SPEED: "SPEED",
                ruinDesertCmd_DEFENSE: "DEFENSE",
                ruinDesertCmd_WITHER: "WITHER",
                ruinDesertCmd_EXECUTE: "EXECUTE",
                ruinDesertCmd_VALUE_1: "VALUE_1",
                ruinDesertCmd_VALUE_2: "VALUE_2",
                ruinDesertCmd_VALUE_4: "VALUE_4",
                ruinDesertCmd_VALUE_8: "VALUE_8",
                ruinDesertCmd_VALUE_16: "VALUE_16",
                ruinDesertCmd_VALUE_32: "VALUE_32",
                ruinDesertCmd_VALUE_3: "VALUE_3",
                ruinDesertCmd_VALUE_5: "VALUE_5",
                ruinDesertCmd_VALUE_10: "VALUE_10",
                ruinDesertCmd_VALUE_64: "VALUE_64",
                ruinDesertCmd_GUARD_POS: "GUARD_POS",
                maxSingleDamage: "Maximum monomer damage",
                maxSecondaryDamage: "Maximum second injury",
                talentWanxiang: "Juvenation",
                talentChuanyun: "Precision",
                talentChuanjia: "Bloodrage",
                talentZhicai: "Overheat",
                talentFangyu: "DamageAbsorption",
                talentChongneng: "WeaponRecharge",
                talentChongzhuang: "ArmorRecharge",
                talentYuanquan: "MagicRecharge",
                talentTuxi: "Frenzy",
                talentZaisheng: "Regeneration",
                talentWeizhi: "unknown",
                talentWanxiangDesc: "HP increases {0}",
                talentChuanyunDesc: "Deal {0} extra damage to targets within 0-64 blocks",
                talentChuanjiaDesc: "Deal extra damage ({0} * your HP) to targets",
                talentZhicaiDesc: "Deal {0} extra damage to targets within 0-16 blocks, the closer the distance, the higher the damage.",
                talentFangyuDesc: "Absorb {0} of the damage.",
                talentChongnengDesc: "Reduce {0} of your weapon's CD",
                talentChongzhuangDesc: "Reduce {0} of your armor's CD",
                talentYuanquanDesc: "Mana recharge speed up {0}",
                talentTuxiDesc: "Deal {0} extra damage to targets. CD: 10s",
                talentZaishengDesc: "Cure the players {0} HP around you every 10s, this talent is invalid when you are in hostile mode",
                talentWeizhiDesc: "unknown",
                occupationEmpty: "null",
                occupationGuard: "Guard",
                occupationWarrior: "warrior",
                occupationAssassin: "Assassin",
                occupationArcher: "Archer",
                occupationWarlock: "Warlock",
                occupationPriest: "Priest",
                menuUISubtitleGonggao: "announcement",
                menuUIMsgGonggao1: "Our new update is out, Let's take a look!",
                menuUISubtitleHuodong: "Activity",
                menuUISubtitleBanben: "Version",
                menuUIMsgBanben1: "Version Information",
                menuUIMsgBanben2: "Basic information",
                menuUIMsgBanben3: "Addon's version: 1.7.4B1, more info about the addon: ",
                menuUIMsgBanben4: "Edition notice",
                menuUIMsgBanben6: "Thanks list",
                menuUIMsgBanben5: "Winter poetry may have a stuttering phenomenon, so we recommend that you first enter/tag @s add owner, then go to the menu settings to open the entity cleanup option.If you are worried that the important entity will be cleared, please don't open it.",
                menuUIMsgBailan1: "Homepage",
                menuUIMsgBailan2: "Propaganda and winning gifts",
                menuUIMsgBailan3: "This work is a large module made for three years, but it is no popular, we decided to host this event",
                menuUIMsgBailan4: "Payment activity: ",
                menuUIMsgBailan5: "Version",
                menuUIMsgBailan6: "End User License Agreement",
                menuUIMsgBailan7: "How to summon the bosses?",
                menuUIMsgBailan8: "Now some of the bosses have their own summon blocks, in some biomes, there will be structures with summon blocks inside. With different items, you can unlock the block to summon the boss. It may takes you a long time to find these summon blocks, good luck!",
                menuUIMsgBailan9: "Why it is so laggy?",
                menuUIMsgBailan10: "Too many mobs may cause the problem, you can go to the Manage page to opem the 'Mob Cleanup'.(Only players with owner tag can visit the Manage page)",
                menuUIMsgBailan11: "How can I upgrade?",
                menuUIMsgBailan12: "You can upgrade your level through the level up table, and you can get some talent points to upgrade your talents when your level is up.",
                menuUIMsgBailan13: "personal",
                menuUIMsgBailan14: "information",
                menuUIMsgBailan15: "Yes",
                menuUIMsgBailan16: "no",
                menuUIMsgBailan17: "Yes",
                menuUIMsgBailan18: "no",
                menuUIMsgBailan19: "addition",
                menuUIMsgBailan20: "Level effect",
                menuUIMsgBailan21: "You can get some powerful buffs when you reach some special levels.",
                menuUIMsgBailan22: "Level effect",
                menuUIMsgBailan23: "Particles",
                menuUIMsgBailan24: "You can craft special potions to get particles, remove them here if you don't like it.",
                menuUIMsgBailan25: "Remove flame particle",
                menuUIMsgBailan26: "Remove halo particle",
                menuUIMsgBailan27: "Remove rune particle",
                menuUIMsgBailan28: "Remove love particle",
                menuUIMsgBailan29: "talent",
                menuUIMsgBailan30: "Talent points: ",
                menuUIMsgBailan31: "Choose your job",
                menuUIMsgBailan32: "Teleport point",
                menuUIMsgBailan33: "Teleport point record",
                menuUIMsgBailan34: "Teleport point: ",
                menuUIMsgBailan35: "Go to point:",
                menuUIMsgBailan36: "bbackpack without teleport stones, teleport failed",
                menuUIMsgBailan37: "bsuccessful teleport",
                menuUIMsgBailan38: "Remarks",
                menuUIMsgBailan39: "Enter remarks",
                menuUIMsgBailan40: "Delete point:",
                menuUIMsgBailan41: "Record the current point",
                menuUIMsgBailan42: "Forbidden record teleportation point",
                menuUIMsgBailan43: "Death point: ",
                menuUIMsgBailan44: "Go to the point",
                menuUIMsgBailan45: "Destroy retrospective",
                menuUIMsgBailan46: "Exchanges",
                menuUIMsgBailan47: "Associated settings",
                menuUIMsgBailan48: "Hostile mode",
                menuUIMsgBailan49: "When you are in hostile mode, you can attack other players and your name will turn into red. When you are in friendly mode, you can't attack other players and your name will turn into green.",
                menuUIMsgBailan50: "That is, if a player's name is green, then he is not threatened; if he starts red, then he may have a tendency to attack.",
                menuUIMsgBailan51: "Friendly mode",
                menuUIMsgBailan52: "Hostile mode",
                menuUIMsgBailan53: "Teleport",
                menuUIMsgBailan54: "teleport not allowed",
                menuUIMsgBailan55: "Teleport to",
                menuUIMsgBailan56: "bbackpack without teleport stones, teleport failed",
                menuUIMsgBailan57: "byou initiated a request to the other party",
                menuUIMsgBailan58: "Teleport request",
                menuUIMsgBailan59: "Yes",
                menuUIMsgBailan60: "bsuccessful teleport",
                menuUIMsgBailan61: "bsuccessful teleport",
                menuUIMsgBailan62: "no",
                menuUIMsgBailan63: "bthe other party rejected your request",
                menuUIMsgBailan64: "byou reject the other party's request",
                menuUIMsgBailan65: "Invite the player to teleport to your position",
                menuUIMsgBailan66: "bbackpack without teleport stones, teleport failed",
                menuUIMsgBailan67: "byou initiated an invitation to the other party",
                menuUIMsgBailan68: "Teleport request",
                menuUIMsgBailan69: "Yes",
                menuUIMsgBailan70: "bsuccessful teleport",
                menuUIMsgBailan71: "bsuccessful teleport",
                menuUIMsgBailan72: "no",
                menuUIMsgBailan73: "bthe target player rejected your invitation",
                menuUIMsgBailan74: "byou rejected the invitation.",
                menuUIMsgBailan75: "set up",
                menuUIMsgBailan76: "manage",
                menuUIMsgBailan77: "Game content",
                menuUIMsgBailan78: "Player Teleportation",
                menuUIMsgBailan79: "Any teleportation requires teleportation stone",
                menuUIMsgBailan80: "Entity Cleanup",
                menuUIMsgBailan81: "Starting the death point back",
                menuUIMsgBailan82: "Allow players to record teleportation point",
                menuUIMsgBailan83: "Access to this page without permissions.If you are OP, enter/tag @s add owner to obtain management permissions",
                menuUIMsgBailan84: "advanced settings",
                menuUIMsgBailan85: "Entity Cleaning Settings",
                menuUIMsgBailan86: "Entity Cleanup",
                menuUIMsgBailan87: "Reserve the number of entities (minimum entity)",
                menuUIMsgBailan88: "Clean up sensitivity (instantaneous stuck processing)",
                menuUIMsgBailan89: "Cleaning frequency (long -term cleaning intensity)",
                menuUIMsgBailan90: "Access to this page without permissions.If you are OP, enter/tag @s add owner to obtain management permissions",
                menuUIMsgBailan91: "Reserve the number of entities (minimum entity)",
                menuUIMsgBailan92: "Clean up sensitivity (instantaneous stuck processing)",
                menuUIMsgBailan93: "Cleaning frequency (long -term cleaning intensity)",
                menuUIMsgBailan94: "Player ID",
                menuUIMsgBailan95: "Player level",
                menuUIMsgBailan96: "Mana",
                menuUIMsgBailan97: "Weapon skill cooling",
                menuUIMsgBailan98: "Armor skills cooling",
                menuUIMsgBailan99: "Whether the friendly mode is opened",
                menuUIMsgBailan100: "Whether the level bonus is turned on",
                menuUIMsgBailan101: "Personal settings",
                menuUIMsgBailan102: "language selection",
                menuUIMsgBailan103: "How can I contact the creator?",
                menuUIMsgBailan104: "Twitter: @le_lyii or @EAT_YOUR_PANTS     (issues)Github: https://github.com/AAswordman/ThePoetryOfWinter"
            }
        };
    class q {
        constructor(t) {
            this._client = t
        }
        get exPlayer() {
            return this._client.exPlayer
        }
        get player() {
            return this._client.player
        }
        get client() {
            return this._client
        }
        get globalSettings() {
            return this._client.globalSettings
        }
        get data() {
            return this._client.data
        }
        runCommandAsync(t) {
            return s.Z.runCommandAsync(t)
        }
        setTimeout(t, e) {
            this._client.setTimeout(t, e)
        }
        getDimension(t) {
            return this._client.getDimension(t)
        }
        getExDimension(t) {
            return this._client.getExDimension(t)
        }
        getPlayers() {
            return this._client.getPlayers()
        }
        getEvents() {
            return this._client.getEvents()
        }
        sayTo(t, e = this.player) {
            this._client.sayTo(t, e)
        }
        getLang() {
            return this._client.getLang()
        }
    }
    var Y;
    class J {}
    Y = J, J.DESERT_RUIN_NUM = 0, J.DESERT_RUIN_LOCATION_START = new e.Z(16384, 64, 16384), J.DESERT_RUIN_LOCATION_SIZE = new e.Z(512, 191, 512), J.DESERT_RUIN_LOCATION_END = Y.DESERT_RUIN_LOCATION_START.clone().add(Y.DESERT_RUIN_LOCATION_SIZE), J.DESERT_RUIN_LOCATION_CENTER = Y.DESERT_RUIN_LOCATION_START.clone().add(Y.DESERT_RUIN_LOCATION_SIZE.x / 2, 0, Y.DESERT_RUIN_LOCATION_SIZE.z / 2), J.DESERT_RUIN_AREA = new E(Y.DESERT_RUIN_LOCATION_START, Y.DESERT_RUIN_LOCATION_SIZE), J.DESERT_RUIN_PROTECT_AREA = new E(Y.DESERT_RUIN_LOCATION_START.clone().sub(Y.DESERT_RUIN_LOCATION_SIZE), Y.DESERT_RUIN_LOCATION_END.clone().add(Y.DESERT_RUIN_LOCATION_SIZE)), J.STONE_RUIN_NUM = 1, J.STONE_RUIN_LOCATION_START = new e.Z(15360, 64, 15360), J.STONE_RUIN_LOCATION_SIZE = new e.Z(128, 128, 128), J.STONE_RUIN_LOCATION_END = Y.STONE_RUIN_LOCATION_START.clone().add(Y.STONE_RUIN_LOCATION_SIZE), J.STONE_RUIN_LOCATION_CENTER = Y.STONE_RUIN_LOCATION_START.clone().add(Y.STONE_RUIN_LOCATION_SIZE.x / 2, 0, Y.STONE_RUIN_LOCATION_SIZE.z / 2), J.STONE_RUIN_AREA = new E(Y.STONE_RUIN_LOCATION_START, Y.STONE_RUIN_LOCATION_SIZE), J.STONE_RUIN_PROTECT_AREA = new E(Y.STONE_RUIN_LOCATION_START.clone().sub(Y.STONE_RUIN_LOCATION_SIZE), Y.STONE_RUIN_LOCATION_END.clone().add(Y.STONE_RUIN_LOCATION_SIZE)), J.CAVE_RUIN_NUM = 2, J.CAVE_RUIN_LOCATION_START = new e.Z(17408, 64, 17408), J.CAVE_RUIN_LOCATION_SIZE = new e.Z(128, 128, 128), J.CAVE_RUIN_LOCATION_END = Y.CAVE_RUIN_LOCATION_START.clone().add(Y.CAVE_RUIN_LOCATION_SIZE), J.CAVE_RUIN_LOCATION_CENTER = Y.CAVE_RUIN_LOCATION_START.clone().add(Y.CAVE_RUIN_LOCATION_SIZE.x / 2, 0, Y.CAVE_RUIN_LOCATION_SIZE.z / 2), J.CAVE_RUIN_AREA = new E(Y.CAVE_RUIN_LOCATION_START, Y.CAVE_RUIN_LOCATION_SIZE), J.CAVE_RUIN_PROTECT_AREA = new E(Y.CAVE_RUIN_LOCATION_START.clone().sub(Y.CAVE_RUIN_LOCATION_SIZE), Y.CAVE_RUIN_LOCATION_END.clone().add(Y.CAVE_RUIN_LOCATION_SIZE)), J.ANCIENT_RUIN_NUM = 3, J.ANCIENT_RUIN_LOCATION_START = new e.Z(15360, 64, 16384), J.ANCIENT_RUIN_LOCATION_SIZE = new e.Z(128, 128, 128), J.ANCIENT_RUIN_LOCATION_END = Y.ANCIENT_RUIN_LOCATION_START.clone().add(Y.ANCIENT_RUIN_LOCATION_SIZE), J.ANCIENT_RUIN_LOCATION_CENTER = Y.ANCIENT_RUIN_LOCATION_START.clone().add(Y.ANCIENT_RUIN_LOCATION_SIZE.x / 2, 0, Y.ANCIENT_RUIN_LOCATION_SIZE.z / 2), J.ANCIENT_RUIN_AREA = new E(Y.ANCIENT_RUIN_LOCATION_START, Y.ANCIENT_RUIN_LOCATION_SIZE), J.ANCIENT_RUIN_PROTECT_AREA = new E(Y.ANCIENT_RUIN_LOCATION_START.clone().sub(Y.ANCIENT_RUIN_LOCATION_SIZE), Y.ANCIENT_RUIN_LOCATION_END.clone().add(Y.ANCIENT_RUIN_LOCATION_SIZE)), J.MIND_RUIN_NUM = 4, J.MIND_RUIN_LOCATION_START = new e.Z(15360, 64, 17408), J.MIND_RUIN_LOCATION_SIZE = new e.Z(128, 128, 128), J.MIND_RUIN_LOCATION_END = Y.MIND_RUIN_LOCATION_START.clone().add(Y.MIND_RUIN_LOCATION_SIZE), J.MIND_RUIN_LOCATION_CENTER = Y.MIND_RUIN_LOCATION_START.clone().add(Y.MIND_RUIN_LOCATION_SIZE.x / 2, 0, Y.MIND_RUIN_LOCATION_SIZE.z / 2), J.MIND_RUIN_AREA = new E(Y.MIND_RUIN_LOCATION_START, Y.MIND_RUIN_LOCATION_SIZE), J.MIND_RUIN_PROTECT_AREA = new E(Y.MIND_RUIN_LOCATION_START.clone().sub(Y.MIND_RUIN_LOCATION_SIZE), Y.MIND_RUIN_LOCATION_END.clone().add(Y.MIND_RUIN_LOCATION_SIZE));
    class Q {
        constructor(t) {
            this.game = t
        }
        get client() {
            return this.game.client
        }
    }
    var tt, et, nt, it, st = __webpack_require__(985);

    function rt(t, e) {
        return t[e]
    }! function(t) {
        t[t.TP = 0] = "TP", t[t.BLAST = 1] = "BLAST", t[t.EFFECT = 2] = "EFFECT", t[t.DAMAGE = 3] = "DAMAGE", t[t.HEALTH_ADD = 4] = "HEALTH_ADD", t[t.HEALTH_REMOVE = 5] = "HEALTH_REMOVE", t[t.EXECUTE = 6] = "EXECUTE"
    }(tt || (tt = {})),
    function(t) {
        t[t.SELF = 0] = "SELF", t[t.FACING_ADD_2 = 1] = "FACING_ADD_2", t[t.FACING_ADD_4 = 2] = "FACING_ADD_4", t[t.FACING_ADD_6 = 3] = "FACING_ADD_6", t[t.FACING_ADD_8 = 4] = "FACING_ADD_8", t[t.FACING_ADD_10 = 5] = "FACING_ADD_10", t[t.FACING_ADD_12 = 6] = "FACING_ADD_12", t[t.FACING_ADD_16 = 7] = "FACING_ADD_16", t[t.FACING_ADD_20 = 8] = "FACING_ADD_20", t[t.FACING_ADD_28 = 9] = "FACING_ADD_28", t[t.FACING_ADD_32 = 10] = "FACING_ADD_32", t[t.Y_ADD_4 = 11] = "Y_ADD_4", t[t.Y_ADD_8 = 12] = "Y_ADD_8", t[t.Y_ADD_16 = 13] = "Y_ADD_16", t[t.Y_ADD_32 = 14] = "Y_ADD_32", t[t.Y_REMOVE_4 = 15] = "Y_REMOVE_4", t[t.Y_REMOVE_8 = 16] = "Y_REMOVE_8", t[t.Y_REMOVE_16 = 17] = "Y_REMOVE_16", t[t.Y_REMOVE_32 = 18] = "Y_REMOVE_32", t[t.GUARD_POS = 19] = "GUARD_POS"
    }(et || (et = {})),
    function(t) {
        t[t.WEAKNESS = 0] = "WEAKNESS", t[t.STRENGTH = 1] = "STRENGTH", t[t.BLIND = 2] = "BLIND", t[t.SPEED = 3] = "SPEED", t[t.DEFENSE = 4] = "DEFENSE", t[t.WITHER = 5] = "WITHER"
    }(nt || (nt = {})),
    function(t) {
        t[t.VALUE_1 = 0] = "VALUE_1", t[t.VALUE_2 = 1] = "VALUE_2", t[t.VALUE_4 = 2] = "VALUE_4", t[t.VALUE_8 = 3] = "VALUE_8", t[t.VALUE_16 = 4] = "VALUE_16", t[t.VALUE_32 = 5] = "VALUE_32", t[t.VALUE_3 = 6] = "VALUE_3", t[t.VALUE_5 = 7] = "VALUE_5", t[t.VALUE_10 = 8] = "VALUE_10", t[t.VALUE_64 = 9] = "VALUE_64"
    }(it || (it = {}));
    class at {
        constructor(t) {
            this.collections = [], this.game = t
        }
        clear() {
            this.collections.splice(0, this.collections.length)
        }
        init() {
            this.collections = []
        }
        randomAddRule() {
            let t = D.Z.choice(function(t) {
                let e = [];
                for (let n in t) isNaN(Number(n)) && e.push(n);
                return e
            }(D.Z.choice([nt, tt, et, it])));
            return this.collections.push(t), t
        }
        show() {
            return n = this, i = void 0, r = function*() {
                let n = [];
                t: for (let i of [1]) {
                    let i = "/ ",
                        s = tt.EXECUTE;
                    for (; s === tt.EXECUTE;) {
                        let t = (new st.ActionFormData).title("").body("" + i + "\n" + this.collections.map((t => this.game.getLang()["ruinDesertCmd_" + t])).join(" , ")),
                            e = [];
                        for (let t of this.collections) t in tt && e.push(t);
                        if (0 === e.length) break t;
                        for (let n of e) t.button(this.game.getLang()["ruinDesertCmd_" + n]);
                        let r = yield t.show(this.game.player);
                        if (r.canceled || void 0 === r.selection) break t;
                        i += this.game.getLang()["ruinDesertCmd_" + e[r.selection]] + " / ", n.push(e[r.selection]), this.collections.splice(this.collections.indexOf(e[r.selection]), 1), s = tt[e[r.selection]], console.log(this.collections), t = (new st.ActionFormData).title("").body("" + i + "\n" + this.collections.map((t => this.game.getLang()["ruinDesertCmd_" + t])).join(" , ")), e = [];
                        for (let t of this.collections) t in et && e.push(t);
                        if (0 === e.length) break t;
                        for (let n of e) t.button(this.game.getLang()["ruinDesertCmd_" + n]);
                        if (r = yield t.show(this.game.player), r.canceled || void 0 === r.selection) break t;
                        i += this.game.getLang()["ruinDesertCmd_" + e[r.selection]] + " / ", n.push(e[r.selection]), this.collections.splice(this.collections.indexOf(e[r.selection]), 1)
                    }
                    let r = (new st.ActionFormData).title("//").body("" + i + "\n" + this.collections.map((t => this.game.getLang()["ruinDesertCmd_" + t])).join(" , ")),
                        a = [];
                    if (s === tt.EFFECT)
                        for (let t of this.collections) t in nt && a.push(t);
                    else
                        for (let t of this.collections) t in it && a.push(t);
                    if (0 === a.length) break t;
                    for (let t of a) r.button(this.game.getLang()["ruinDesertCmd_" + t]);
                    let o = yield r.show(this.game.player);
                    if (o.canceled || void 0 === o.selection) break t;
                    i += this.game.getLang()["ruinDesertCmd_" + a[o.selection]] + " / ", n.push(a[o.selection]), this.collections.splice(this.collections.indexOf(a[o.selection]), 1);
                    const h = new e.Z;
                    let l = 0;
                    for (s = tt.EXECUTE; s === tt.EXECUTE && n[l] in tt;) {
                        s = rt(tt, n[l]), l += 1;
                        let t = rt(et, n[l]);
                        switch (l += 1, t) {
                            case et.FACING_ADD_2:
                                h.add(this.game.exPlayer.getViewDirection().scl(2));
                                break;
                            case et.FACING_ADD_4:
                                h.add(this.game.exPlayer.getViewDirection().scl(4));
                                break;
                            case et.FACING_ADD_6:
                                h.add(this.game.exPlayer.getViewDirection().scl(6));
                                break;
                            case et.FACING_ADD_8:
                                h.add(this.game.exPlayer.getViewDirection().scl(8));
                                break;
                            case et.FACING_ADD_10:
                                h.add(this.game.exPlayer.getViewDirection().scl(10));
                                break;
                            case et.FACING_ADD_12:
                                h.add(this.game.exPlayer.getViewDirection().scl(12));
                                break;
                            case et.FACING_ADD_16:
                                h.add(this.game.exPlayer.getViewDirection().scl(16));
                                break;
                            case et.FACING_ADD_32:
                                h.add(this.game.exPlayer.getViewDirection().scl(32));
                                break;
                            case et.FACING_ADD_20:
                                h.add(this.game.exPlayer.getViewDirection().scl(20));
                                break;
                            case et.FACING_ADD_28:
                                h.add(this.game.exPlayer.getViewDirection().scl(28));
                                break;
                            case et.Y_ADD_8:
                                h.y += 8;
                                break;
                            case et.Y_ADD_4:
                                h.y += 4;
                                break;
                            case et.Y_ADD_16:
                                h.y += 16;
                                break;
                            case et.Y_ADD_32:
                                h.y += 32;
                                break;
                            case et.Y_REMOVE_8:
                                h.y -= 8;
                                break;
                            case et.Y_REMOVE_4:
                                h.y -= 4;
                                break;
                            case et.Y_REMOVE_16:
                                h.y -= 16;
                                break;
                            case et.Y_REMOVE_32:
                                h.y -= 32
                        }
                    }
                    const c = rt(nt, n[l]) || rt(it, n[l]),
                        p = n[l].startsWith("VALUE_") ? parseInt(n[l].split("_")[1]) : 0,
                        d = yield(new st.ModalFormData).title("").slider("(s)", 0, 15, .5, 0).show(this.game.player);
                    if (d.canceled || void 0 === d.formValues) break t;
                    const m = 1e3 * d.formValues[0],
                        g = new e.Z,
                        f = new u.Z(this.game.getEvents(), (() => {
                            g.set(this.game.player.location).add(h), this.game.getExDimension().spawnParticle("wb:ruin_desert_rulepre", g)
                        })).delay(1);
                    return f.start(), void this.game.setTimeout((() => {
                        switch (f.stop(), s) {
                            case tt.BLAST:
                                this.game.getExDimension().createExplosion(g, p, {
                                    breaksBlocks: !1,
                                    source: this.game.player
                                });
                                break;
                            case tt.DAMAGE:
                                this.game.getExDimension().getEntities({
                                    maxDistance: 15,
                                    excludeTags: this.game.player.hasTag("wbmsyh") ? ["wbmsyh"] : [],
                                    location: k.Z.getLocation(g)
                                }).forEach((t => this.game.exPlayer.causeDamageTo(t, p)));
                                break;
                            case tt.HEALTH_ADD:
                                this.game.getExDimension().getEntities({
                                    maxDistance: 15,
                                    location: k.Z.getLocation(g)
                                }).forEach((t => {
                                    let e = I.Z.getInstance(t).getHealthComponent();
                                    e.setCurrent(e.current + p)
                                }));
                                break;
                            case tt.HEALTH_REMOVE:
                                this.game.getExDimension().getEntities({
                                    maxDistance: 15,
                                    excludeTags: this.game.player.hasTag("wbmsyh") ? ["wbmsyh"] : [],
                                    location: k.Z.getLocation(g)
                                }).forEach((t => {
                                    let e = I.Z.getInstance(t).getHealthComponent();
                                    e.setCurrent(Math.max(0, e.current - p))
                                }));
                                break;
                            case tt.TP:
                                this.game.getExDimension().getEntities({
                                    maxDistance: 15,
                                    location: k.Z.getLocation(g)
                                }).forEach((t => I.Z.getInstance(t).setPosition(g.clone().sub(this.game.exPlayer.getPosition()).scl(p / 2).add(g))));
                                break;
                            case tt.EFFECT: {
                                let e = t.MinecraftEffectTypes.absorption;
                                switch (c) {
                                    case nt.WITHER:
                                        e = t.MinecraftEffectTypes.wither;
                                        break;
                                    case nt.BLIND:
                                        e = t.MinecraftEffectTypes.blindness;
                                        break;
                                    case nt.DEFENSE:
                                        e = t.MinecraftEffectTypes.resistance;
                                        break;
                                    case nt.SPEED:
                                        e = t.MinecraftEffectTypes.speed;
                                        break;
                                    case nt.STRENGTH:
                                        e = t.MinecraftEffectTypes.strength;
                                        break;
                                    case nt.WEAKNESS:
                                        e = t.MinecraftEffectTypes.weakness
                                }
                                this.game.getExDimension().getEntities({
                                    maxDistance: 15,
                                    location: k.Z.getLocation(g)
                                }).forEach((t => t.addEffect(e, 600, 1, !1)));
                                break
                            }
                        }
                    }), m)
                }
                this.collections = this.collections.concat(n)
            }, new((s = void 0) || (s = Promise))((function(t, e) {
                function a(t) {
                    try {
                        u(r.next(t))
                    } catch (t) {
                        e(t)
                    }
                }

                function o(t) {
                    try {
                        u(r.throw(t))
                    } catch (t) {
                        e(t)
                    }
                }

                function u(e) {
                    e.done ? t(e.value) : function(t) {
                        return t instanceof s ? t : new s((function(e) {
                            e(t)
                        }))
                    }(e.value).then(a, o)
                }
                u((r = r.apply(n, i || [])).next())
            }));
            var n, i, s, r
        }
    }
    class ot {}
    ot.CHAR_MAZE_EMPTY = "", ot.CHAR_MAZE_PATH = "", ot.CHAR_MAZE_ROOM = "", ot.CHAR_MAZE_ROOM_PASSED = "", ot.CHAR_MAZE_ROOM_ARROW_UP = "", ot.CHAR_MAZE_ROOM_ARROW_RIGHT = "", ot.CHAR_MAZE_ROOM_ARROW_DOWN = "", ot.CHAR_MAZE_ROOM_ARROW_LEFT = "", ot.CHAR_MAZE_PATH_ARROW_UP = "", ot.CHAR_MAZE_PATH_ARROW_RIGHT = "", ot.CHAR_MAZE_PATH_ARROW_DOWN = "", ot.CHAR_MAZE_PATH_ARROW_LEFT = "", ot.CHAR_MAZE_PATH_GUARD = "";
    class ut {
        constructor(t, e) {
            this.trigger = t, this.value = e
        }
        upDate(t) {
            if (this.value !== t) {
                const e = this.value;
                this.value = t, this.trigger(t, e)
            }
        }
    }
    class ht extends Q {
        constructor(n) {
            super(n), this.tmpA = new e.Z;
            const i = t => {
                this.client.magicSystem.additionHealth -= t / 2, this.client.magicSystem.additionHealth <= 0 && n.exPlayer.removeHealth(n, 999)
            };
            this.desertRuinRules = new at(n), this.inRuinsListener = new ut((t => {
                t ? (this.desertRuinRules.init(), this.client.talentSystem.hasBeenDamaged.hasMonitor(i) || this.client.talentSystem.hasBeenDamaged.addMonitor(i), this.client.magicSystem.deleteActionbarPass("desertRuinMap")) : (this.client.magicSystem.additionHealth = 40, this.client.talentSystem.hasBeenDamaged.removeMonitor(i), this.desertRoomCounter.clear(), this.desertRuinRules.clear(), this.client.magicSystem.deleteActionbarPass("desertRuinMap"))
            }), !1), this.desertRoomCounter = new Map, this.desertRuinScoreJudge = new ut(((i, s) => {
                var r, a;
                const u = this.client.getServer().ruin_desertBoss;
                if (s && u.isInRoom(s)) {
                    let i = s.split(",").map((t => parseInt(t))),
                        r = new e.Z(i[0], i[1], i[2]).scl(16).add(J.DESERT_RUIN_LOCATION_START).add(8, 8, 8);
                    const a = new e.Z,
                        o = [];
                    for (let e of n.getDimension().getEntities({
                            excludeTypes: ["minecraft:item", t.MinecraftEntityTypes.player.id],
                            maxDistance: 16,
                            location: k.Z.getLocation(r)
                        })) r.clone().sub(a.set(e.location)).abs().toArray().every((t => t <= 8)) && (o.push(e.id), this.client.magicSystem.additionHealth -= 1, e.kill());
                    0 !== o.length && n.sayTo("b[]f" + o.length + ",  " + o.length + " ")
                }
                if (this.client.getServer().ruin_desertBoss.isInRoom(i)) {
                    this.desertRoomCounter.set(i, (null !== (r = this.desertRoomCounter.get(i)) && void 0 !== r ? r : 0) + 1);
                    let t = Math.max(-2, Math.floor(Math.random() * (5 + (n.player.location.y - J.DESERT_RUIN_LOCATION_START.y) / 12 - 2 * (null !== (a = this.desertRoomCounter.get(i)) && void 0 !== a ? a : 0))));
                    n.sayTo("b[]f" + this.desertRoomCounter.get(i) + "" + t);
                    let e = t;
                    for (; e >= 1;) n.sayTo("b[]f bl" + n.getLang()["ruinDesertCmd_" + this.desertRuinRules.randomAddRule()]), n.sayTo("b[]f bl" + n.getLang()["ruinDesertCmd_" + this.desertRuinRules.randomAddRule()]), e--;
                    this.client.magicSystem.additionHealth += t, Math.random() < .7 && this.desertRuinRules.show().then((e => {
                        let i = Math.floor(10 * Math.random()),
                            s = n.exPlayer.getPosition().div(16).floor().scl(16).add(8, 4, 8);
                        switch (i) {
                            case 0:
                            default:
                                break;
                            case 1:
                                for (; t + 1 > 0;) n.getExDimension().spawnEntity("wb:magic_book", s), n.getExDimension().spawnEntity("wb:magic_book", s), t -= 2;
                                break;
                            case 2:
                                for (; t + 1 > 0;) n.getExDimension().spawnEntity("wb:desert_insect", s), n.getExDimension().spawnEntity("wb:magic_book", s), n.getExDimension().spawnEntity("wb:magic_book", s), n.getExDimension().spawnEntity("wb:desert_chester_normal", s), t -= 2;
                                break;
                            case 3:
                                for (; t + 1 > 0;) n.getExDimension().spawnEntity("wb:desert_chester_high", s), n.getExDimension().spawnEntity("wb:desert_skeleton", s), n.getExDimension().spawnEntity("wb:desert_skeleton", s), n.getExDimension().spawnEntity("wb:desert_skeleton", s), n.getExDimension().spawnEntity("wb:desert_skeleton", s), t -= 2;
                                break;
                            case 4:
                                for (; t + 1 > 0;) n.getExDimension().spawnEntity("dec:stone_golem", s), n.getExDimension().spawnEntity("dec:stone_golem", s), n.getExDimension().spawnEntity("wb:desert_chester_high", s), t -= 4;
                                break;
                            case 5:
                                for (; t + 1 > 0;) n.getExDimension().spawnEntity("dec:stone_golem", s), n.getExDimension().spawnEntity("dec:stone_golem", s), n.getExDimension().spawnEntity("wb:desert_chester_high", s), t -= 4;
                                break;
                            case 6:
                                for (; t + 1 > 0;) n.getExDimension().spawnEntity("wb:desert_zombie", s), n.getExDimension().spawnEntity("wb:desert_zombie", s), n.getExDimension().spawnEntity("wb:desert_skeleton", s), t -= 2
                        }
                    })).catch((t => o.Z.throwError(t)))
                }
            }), "0,0,0")
        }
        getShowMap() {
            const t = [],
                e = this.client.exPlayer.getPosition().sub(J.DESERT_RUIN_LOCATION_START).div(16).floor();
            e.div(8, 1, 8).floor().scl(8, 1, 8);
            const n = this.client.exPlayer.getPosition().sub(J.DESERT_RUIN_LOCATION_START).div(16).floor(),
                i = e.clone(),
                s = e.clone().add(8, 0, 8),
                r = this.client.getServer().ruin_desertBoss;
            for (this.tmpA.set(this.client.getServer().ruinDesertGuardPos).sub(J.DESERT_RUIN_LOCATION_START).div(16).floor(); e.z < s.z; e.z++) {
                let a = [];
                for (e.x = i.x; e.x < s.x; e.x++) {
                    const t = `${e.x},${e.y},${e.z}`;
                    if (e.x === this.tmpA.x && e.y === this.tmpA.y && e.z === this.tmpA.z) a.push(ot.CHAR_MAZE_PATH_GUARD);
                    else if (e.x === n.x && e.z === n.z) {
                        const e = this.game.player.viewDirection;
                        r.isInRoom(t) ? e.x > e.z ? Math.abs(e.x) > Math.abs(e.z) ? a.push(ot.CHAR_MAZE_ROOM_ARROW_LEFT) : a.push(ot.CHAR_MAZE_ROOM_ARROW_DOWN) : Math.abs(e.x) > Math.abs(e.z) ? a.push(ot.CHAR_MAZE_ROOM_ARROW_RIGHT) : a.push(ot.CHAR_MAZE_ROOM_ARROW_UP) : r.isOnPath(t) ? e.x > e.z ? Math.abs(e.x) > Math.abs(e.z) ? a.push(ot.CHAR_MAZE_PATH_ARROW_LEFT) : a.push(ot.CHAR_MAZE_PATH_ARROW_DOWN) : Math.abs(e.x) > Math.abs(e.z) ? a.push(ot.CHAR_MAZE_PATH_ARROW_RIGHT) : a.push(ot.CHAR_MAZE_PATH_ARROW_UP) : a.push(ot.CHAR_MAZE_EMPTY)
                    } else r.isInRoom(t) ? this.desertRoomCounter.has(t) ? a.push(ot.CHAR_MAZE_ROOM_PASSED) : a.push(ot.CHAR_MAZE_ROOM) : r.isOnPath(t) ? a.push(ot.CHAR_MAZE_PATH) : a.push(ot.CHAR_MAZE_EMPTY)
                }
                t.unshift(a.reverse().join(""))
            }
            return t
        }
    }
    class lt {
        constructor() {
            this._alert = new st.MessageFormData, this.buttonEvent = [() => {}, () => {}]
        }
        body(t) {
            return this._alert.body(t), this
        }
        button1(t, e) {
            return this._alert.button1(t), this.buttonEvent[1] = e, this
        }
        button2(t, e) {
            return this._alert.button2(t), this.buttonEvent[0] = e, this
        }
        show(t) {
            return this._alert.show(t).then((t => {
                t.canceled || void 0 === t.selection || this.buttonEvent[t.selection]()
            })).catch((t => o.Z.throwError(t))), this
        }
        title(t) {
            return this._alert.title(t), this
        }
    }
    var ct = __webpack_require__(217);
    class pt {
        constructor(t, e, n, i) {
            this.deathTimes = 0, this.fogListener = new ut(((t, e) => {
                this.dim.command.run(`fog @a[x=${this.center.x},y=${this.center.y},z=${this.center.z},r=128] remove "ruin_fog"`), this.fog = t
            }), ""), this.players = new Map, this.area = n, this.center = n.center(), this.id = a.Z.randomUUID(), pt.map.set(this.id, this), this.dim = e;
            for (let i of e.getPlayers())
                if (n.contains(i.location)) {
                    this.players.set(i, !0);
                    let e = t.findClientByPlayer(i);
                    e && (e.ruinsSystem.barrier = this)
                } this.tickEvent = this.update.bind(this), this.server = t, this.manager = t.getEvents(), this.manager.register("onLongTick", this.tickEvent), this.boss = i
        }
        particle(t) {
            this.dim.spawnParticle(t, this.center)
        }
        static find(t) {
            for (let [e, n] of this.map)
                if (n.area.contains(t)) return n
        }
        setBoss(t) {
            this.boss = t
        }
        static isInBarrier(t) {
            return void 0 !== pt.find(t.location)
        }
        dispose() {
            pt.map.delete(this.id), this.manager.cancel("onLongTick", this.tickEvent);
            for (let t of this.clientsByPlayer()) t.ruinsSystem.barrier = void 0
        }* clientsByPlayer() {
            for (let t of this.players) {
                let e = this.server.findClientByPlayer(t[0]);
                e && (yield e)
            }
        }
        notifyDeathAdd() {
            this.deathTimes += 1;
            for (let t of this.clientsByPlayer()) t.ruinsSystem.deathTimes = this.deathTimes;
            this.deathTimes >= 3 && this.boss.onFail()
        }
        update() {
            this.dim.spawnParticle("wb:boss_barrier", this.center);
            for (let e of this.server.getPlayers()) e.location && (this.players.has(e) ? this.area.contains(e.location) ? this.players.set(e, !0) : this.players.get(e) && (this.server.setTimeout((() => {
                this.dim.dimension !== e.dimension && (e.addEffect(t.MinecraftEffectTypes.resistance, 280, 10, !0), e.addEffect(t.MinecraftEffectTypes.weakness, 280, 10, !0)), d.Z.getInstance(e).setPosition(this.area.center(), this.dim.dimension)
            }), 2e3), this.players.set(e, !1)) : this.area.contains(e.location) && e.kill());
            (0, o.W)((() => this.boss.entity.location)) && !this.area.contains(this.boss.entity.location) && this.boss.exEntity.setPosition(this.area.center()), this.fog && this.dim.command.run(`fog @a[x=${this.center.x},y=${this.center.y},z=${this.center.z},r=128] push ${this.fog} "ruin_fog"`)
        }
        stop() {
            this.dispose()
        }
        changeFog(t) {
            this.fogListener.upDate(t)
        }
    }
    pt.map = new Map;
    class dt extends q {
        constructor() {
            super(...arguments), this.i_inviolable = new S.C("i_inviolable"), this.i_damp = new S.C("i_damp"), this.i_soft = new S.C("i_soft"), this.desertRuinRules = new ht(this), this.isInRuinJudge = !1, this.causeDamage = 0, this.deathTimes = 0, this._causeDamageShow = !1, this.causeDamageType = new Set, this.causeDamageListenner = new ut(((t, e) => {
                t ? (this.causeDamageMonitor = this.client.talentSystem.hasCauseDamage.addMonitor(((t, e) => {
                    this.causeDamageType.has(e.typeId) && (this.causeDamage += t)
                })), this.deathTimesListener = t => {
                    var e;
                    this.exPlayer.getHealth() <= 0 && (null === (e = this.barrier) || void 0 === e || e.notifyDeathAdd())
                }, this.getEvents().exEvents.playerHurt.subscribe(this.deathTimesListener)) : (this.causeDamageMonitor && (this.client.talentSystem.hasCauseDamage.removeMonitor(this.causeDamageMonitor), this.causeDamageMonitor = void 0, this.client.magicSystem.deleteActionbarPass("hasCauseDamage")), this.deathTimesListener && (this.getEvents().exEvents.playerHurt.unsubscribe(this.deathTimesListener), this.deathTimesListener = void 0), this.deathTimes = 0, this.causeDamage = 0, this.causeDamageType.clear())
            }), !1), this.desertRuinBackJudge = new ut((n => {
                n && (new lt).title("").body("?").button1("", (() => {})).button2("", (() => {
                    let n = this.data.dimBackPoint;
                    n || (n = new e.Z(0, 255, 0)), this.exPlayer.setPosition(n, this.getDimension(t.MinecraftDimensionTypes.overworld))
                })).show(this.player)
            }), !1), this.stoneRuinBackJudge = new ut((n => {
                n && (new ct.Z).title("").body("").button("boss", (() => {
                    this.getExDimension().spawnEntity("wb:magic_stoneman", this.client.getServer().ruin_stoneBoss.getBossSpawnArea().center())
                })).button("", (() => {
                    let n = this.data.dimBackPoint;
                    n || (n = new e.Z(0, 255, 0)), this.exPlayer.setPosition(n, this.getDimension(t.MinecraftDimensionTypes.overworld))
                })).button("", (() => {})).show(this.player)
            }), !1), this.caveRuinBackJudge = new ut((n => {
                n && (new ct.Z).title("").body("").button("boss", (() => {
                    this.getExDimension().spawnEntity("wb:headless_guard", this.client.getServer().ruin_caveBoss.getBossSpawnArea().center())
                })).button("", (() => {
                    let n = this.data.dimBackPoint;
                    n || (n = new e.Z(0, 255, 0)), this.exPlayer.setPosition(n, this.getDimension(t.MinecraftDimensionTypes.overworld))
                })).button("", (() => {})).show(this.player)
            }), !1), this.ancientRuinBackJudge = new ut((n => {
                n && (new ct.Z).title("").body("").button("boss", (() => {
                    this.getExDimension().spawnEntity("wb:ancient_stone", this.client.getServer().ruin_ancientBoss.getBossSpawnArea().center())
                })).button("", (() => {
                    let n = this.data.dimBackPoint;
                    n || (n = new e.Z(0, 255, 0)), this.exPlayer.setPosition(n, this.getDimension(t.MinecraftDimensionTypes.overworld))
                })).button("", (() => {})).show(this.player)
            }), !1), this.mindRuinBackJudge = new ut((n => {
                n && (new ct.Z).title("").body("").button("boss", (() => {
                    this.getExDimension().spawnEntity("wb:intentions_first", this.client.getServer().ruin_mindBoss.getBossSpawnArea().center())
                })).button("", (() => {
                    let n = this.data.dimBackPoint;
                    n || (n = new e.Z(0, 255, 0)), this.exPlayer.setPosition(n, this.getDimension(t.MinecraftDimensionTypes.overworld))
                })).button("", (() => {})).show(this.player)
            }), !1), this.fogChange = new ut(((t, e) => {
                this.exPlayer.command.run('fog @s remove "ruin_fog"')
            }), "")
        }
        get causeDamageShow() {
            return this._causeDamageShow
        }
        set causeDamageShow(t) {
            this._causeDamageShow = t, this.causeDamageListenner.upDate(t)
        }
        onJoin() {
            const n = new e.Z;
            new e.Z, new e.Z, this.getEvents().exEvents.onLongTick.subscribe((i => {
                var s, r, a, o, u, h, l, c, p, d;
                if (i.currentTick % 4 != 0) return;
                n.set(this.player.location);
                let m, g = k.Z.getBlockLocation(n);
                g.y -= 1;
                try {
                    m = this.getDimension().getBlock(g)
                } catch (t) {}
                "wb:portal_desertboss" === (null == m ? void 0 : m.typeId) ? (this.data.dimBackPoint = new e.Z(this.player.location).add(3, 2, 3), this.client.cache.save(), this.exPlayer.setPosition(E.randomPoint(this.client.getServer().ruin_desertBoss.getPlayerSpawnArea(), 4), this.getDimension(t.MinecraftDimensionTypes.theEnd)), 0 == (this.globalSettings.ruinsExsitsData >> J.DESERT_RUIN_NUM & 1) && (this.client.getServer().ruin_desertBoss.generate(), this.globalSettings.ruinsExsitsData = this.globalSettings.ruinsExsitsData | 1 << J.DESERT_RUIN_NUM)) : "wb:portal_stoneboss" === (null == m ? void 0 : m.typeId) ? (this.data.dimBackPoint = new e.Z(this.player.location).add(3, 2, 3), this.client.cache.save(), this.player.addEffect(t.MinecraftEffectTypes.resistance, 200, 10, !0), this.exPlayer.setPosition(E.randomPoint(this.client.getServer().ruin_stoneBoss.getPlayerSpawnArea(), 0), this.getDimension(t.MinecraftDimensionTypes.theEnd)), 0 == (this.globalSettings.ruinsExsitsData >> J.STONE_RUIN_NUM & 1) && (this.client.getServer().ruin_stoneBoss.generate(), this.globalSettings.ruinsExsitsData = this.globalSettings.ruinsExsitsData | 1 << J.STONE_RUIN_NUM)) : "wb:portal_caveboss" === (null == m ? void 0 : m.typeId) ? (this.data.dimBackPoint = new e.Z(this.player.location).add(3, 2, 3), this.client.cache.save(), this.player.addEffect(t.MinecraftEffectTypes.resistance, 200, 10, !0), this.exPlayer.setPosition(E.randomPoint(this.client.getServer().ruin_caveBoss.getPlayerSpawnArea(), 0), this.getDimension(t.MinecraftDimensionTypes.theEnd)), 0 == (this.globalSettings.ruinsExsitsData >> J.CAVE_RUIN_NUM & 1) && (this.client.getServer().ruin_caveBoss.generate(), this.globalSettings.ruinsExsitsData = this.globalSettings.ruinsExsitsData | 1 << J.CAVE_RUIN_NUM)) : "wb:portal_ancientboss" === (null == m ? void 0 : m.typeId) ? (this.data.dimBackPoint = new e.Z(this.player.location).add(3, 2, 3), this.client.cache.save(), this.player.addEffect(t.MinecraftEffectTypes.resistance, 200, 10, !0), this.exPlayer.setPosition(E.randomPoint(this.client.getServer().ruin_ancientBoss.getPlayerSpawnArea(), 0), this.getDimension(t.MinecraftDimensionTypes.theEnd)), 0 == (this.globalSettings.ruinsExsitsData >> J.ANCIENT_RUIN_NUM & 1) && (this.client.getServer().ruin_ancientBoss.generate(), this.globalSettings.ruinsExsitsData = this.globalSettings.ruinsExsitsData | 1 << J.ANCIENT_RUIN_NUM)) : "wb:portal_mindboss" === (null == m ? void 0 : m.typeId) && (this.data.dimBackPoint = new e.Z(this.player.location).add(3, 2, 3), this.client.cache.save(), this.player.addEffect(t.MinecraftEffectTypes.resistance, 200, 10, !0), this.exPlayer.setPosition(E.randomPoint(this.client.getServer().ruin_mindBoss.getPlayerSpawnArea(), 0), this.getDimension(t.MinecraftDimensionTypes.theEnd)), 0 == (this.globalSettings.ruinsExsitsData >> J.MIND_RUIN_NUM & 1) && (this.client.getServer().ruin_mindBoss.generate(), this.globalSettings.ruinsExsitsData = this.globalSettings.ruinsExsitsData | 1 << J.MIND_RUIN_NUM)), pt.isInBarrier(this.player) || (this.desertRuinBackJudge.upDate(null !== (r = null === (s = this.client.getServer().ruin_desertBoss.getBossSpawnArea()) || void 0 === s ? void 0 : s.contains(n)) && void 0 !== r && r && this.player.dimension.id === t.MinecraftDimensionTypes.theEnd), this.stoneRuinBackJudge.upDate(null !== (o = null === (a = this.client.getServer().ruin_stoneBoss.getBossSpawnArea()) || void 0 === a ? void 0 : a.contains(n)) && void 0 !== o && o && this.player.dimension.id === t.MinecraftDimensionTypes.theEnd), this.caveRuinBackJudge.upDate(null !== (h = null === (u = this.client.getServer().ruin_caveBoss.getBossSpawnArea()) || void 0 === u ? void 0 : u.contains(n)) && void 0 !== h && h && this.player.dimension.id === t.MinecraftDimensionTypes.theEnd), this.ancientRuinBackJudge.upDate(null !== (c = null === (l = this.client.getServer().ruin_ancientBoss.getBossSpawnArea()) || void 0 === l ? void 0 : l.contains(n)) && void 0 !== c && c && this.player.dimension.id === t.MinecraftDimensionTypes.theEnd), this.mindRuinBackJudge.upDate(null !== (d = null === (p = this.client.getServer().ruin_mindBoss.getBossSpawnArea()) || void 0 === p ? void 0 : p.contains(n)) && void 0 !== d && d && this.player.dimension.id === t.MinecraftDimensionTypes.theEnd));
                let f = !1,
                    y = !1,
                    x = !1,
                    _ = !1,
                    b = !1;
                if (this.getDimension(t.MinecraftDimensionTypes.theEnd) === this.player.dimension && n.x >= J.DESERT_RUIN_LOCATION_START.x && n.x <= J.DESERT_RUIN_LOCATION_END.x && n.z >= J.DESERT_RUIN_LOCATION_START.z && n.z <= J.DESERT_RUIN_LOCATION_END.z) {
                    n.y < J.DESERT_RUIN_LOCATION_START.y - 2 && (n.y = J.DESERT_RUIN_LOCATION_START.y + 4, this.exPlayer.setPosition(n)), 3 <= n.x % 16 && n.x % 16 <= 13 && 3 <= n.z % 16 && n.z % 16 <= 13 && this.desertRuinRules.desertRuinScoreJudge.upDate(`${Math.floor((n.x-J.DESERT_RUIN_LOCATION_START.x)/16)},${Math.floor((n.y-J.DESERT_RUIN_LOCATION_START.y)/16)},${Math.floor((n.z-J.DESERT_RUIN_LOCATION_START.z)/16)}`), f = !0;
                    let t = [];
                    t = this.desertRuinRules.getShowMap(), this.client.magicSystem.setActionbarByPass("desertRuinMap", t)
                }
                if (this.desertRuinRules.inRuinsListener.upDate(f), this.getDimension(t.MinecraftDimensionTypes.theEnd) === this.player.dimension && n.x >= J.STONE_RUIN_LOCATION_START.x && n.x <= J.STONE_RUIN_LOCATION_END.x && n.z >= J.STONE_RUIN_LOCATION_START.z && n.z <= J.STONE_RUIN_LOCATION_END.z && (n.y < J.STONE_RUIN_LOCATION_START.y - 2 && (n.y = J.STONE_RUIN_LOCATION_START.y + 6, this.exPlayer.setPosition(n)), y = !0, this.exPlayer.command.run('fog @s push wb:ruin_stone_boss "ruin_fog"')), this.getDimension(t.MinecraftDimensionTypes.theEnd) === this.player.dimension && n.x >= J.CAVE_RUIN_LOCATION_START.x && n.x <= J.CAVE_RUIN_LOCATION_END.x && n.z >= J.CAVE_RUIN_LOCATION_START.z && n.z <= J.CAVE_RUIN_LOCATION_END.z && (x = !0, this.exPlayer.command.run('fog @s push wb:ruin_cave_boss "ruin_fog"')), this.getDimension(t.MinecraftDimensionTypes.theEnd) === this.player.dimension && n.x >= J.ANCIENT_RUIN_LOCATION_START.x && n.x <= J.ANCIENT_RUIN_LOCATION_END.x && n.z >= J.ANCIENT_RUIN_LOCATION_START.z && n.z <= J.ANCIENT_RUIN_LOCATION_END.z && (_ = !0, this.exPlayer.command.run('fog @s push wb:ruin_ancient_boss "ruin_fog"')), this.getDimension(t.MinecraftDimensionTypes.theEnd) === this.player.dimension && n.x >= J.MIND_RUIN_LOCATION_START.x && n.x <= J.MIND_RUIN_LOCATION_END.x && n.z >= J.MIND_RUIN_LOCATION_START.z && n.z <= J.MIND_RUIN_LOCATION_END.z && (b = !0), this.causeDamageShow) {
                    let t = this.client.magicSystem.registActionbarPass("hasCauseDamage");
                    t.push(`: ${this.deathTimes} `), t.push(`: ${this.causeDamage} `)
                }
                this.client.magicSystem.additionHealthShow = f, this.isInRuinJudge = f || y || x || _ || b, this.fogChange.upDate(`${f}-${y}-${x}-${_}-${b}`)
            })), this.getEvents().exEvents.onceItemUseOn.subscribe((n => {
                let i;
                try {
                    i = this.getDimension().getBlock(n.blockLocation)
                } catch (n) {}
                if ("wb:start_key" === n.item.typeId)
                    if ("wb:block_magic_equipment" === (null == i ? void 0 : i.typeId)) {
                        let i = this.client.getServer().portal_desertBoss;
                        const s = new e.Z(n.blockLocation).add(2, 2, 2),
                            r = new e.Z(n.blockLocation).sub(2, 0, 2);
                        let a = i.setArea(new E(r, s, !0)).setDimension(this.getDimension(t.MinecraftDimensionTypes.overworld)).find();
                        if (a) {
                            i.clone().analysis({
                                X: t.MinecraftBlockTypes.sandstone.id,
                                W: "wb:portal_desertboss",
                                Y: "wb:portal_desertboss",
                                A: t.MinecraftBlockTypes.air.id,
                                S: t.MinecraftBlockTypes.stoneBlockSlab2.id,
                                C: t.MinecraftBlockTypes.cobblestoneWall.id
                            }).putStructure(a);
                            const s = new e.Z(n.blockLocation).add(.5, .5, .5);
                            this.getExDimension().spawnParticle("wb:portal_desertboss_par1", s), this.getExDimension().spawnParticle("wb:portal_desertboss_par2", s)
                        }
                    } else if ("wb:block_energy_seal" === (null == i ? void 0 : i.typeId)) {
                    const i = new e.Z(n.blockLocation).add(2, 1, 2),
                        s = new e.Z(n.blockLocation).sub(2, 0, 2);
                    let r = this.client.getServer().portal_stoneBoss,
                        a = r.setArea(new E(s, i, !0)).setDimension(this.getDimension(t.MinecraftDimensionTypes.overworld)).find();
                    a && r.clone().analysis({
                        X: t.MinecraftBlockTypes.sandstone.id,
                        W: "wb:portal_stoneboss",
                        Y: "wb:portal_stoneboss",
                        S: t.MinecraftBlockTypes.cobblestoneWall.id,
                        A: t.MinecraftBlockTypes.air.id,
                        B: t.MinecraftBlockTypes.stonebrick.id
                    }).putStructure(a)
                } else if ("wb:block_energy_boundary" === (null == i ? void 0 : i.typeId)) {
                    const i = new e.Z(n.blockLocation).add(2, 1, 2),
                        s = new e.Z(n.blockLocation).sub(2, 0, 2);
                    let r = this.client.getServer().portal_caveBoss,
                        a = r.setArea(new E(s, i, !0)).setDimension(this.getDimension(t.MinecraftDimensionTypes.overworld)).find();
                    a && r.clone().analysis({
                        X: t.MinecraftBlockTypes.deepslateTiles.id,
                        W: "wb:portal_caveboss",
                        Y: "wb:portal_caveboss",
                        S: t.MinecraftBlockTypes.lantern.id,
                        A: t.MinecraftBlockTypes.air.id
                    }).putStructure(a)
                } else if ("wb:block_magic_ink" === (null == i ? void 0 : i.typeId)) {
                    const i = new e.Z(n.blockLocation).add(2, 1, 2),
                        s = new e.Z(n.blockLocation).sub(2, 0, 2);
                    let r = this.client.getServer().portal_ancientBoss,
                        a = r.setArea(new E(s, i, !0)).setDimension(this.getDimension(t.MinecraftDimensionTypes.overworld)).find();
                    a && r.clone().analysis({
                        X: t.MinecraftBlockTypes.chiseledDeepslate.id,
                        W: "wb:portal_ancientboss",
                        Y: "wb:portal_ancientboss",
                        S: t.MinecraftBlockTypes.verdantFroglight.id,
                        A: t.MinecraftBlockTypes.air.id,
                        B: t.MinecraftBlockTypes.mossyCobblestone.id
                    }).putStructure(a)
                } else if ("wb:block_senior_equipment" === (null == i ? void 0 : i.typeId)) {
                    const i = new e.Z(n.blockLocation).add(2, 1, 2),
                        s = new e.Z(n.blockLocation).sub(2, 0, 2);
                    let r = this.client.getServer().portal_mindBoss,
                        a = r.setArea(new E(s, i, !0)).setDimension(this.getDimension(t.MinecraftDimensionTypes.overworld)).find();
                    a && r.clone().analysis({
                        X: "wb:block_magic_equipment",
                        W: "wb:portal_mindboss",
                        Y: "wb:portal_mindboss",
                        S: "wb:block_magic_barrier",
                        A: t.MinecraftBlockTypes.air.id
                    }).putStructure(a)
                }
            }))
        }
        onLoaded() {}
        onLeave() {}
    }
    class mt {
        constructor(t) {
            this._block = t
        }
        static getInstance(t) {
            let e = t;
            return this.propertyNameCache in e ? e[this.propertyNameCache] : e[this.propertyNameCache] = new mt(e)
        }
        getPosition() {
            return new e.Z(this._block)
        }
        transTo(t) {
            n.Z.getInstance(this._block.dimension).setBlock(this.getPosition(), t)
        }
    }
    mt.propertyNameCache = "exCache";
    class gt {
        constructor(t) {
            this._item = t
        }
        getItem() {
            return this._item
        }
        static getInstance(t) {
            let e = t;
            return this.propertyNameCache in e ? e[this.propertyNameCache] : e[this.propertyNameCache] = new gt(e)
        }
        getLore() {
            var t;
            return null !== (t = this._item.getLore()) && void 0 !== t ? t : []
        }
        setLore(t) {
            -1 !== t.indexOf(" ") && t.splice(t.indexOf(" "), 1), this._item.setLore(0 == t.length ? [Math.random() > .9 ? "mojang nmsl" : " "] : t)
        }
        getComponent(t) {
            return this._item.getComponent(t)
        }
        hasComponent(t) {
            return this._item.hasComponent(t)
        }
        getEnchantsComponent() {
            return this.getComponent(t.ItemEnchantsComponent.componentId)
        }
        hasEnchantsComponent() {
            return this.hasComponent(t.ItemEnchantsComponent.componentId)
        }
    }
    gt.propertyNameCache = "exCache";
    class ft extends q {
        onJoin() {
            this.getEvents().exEvents.itemOnHandChange.subscribe((t => {
                const e = this.exPlayer.getBag();
                if (t.afterItem) {
                    let n = new K(gt.getInstance(t.afterItem));
                    if (null !== n.search("enchants")) {
                        for (let e of n.entries("enchants")) try {
                            this.player.runCommandAsync("enchant @s " + e[0].replace(/[A-Z]/g, (t => "_" + t.toLowerCase())) + " " + e[1])
                        } catch (t) {}
                        let i = e.getItemOnHand();
                        null != i && (n = new K(new gt(i)), n.delete("enchants"), this.exPlayer.getBag().setItem(this.player.selectedSlot, i))
                    }
                }
            })), this.getEvents().exEvents.onceItemUseOn.subscribe((n => {
                let i = new e.Z(n.blockLocation),
                    s = this.getExDimension().getBlock(i);
                if (s && s.typeId !== t.MinecraftBlockTypes.air.id)
                    if ("wb:block_translate" === s.typeId) {
                        n.cancel = !0;
                        let t = this.exPlayer.getBag(),
                            i = t.getItemOnHand(),
                            r = t.getItemOnHand();
                        i && r && "wb:book_cache" === i.typeId && (ft.blockTranslateData.set(new e.Z(s).toString(), i), mt.getInstance(s).transTo("wb:block_translate_book"), r.amount--, t.setItem(this.exPlayer.selectedSlot, r))
                    } else if ("wb:block_translate_book" === s.typeId) {
                    n.cancel = !0;
                    let r = this.exPlayer.getBag(),
                        a = r.getItemOnHand(),
                        o = ft.blockTranslateData.get(new e.Z(s).toString());
                    if (!o) return mt.getInstance(s).transTo("wb:block_translate");
                    if (a && 1 === a.amount) {
                        let n = gt.getInstance(a),
                            u = gt.getInstance(o);
                        o.data++;
                        let h = new gt(new t.ItemStack(o.data >= 4 ? t.MinecraftItemTypes.enchantedBook : t.Items.get("wb:book_cache")));
                        h.getItem().data = o.data;
                        let l = new K(h);
                        if (h.setLore([...n.getLore()]), n.hasEnchantsComponent()) {
                            for (let t of n.getEnchantsComponent().enchantments) l.setValueUseMap("enchants", t.type.id, t.level + "");
                            n.getEnchantsComponent().removeAllEnchantments()
                        }
                        if (l = new K(n), l.setLore([...u.getLore()]), u.hasEnchantsComponent()) {
                            for (let t of u.getEnchantsComponent().enchantments) l.setValueUseMap("enchants", t.type.id, t.level + "");
                            u.getEnchantsComponent().removeAllEnchantments()
                        }
                        ft.blockTranslateData.delete(new e.Z(s).toString()), mt.getInstance(s).transTo("wb:block_translate"), r.setItem(this.exPlayer.selectedSlot, a), this.getDimension().spawnItem(h.getItem(), k.Z.getBlockLocation(i).above())
                    }
                }
            }))
        }
        onLoaded() {}
        onLeave() {}
    }
    ft.blockTranslateData = new Map, __webpack_require__(437);
    class yt extends q {
        onJoin() {
            this.getEvents().exEvents.itemOnHandChange.subscribe((t => {
                var e, n;
                "epic:machanical_operator" === (null === (e = t.afterItem) || void 0 === e ? void 0 : e.typeId) || "epic:alliance_token" === (null === (n = t.afterItem) || void 0 === n ? void 0 : n.typeId) ? (this.listenCannonState = t => {
                    if (t.currentTick % 4 == 0) {
                        let t = this.client.magicSystem.getActionbarByPass("cannon_state");
                        null == t || t.clear();
                        for (let e of this.getDimension().getEntities({
                                location: k.Z.getLocation(this.player.location),
                                closest: 1,
                                maxDistance: 3,
                                type: "epic:cannon_cart"
                            })) {
                            let n = I.Z.getInstance(e);
                            switch (null == t || t.push(": " + n.nameTag), e.hasTag("wbmsyh") ? null == t || t.push("    = af =") : null == t || t.push("    = 4f ="), n.getVariant()) {
                                case 2:
                                    null == t || t.push("    : 3[]");
                                    break;
                                case 1:
                                    null == t || t.push("    : 6[]");
                                    break;
                                case 3:
                                    null == t || t.push("    : c[]")
                            }
                            switch (n.getMarkVariant()) {
                                case 1:
                                    null == t || t.push("    : 6[]");
                                    break;
                                case 2:
                                    null == t || t.push("    : 3[]");
                                    break;
                                case 3:
                                    null == t || t.push("    : c[]")
                            }
                        }
                    }
                }, this.getEvents().exEvents.onLongTick.subscribe(this.listenCannonState), this.client.magicSystem.registActionbarPass("cannon_state")) : this.listenCannonState && (this.client.magicSystem.deleteActionbarPass("cannon_state"), this.getEvents().exEvents.onLongTick.unsubscribe(this.listenCannonState), this.listenCannonState = void 0)
            }))
        }
        onLoaded() {}
        onLeave() {}
    }
    class xt extends q {
        constructor() {
            super(...arguments), this.additionHealthShow = !1, this.additionHealth = 40, this.scoresManager = this.exPlayer.getScoresManager(), this.wbflLooper = new L(this.getEvents(), (() => {
                this.scoresManager.getScore("wbfl") < 200 && this.scoresManager.addScoreAsync("wbfl", 2)
            })).delay(5e3), this.armorCoolingLooper = new L(this.getEvents(), (() => {
                this.scoresManager.getScore("wbkjlq") > 0 && this.scoresManager.removeScoreAsync("wbkjlq", 1)
            })).delay(1e3), this._anotherShow = [], this._mapShow = new Map, this.actionbarShow = new L(this.getEvents(), (() => {
                let t = [
                        [xt.AdditionHPChar, this.additionHealth / 100, !0, this.additionHealthShow, "HP"],
                        [xt.wbflChar, this.scoresManager.getScore("wbfl") / 200, !0, !0, "MP"],
                        [xt.weaponCoolingChar, this.scoresManager.getScore("wbwqlq") / 20, !1, !0, "CD"],
                        [xt.armorCoolingChar, this.scoresManager.getScore("wbkjlqcg") / 20, !1, !0, "CD"]
                    ],
                    e = [];
                for (let n of t) {
                    if (0 === n[1] && !n[2] || !n[3]) continue;
                    let t = "";
                    for (; n[1] >= .2;) n[1] -= .2, t += n[0][0];
                    for (n[1] < 0 && (n[1] = 0), t.length < 5 && (t += n[0][n[0].length - 1 - Math.floor(n[1] / (.2 / n[0].length))]); t.length < 5;) t += n[0][n[0].length - 1];
                    t = n[4] + ": " + t, e.push(t)
                }
                for (let t = 0; t < 100; t++) e.push("");
                e = e.concat(Array.from(this._mapShow.values()).map((t => t.join("\nr")))), this.exPlayer.titleActionBar(e.join("\nr"))
            })).delay(500)
        }
        registActionbarPass(t) {
            return this._mapShow.set(t, []), this.getActionbarByPass(t)
        }
        getActionbarSize() {
            return this._mapShow.size
        }
        getActionbarByPass(t) {
            return this._mapShow.get(t)
        }
        setActionbarByPass(t, e) {
            this._mapShow.set(t, e)
        }
        deleteActionbarPass(t) {
            this._mapShow.delete(t)
        }
        onJoin() {}
        onLoaded() {
            this.wbflLooper.start(), this.armorCoolingLooper.start(), this.actionbarShow.start()
        }
        onLeave() {}
        upDateByTalent(t) {
            var e, n, i;
            let s = this.exPlayer.getScoresManager();
            s.setScoreAsync("wbwqlqjs", Math.round(100 + (null !== (e = t.get(j.CHARGING)) && void 0 !== e ? e : 0))), this.wbflLooper.delay(5e3 / ((1 + (null !== (n = t.get(j.SOURCE)) && void 0 !== n ? n : 0) / 100) * (1 + 3 * s.getScore("wbdjcg") / 100))), this.armorCoolingLooper.delay(1 / (.001 * (1 + (null !== (i = t.get(j.RELOAD)) && void 0 !== i ? i : 0) / 100)))
        }
    }
    xt.weaponCoolingChar = "", xt.armorCoolingChar = "", xt.wbflChar = "", xt.AdditionHPChar = "";
    var _t = __webpack_require__(342);

    function bt(t, e, n) {
        if ((e = Math.round(Math.min(9999, e))) > 1e3) {
            let i = e - e % 1e3;
            t.spawnParticle("wb:show_damage_" + i, n), e -= i
        }
        if (e > 100) {
            let i = e - e % 100;
            t.spawnParticle("wb:show_damage_" + i, n), e -= i
        }
        t.spawnParticle("wb:show_damage_" + e, n)
    }
    class wt {
        constructor() {
            this.mixer = []
        }
        addMonitor(t) {
            return this.mixer.push(t), t
        }
        removeMonitor(t) {
            let e = this.mixer.indexOf(t); - 1 !== e && this.mixer.splice(e, 1)
        }
        hasMonitor(t) {
            return -1 !== this.mixer.indexOf(t)
        }
        trigger(...t) {
            for (let e of this.mixer) e(...t)
        }
    }
    class Tt extends q {
        constructor() {
            super(...arguments), this.strikeSkill = !0, this.talentRes = new Map, this.skillLoop = new L(this.getEvents(), (() => {
                var t;
                if (this.data.talent.occupation.id === W.ASSASSIN.id && (this.strikeSkill = !0), this.data.talent.occupation.id === W.PRIEST.id) {
                    let e = 999,
                        n = this.exPlayer;
                    for (let t of this.player.dimension.getPlayers({
                            maxDistance: 20,
                            location: k.Z.getLocation(this.player.location)
                        })) {
                        let i = d.Z.getInstance(t);
                        i.getHealth() < e && (e = i.getHealth(), n = i)
                    }
                    n.addHealth(this, null !== (t = this.talentRes.get(j.REGENERATE)) && void 0 !== t ? t : 0)
                }
            })).delay(1e4), this.hasBeenDamaged = new wt, this.hasCauseDamage = new wt
        }
        updateTalentRes() {
            this.talentRes.clear();
            for (let t of this.data.talent.talents) this.talentRes.set(t.id, G.calculateTalent(this.data.talent.occupation, t.id, t.level));
            this.client.magicSystem.upDateByTalent(this.talentRes), this.data.talent.occupation.id === W.PRIEST.id || this.data.talent.occupation.id === W.ASSASSIN.id ? this.skillLoop.start() : this.skillLoop.stop()
        }
        onJoin() {
            this.getEvents().exEvents.playerHitEntity.subscribe((t => {
                var e, n, i, s, r, a, o, u;
                let h = this.exPlayer.getBag().getItemOnHand(),
                    l = 0,
                    c = 0,
                    p = I.Z.getInstance(t.hurtEntity),
                    d = p.getPosition().distance(this.exPlayer.getPosition());
                if (h) {
                    let t = new K(gt.getInstance(h)),
                        e = F.zeroIfNaN(parseFloat((null !== (r = t.getValueUseMap("addition", j.getCharacter(this.getLang(), j.CLOAD_PIERCING))) && void 0 !== r ? r : "->0").split("->")[1]));
                    l += Math.min(64, d) / 64 * e / 100;
                    let n = F.zeroIfNaN(parseFloat((null !== (a = t.getValueUseMap("addition", j.getCharacter(this.getLang(), j.ARMOR_BREAKING))) && void 0 !== a ? a : "->0").split("->")[1]));
                    c += this.exPlayer.getMaxHealth() * n / 100;
                    let i = F.zeroIfNaN(parseFloat((null !== (o = t.getValueUseMap("addition", j.getCharacter(this.getLang(), j.SANCTION))) && void 0 !== o ? o : "->0").split("->")[1]));
                    l += (16 - Math.min(16, d)) / 16 * i / 100;
                    let s = F.zeroIfNaN(parseFloat((null !== (u = t.getValueUseMap("addition", j.getCharacter(this.getLang(), j.SUDDEN_STRIKE))) && void 0 !== u ? u : "->0").split("->")[1]));
                    h.typeId.startsWith("dec:") && (l += .4), this.strikeSkill && (this.data.talent.occupation.id === W.ASSASSIN.id && this.skillLoop.startOnce(), this.strikeSkill = !1, l += s / 100)
                } else {
                    let t = null !== (e = this.talentRes.get(j.CLOAD_PIERCING)) && void 0 !== e ? e : 0;
                    l += Math.min(64, d) / 64 * t / 100;
                    let r = null !== (n = this.talentRes.get(j.ARMOR_BREAKING)) && void 0 !== n ? n : 0;
                    c += this.exPlayer.getMaxHealth() * r / 100;
                    let a = null !== (i = this.talentRes.get(j.SANCTION)) && void 0 !== i ? i : 0;
                    l += (16 - Math.min(16, d)) / 16 * a / 100;
                    let o = null !== (s = this.talentRes.get(j.SUDDEN_STRIKE)) && void 0 !== s ? s : 0;
                    this.strikeSkill && (this.data.talent.occupation.id === W.ASSASSIN.id && this.skillLoop.startOnce(), this.strikeSkill = !1, l += o / 100)
                }
                let m = t.damage * l + c;
                this.globalSettings.damageShow && bt(this.getExDimension(), m, p.entity.location), this.hasCauseDamage.trigger(t.damage + m, t.hurtEntity), p.removeHealth(this, m)
            })), this.getEvents().exEvents.playerHurt.subscribe((t => {
                var e, n;
                let i = 0;
                i += ((null !== (e = this.exPlayer.getPreRemoveHealth()) && void 0 !== e ? e : 0) + t.damage) * (null !== (n = this.talentRes.get(j.DEFENSE)) && void 0 !== n ? n : 0) / 100, this.exPlayer.addHealth(this, i), this.hasBeenDamaged.trigger(t.damage - i, t.damageSource.damagingEntity)
            }));
            let t = t => {};
            this.getEvents().exEvents.itemOnHandChange.subscribe((e => {
                var n, i, s, r, a;
                let o = this.exPlayer.getBag();
                if (e.afterItem && function(t) {
                        if (t.startsWith("wb:sword_") || t.startsWith("wb:staff_")) return !0;
                        if (t.startsWith("minecraft:") && ("minecraft:bow" === t || "minecraft:cross_bow" === t || -1 !== t.indexOf("_sword"))) return !0;
                        if (t.startsWith("dec:")) {
                            if (t.endsWith("_sword") || t.endsWith("_dagger") || t.endsWith("_sickle") || t.endsWith("_staff") || t.endsWith("_axe") || t.endsWith("_battleaxe") || t.endsWith("flintlock") || t.startsWith("sword_of_") || t.endsWith("_dart")) return !0;
                            let e = ["bamboo_yataghan", "absolute_zero", "growth", "angel_purification", "blood_mare", "blue_of_the_sea", "candy_cane", "cudgel", "lollipop", "hard_lollipop", "mace", "long_bread", "scimitar", "sharp_coral", "village_guardian", "flare_magic_book", "snowball_magic_book", "wave_magic_book", "giant_ivy", "god_of_sun", "night_mare", "natura_spear", "radiate_spreader", "thunder_rapier", "ghost_summoner"];
                            for (let n of e)
                                if ("dec:" + n === t) return !0
                        }
                        return !1
                    }(e.afterItem.typeId)) {
                    const r = new K(e.afterItem);
                    G.calculateTalentToLore(this.data.talent.talents, this.data.talent.occupation, gt.getInstance(e.afterItem), this.getLang()), e.afterItem.typeId.startsWith("dec:") && r.setTag(": +40"), o.setItem(this.exPlayer.selectedSlot, e.afterItem);
                    let a = parseFloat(null !== (n = r.getValueUseMap("total", this.getLang().maxSingleDamage)) && void 0 !== n ? n : "0"),
                        u = parseFloat(null !== (i = r.getValueUseMap("total", this.getLang().maxSecondaryDamage)) && void 0 !== i ? i : "0"),
                        h = 0;
                    this.hasCauseDamage.removeMonitor(t), t = t => {
                        h += t, a = Math.ceil(Math.max(t, a))
                    }, this.hasCauseDamage.addMonitor(t), null === (s = this.equiTotalTask) || void 0 === s || s.stop(), (this.equiTotalTask = new L(this.getEvents(), (() => {
                        var t, n, i, s;
                        let l = !1;
                        u = Math.ceil(Math.max(u, h / 5)), h = 0, (null !== (t = r.getValueUseMap("total", this.getLang().maxSingleDamage)) && void 0 !== t ? t : "0") !== a + "" && (r.setValueUseMap("total", this.getLang().maxSingleDamage, a + ""), l = !0), (null !== (n = r.getValueUseMap("total", this.getLang().maxSecondaryDamage)) && void 0 !== n ? n : "0") !== u + "" && (r.setValueUseMap("total", this.getLang().maxSecondaryDamage, u + ""), l = !0), l && (null === (i = o.getItemOnHand()) || void 0 === i ? void 0 : i.typeId) === (null === (s = null == e ? void 0 : e.afterItem) || void 0 === s ? void 0 : s.typeId) && o.setItem(this.exPlayer.selectedSlot, e.afterItem)
                    })).delay(5e3)).start()
                } else null === (r = this.equiTotalTask) || void 0 === r || r.stop();
                this.exPlayer.triggerEvent("hp:" + Math.round(20 + (null !== (a = this.talentRes.get(j.VIENTIANE)) && void 0 !== a ? a : 0)))
            }))
        }
        onLoaded() {
            this.updateTalentRes(),
                function(t) {
                    let e, n, i, s;
                    s = "sdgdfhfacfhllyzsFsxdTLLBo", e = s[0] + s[7] + s[13] + s[20] + s[24], i = "%AF%B7%E5%8F%8A%E6%97%B6%E9%80%9A%E7%9F%A5%E6%88%91%E4%BB%AC%EF%BC%81", n = `%E6%9C%AC${s[7]}ddon%E7%94%B1${s[7]+s[7]}%E5%89%91%E4%BE%A0%E5%92%8C${s[22]}i${s[22]}e${s[13]}i%E5%88%B6%E4%BD%9C%EF%BC%8C%E8%8B%A5%E5%8F%91%E7%8E%B0%E5%85%B6%E4%BB`, t[e](decodeURIComponent((null != n ? n : 0) + "%96%E5%9C%B0%E6%96%B9%E4%BF%A1%E6%81%AF%E8%A2%AB%E4%BF%AE%E6%94%B9%E8%BF%87%E8%AF%B7%E5%8F%8A%E6%97%B6%E9%80%9A%E7%9F%A5%E6%88%91%E4%BB%AC%EF%BC%81")), t[e]((0, _t.L)("\\u0054\\u0068\\u0069\\u0073\\u0020\\u0061\\u0064\\u0064\\u006f\\u006e\\u0020\\u0069\\u0073\\u0020\\u006d\\u0061\\u0064\\u0065\\u0020\\u0062\\u0079\\u0020\\u0041\\u0041\\u0020\\u0073\\u0077\\u006f\\u0072\\u0064\\u0073\\u006d\\u0061\\u006e\\u0020\\u0061\\u006e\\u0064\\u0020\\u004c\\u0069\\u004c\\u0065\\u0079\\u0069\\u002e\\u0020\\u0049\\u0066\\u0020\\u0079\\u006f\\u0075\\u0020\\u0066\\u0069\\u006e\\u0064\\u0020\\u0074\\u0068\\u0061\\u0074\\u0020\\u0074\\u0068\\u0065\\u0020\\u0069\\u006e\\u0066\\u006f\\u0072\\u006d\\u0061\\u0074\\u0069\\u006f\\u006e\\u0020\\u0068\\u0061\\u0073\\u0020\\u0062\\u0065\\u0065\\u006e\\u0020\\u006d\\u006f\\u0064\\u0069\\u0066\\u0069\\u0065\\u0064\\u002c\\u0020\\u0070\\u006c\\u0065\\u0061\\u0073\\u0065\\u0020\\u0063\\u006f\\u006e\\u0074\\u0061\\u0063\\u0074\\u0020\\u0075\\u0073\\uff08\\u0020\\u0047\\u0069\\u0074\\u0068\\u0075\\u0062\\u0040\\u0041\\u0041\\u0073\\u0077\\u006f\\u0072\\u0064\\u006d\\u0061\\u006e\\u0020\\u006f\\u0072\\u0020\\u0054\\u0077\\u0069\\u0074\\u0074\\u0065\\u0072\\u0040\\u006c\\u0065\\u005f\\u006c\\u0079\\u0069\\u0069\\uff09"))
                }(this)
        }
        onLeave() {}
    }

    function vt(e) {
        return {
            name: "-",
            tasks: [{
                name: "",
                conditions: [{
                    name: "",
                    typeId: t.MinecraftItemTypes.wheat.id,
                    count: 64,
                    type: "item"
                }, {
                    name: "",
                    typeId: t.MinecraftItemTypes.carrot.id,
                    count: 64,
                    type: "item"
                }],
                rewards: [{
                    name: "",
                    count: 125,
                    unit: "",
                    type: "integral"
                }]
            }, {
                name: "",
                conditions: [{
                    name: "",
                    typeId: t.MinecraftItemTypes.potato.id,
                    count: 64,
                    type: "item"
                }, {
                    name: "",
                    typeId: t.MinecraftItemTypes.carrot.id,
                    count: 64,
                    type: "item"
                }],
                rewards: [{
                    name: "",
                    count: 125,
                    unit: "",
                    type: "integral"
                }]
            }, {
                name: "",
                conditions: [{
                    name: "",
                    typeId: t.MinecraftItemTypes.melonBlock.id,
                    count: 64,
                    type: "item"
                }],
                rewards: [{
                    name: "",
                    count: 125,
                    unit: "",
                    type: "integral"
                }]
            }, {
                name: "",
                conditions: [{
                    name: "",
                    typeId: t.MinecraftItemTypes.pumpkin.id,
                    count: 64,
                    type: "item"
                }],
                rewards: [{
                    name: "",
                    count: 125,
                    unit: "",
                    type: "integral"
                }]
            }, {
                name: "",
                conditions: [{
                    name: "",
                    typeId: t.MinecraftEntityTypes.zombie.id,
                    count: 8,
                    type: "kill"
                }, {
                    name: "",
                    typeId: t.MinecraftEntityTypes.creeper.id,
                    count: 2,
                    type: "kill"
                }, {
                    name: "",
                    typeId: t.MinecraftEntityTypes.blaze.id,
                    count: 2,
                    type: "kill"
                }],
                rewards: [{
                    name: "",
                    count: 125,
                    unit: "",
                    type: "integral"
                }]
            }, {
                name: "",
                conditions: [{
                    name: "",
                    typeId: "wb:station_upgrade_a",
                    count: 1,
                    type: "kill"
                }],
                rewards: [{
                    name: "",
                    count: 175,
                    unit: "",
                    type: "integral"
                }]
            }, {
                name: "",
                conditions: [{
                    name: "",
                    typeId: t.MinecraftEntityTypes.pig.id,
                    count: 3,
                    type: "kill"
                }, {
                    name: "",
                    typeId: t.MinecraftEntityTypes.cow.id,
                    count: 3,
                    type: "kill"
                }, {
                    name: "",
                    typeId: t.MinecraftEntityTypes.sheep.id,
                    count: 3,
                    type: "kill"
                }],
                rewards: [{
                    name: "",
                    count: 125,
                    unit: "",
                    type: "integral"
                }]
            }, {
                name: "",
                conditions: [{
                    name: "",
                    typeId: t.MinecraftItemTypes.log.id,
                    count: 64,
                    type: "break"
                }],
                rewards: [{
                    name: "",
                    count: 125,
                    unit: "",
                    type: "integral"
                }]
            }, {
                name: "",
                conditions: [{
                    name: "",
                    typeId: t.MinecraftItemTypes.stone.id,
                    count: 64,
                    type: "break"
                }],
                rewards: [{
                    name: "",
                    count: 125,
                    unit: "",
                    type: "integral"
                }]
            }, {
                name: "",
                conditions: [{
                    name: "",
                    typeId: t.MinecraftItemTypes.apple.id,
                    count: 3,
                    aux: 0,
                    type: "item"
                }],
                rewards: [{
                    name: "",
                    count: 125,
                    unit: "",
                    type: "integral"
                }]
            }, {
                name: "",
                conditions: [{
                    name: "",
                    typeId: t.MinecraftItemTypes.poisonousPotato.id,
                    count: 3,
                    aux: 0,
                    type: "item"
                }],
                rewards: [{
                    name: "",
                    count: 125,
                    unit: "",
                    type: "integral"
                }]
            }, {
                name: "",
                conditions: [{
                    name: "",
                    typeId: t.MinecraftItemTypes.rabbitStew.id,
                    count: 3,
                    type: "item"
                }],
                rewards: [{
                    name: "",
                    count: 125,
                    unit: "",
                    type: "integral"
                }]
            }, {
                name: "",
                conditions: [{
                    name: "",
                    typeId: t.MinecraftItemTypes.rottenFlesh.id,
                    count: 128,
                    type: "item"
                }],
                rewards: [{
                    name: "",
                    count: 125,
                    unit: "",
                    type: "integral"
                }]
            }, {
                name: "",
                conditions: [{
                    name: "",
                    typeId: t.MinecraftItemTypes.pumpkinPie.id,
                    count: 16,
                    type: "item"
                }],
                rewards: [{
                    name: "",
                    count: 125,
                    unit: "",
                    type: "integral"
                }]
            }, {
                name: "",
                conditions: [{
                    name: "",
                    typeId: "wb:book_cache",
                    count: 1,
                    type: "item"
                }],
                rewards: [{
                    name: "",
                    count: 125,
                    unit: "",
                    type: "integral"
                }]
            }, {
                name: "",
                conditions: [{
                    name: "",
                    typeId: "dec:soul",
                    count: 8,
                    type: "item"
                }],
                rewards: [{
                    name: "",
                    count: 125,
                    unit: "",
                    type: "integral"
                }]
            }]
        }
    }

    function Et(e) {
        return {
            name: "-",
            tasks: [{
                name: "",
                conditions: [{
                    name: "",
                    typeId: t.MinecraftItemTypes.wheat.id,
                    count: 128,
                    type: "item"
                }, {
                    name: "",
                    typeId: t.MinecraftItemTypes.pumpkin.id,
                    count: 64,
                    type: "item"
                }, {
                    name: "",
                    typeId: t.MinecraftItemTypes.melonSlice.id,
                    count: 128,
                    type: "item"
                }],
                rewards: [{
                    name: "",
                    count: 200,
                    unit: "",
                    type: "integral"
                }]
            }, {
                name: "",
                conditions: [{
                    name: "",
                    typeId: t.MinecraftItemTypes.potato.id,
                    count: 128,
                    type: "item"
                }, {
                    name: "",
                    typeId: t.MinecraftItemTypes.carrot.id,
                    count: 64,
                    type: "item"
                }, {
                    name: "",
                    typeId: t.MinecraftItemTypes.melonBlock.id,
                    count: 32,
                    type: "item"
                }],
                rewards: [{
                    name: "",
                    count: 200,
                    unit: "",
                    type: "integral"
                }]
            }, {
                name: "",
                conditions: [{
                    name: "",
                    typeId: t.MinecraftItemTypes.cookedChicken.id,
                    count: 64,
                    type: "item"
                }, {
                    name: "",
                    typeId: t.MinecraftItemTypes.cookedMutton.id,
                    count: 32,
                    type: "item"
                }, {
                    name: "",
                    typeId: t.MinecraftItemTypes.beef.id,
                    count: 32,
                    type: "item"
                }, {
                    name: "",
                    typeId: t.MinecraftItemTypes.cookedRabbit.id,
                    count: 6,
                    type: "item"
                }],
                rewards: [{
                    name: "",
                    count: 200,
                    unit: "",
                    type: "integral"
                }]
            }, {
                name: "",
                conditions: [{
                    name: "",
                    typeId: "dec:zombie_warrior",
                    count: 8,
                    type: "kill"
                }, {
                    name: "",
                    typeId: "dec:nether_creeper",
                    count: 4,
                    type: "kill"
                }, {
                    name: "",
                    typeId: "dec:ender_witch",
                    count: 2,
                    type: "kill"
                }],
                rewards: [{
                    name: "",
                    count: 225,
                    unit: "",
                    type: "integral"
                }]
            }, {
                name: "",
                conditions: [{
                    name: "",
                    typeId: "wb:station_upgrade_b",
                    count: 1,
                    type: "kill"
                }],
                rewards: [{
                    name: "",
                    count: 275,
                    unit: "",
                    type: "integral"
                }]
            }, {
                name: "!",
                conditions: [{
                    name: "",
                    typeId: t.MinecraftEntityTypes.pig.id,
                    count: 10,
                    type: "kill"
                }, {
                    name: "",
                    typeId: t.MinecraftEntityTypes.cow.id,
                    count: 12,
                    type: "kill"
                }, {
                    name: "",
                    typeId: t.MinecraftEntityTypes.sheep.id,
                    count: 9,
                    type: "kill"
                }],
                rewards: [{
                    name: "",
                    count: 200,
                    unit: "",
                    type: "integral"
                }]
            }, {
                name: "!",
                conditions: [{
                    name: "",
                    typeId: t.MinecraftItemTypes.log.id,
                    count: 128,
                    type: "break"
                }],
                rewards: [{
                    name: "",
                    count: 175,
                    unit: "",
                    type: "integral"
                }]
            }, {
                name: "",
                conditions: [{
                    name: "",
                    typeId: t.MinecraftItemTypes.stone.id,
                    count: 128,
                    type: "break"
                }],
                rewards: [{
                    name: "",
                    count: 175,
                    unit: "",
                    type: "integral"
                }]
            }, {
                name: "",
                conditions: [{
                    name: "",
                    typeId: t.MinecraftItemTypes.poisonousPotato.id,
                    count: 16,
                    type: "item"
                }],
                rewards: [{
                    name: "",
                    count: 225,
                    unit: "",
                    type: "integral"
                }]
            }, {
                name: "",
                conditions: [{
                    name: "",
                    typeId: t.MinecraftItemTypes.rabbitStew.id,
                    count: 5,
                    type: "item"
                }, {
                    name: "",
                    typeId: t.MinecraftItemTypes.mushroomStew.id,
                    count: 5,
                    type: "item"
                }],
                rewards: [{
                    name: "",
                    count: 225,
                    unit: "",
                    type: "integral"
                }]
            }, {
                name: "",
                conditions: [{
                    name: "",
                    typeId: "dec:zombie_brain",
                    count: 64,
                    type: "item"
                }],
                rewards: [{
                    name: "",
                    count: 200,
                    unit: "",
                    type: "integral"
                }]
            }, {
                name: "",
                conditions: [{
                    name: "",
                    typeId: t.MinecraftItemTypes.endCrystal.id,
                    count: 4,
                    type: "item"
                }],
                rewards: [{
                    name: "",
                    count: 250,
                    unit: "",
                    type: "integral"
                }]
            }, {
                name: "",
                conditions: [{
                    name: "",
                    typeId: "wb:book_cache",
                    count: 3,
                    type: "item"
                }],
                rewards: [{
                    name: "",
                    count: 250,
                    unit: "",
                    type: "integral"
                }]
            }, {
                name: "",
                conditions: [{
                    name: "",
                    typeId: "dec:soul",
                    count: 32,
                    type: "item"
                }],
                rewards: [{
                    name: "",
                    count: 250,
                    unit: "",
                    type: "integral"
                }]
            }, {
                name: "",
                conditions: [{
                    name: "",
                    typeId: "dec:sea_urchin",
                    count: 4,
                    type: "item"
                }],
                rewards: [{
                    name: "",
                    count: 225,
                    unit: "",
                    type: "integral"
                }]
            }]
        }
    }

    function At(e) {
        return {
            name: "-",
            tasks: [{
                name: "",
                conditions: [{
                    name: "",
                    typeId: t.MinecraftItemTypes.wheat.id,
                    count: 256,
                    type: "item"
                }, {
                    name: "",
                    typeId: t.MinecraftItemTypes.potato.id,
                    count: 256,
                    type: "item"
                }, {
                    name: "",
                    typeId: t.MinecraftItemTypes.pumpkin.id,
                    count: 64,
                    type: "item"
                }],
                rewards: [{
                    name: "",
                    count: 350,
                    unit: "",
                    type: "integral"
                }]
            }, {
                name: "",
                conditions: [{
                    name: "",
                    typeId: t.MinecraftItemTypes.wheat.id,
                    count: 128,
                    type: "item"
                }, {
                    name: "",
                    typeId: t.MinecraftItemTypes.potato.id,
                    count: 128,
                    type: "item"
                }, {
                    name: "",
                    typeId: t.MinecraftItemTypes.carrot.id,
                    count: 128,
                    type: "item"
                }, {
                    name: "",
                    typeId: t.MinecraftItemTypes.beetroot.id,
                    count: 128,
                    type: "item"
                }, {
                    name: "",
                    typeId: t.MinecraftItemTypes.melonBlock.id,
                    count: 64,
                    type: "item"
                }, {
                    name: "",
                    typeId: t.MinecraftItemTypes.pumpkin.id,
                    count: 64,
                    type: "item"
                }],
                rewards: [{
                    name: "",
                    count: 450,
                    unit: "",
                    type: "integral"
                }]
            }, {
                name: "",
                conditions: [{
                    name: "",
                    typeId: t.MinecraftItemTypes.cookedChicken.id,
                    count: 64,
                    type: "item"
                }, {
                    name: "",
                    typeId: t.MinecraftItemTypes.cookedMutton.id,
                    count: 64,
                    type: "item"
                }, {
                    name: "",
                    typeId: t.MinecraftItemTypes.cookedBeef.id,
                    count: 64,
                    type: "item"
                }, {
                    name: "",
                    typeId: t.MinecraftItemTypes.cookedRabbit.id,
                    count: 16,
                    type: "item"
                }, {
                    name: "",
                    typeId: t.MinecraftItemTypes.mushroomStew.id,
                    count: 3,
                    type: "item"
                }],
                rewards: [{
                    name: "",
                    count: 450,
                    unit: "",
                    type: "integral"
                }]
            }, {
                name: "",
                conditions: [{
                    name: "",
                    typeId: "dec:zombie_warrior",
                    count: 32,
                    type: "kill"
                }, {
                    name: "",
                    typeId: "dec:nether_creeper",
                    count: 8,
                    type: "kill"
                }, {
                    name: "",
                    typeId: "dec:ender_witch",
                    count: 6,
                    type: "kill"
                }, {
                    name: "",
                    typeId: "dec:stone_golem",
                    count: 3,
                    type: "kill"
                }, {
                    name: "",
                    typeId: "dec:obsidian_golem",
                    count: 2,
                    type: "kill"
                }],
                rewards: [{
                    name: "",
                    count: 450,
                    unit: "",
                    type: "integral"
                }]
            }, {
                name: "",
                conditions: [{
                    name: "",
                    typeId: "wb:station_upgrade_c",
                    count: 1,
                    type: "kill"
                }],
                rewards: [{
                    name: "",
                    count: 450,
                    unit: "",
                    type: "integral"
                }]
            }, {
                name: "",
                conditions: [{
                    name: "",
                    typeId: t.MinecraftEntityTypes.wither.id,
                    count: 1,
                    type: "kill"
                }],
                rewards: [{
                    name: "",
                    count: 600,
                    unit: "",
                    type: "integral"
                }]
            }, {
                name: "",
                conditions: [{
                    name: "",
                    typeId: t.MinecraftEntityTypes.pig.id,
                    count: 16,
                    type: "kill"
                }, {
                    name: "",
                    typeId: t.MinecraftEntityTypes.cow.id,
                    count: 20,
                    type: "kill"
                }, {
                    name: "",
                    typeId: t.MinecraftEntityTypes.sheep.id,
                    count: 16,
                    type: "kill"
                }],
                rewards: [{
                    name: "",
                    count: 400,
                    unit: "",
                    type: "integral"
                }]
            }, {
                name: "",
                conditions: [{
                    name: "",
                    typeId: t.MinecraftItemTypes.diamondOre.id,
                    count: 5,
                    type: "break"
                }, {
                    name: "",
                    typeId: t.MinecraftItemTypes.coalOre.id,
                    count: 64,
                    type: "break"
                }, {
                    name: "",
                    typeId: t.MinecraftItemTypes.goldOre.id,
                    count: 5,
                    type: "break"
                }],
                rewards: [{
                    name: "",
                    count: 500,
                    unit: "",
                    type: "integral"
                }]
            }, {
                name: "",
                conditions: [{
                    name: "",
                    typeId: t.MinecraftItemTypes.rabbitStew.id,
                    count: 8,
                    type: "item"
                }, {
                    name: "",
                    typeId: t.MinecraftItemTypes.mushroomStew.id,
                    count: 8,
                    type: "item"
                }, {
                    name: "",
                    typeId: "dec:apple_juice",
                    count: 2,
                    type: "item"
                }, {
                    name: "",
                    typeId: "dec:perch_cooked",
                    count: 32,
                    type: "item"
                }],
                rewards: [{
                    name: "",
                    count: 450,
                    unit: "",
                    type: "integral"
                }]
            }, {
                name: "",
                conditions: [{
                    name: "",
                    typeId: "wb:mineral_senior_equipment",
                    count: 5,
                    type: "item"
                }],
                rewards: [{
                    name: "",
                    count: 700,
                    unit: "",
                    type: "integral"
                }]
            }, {
                name: "",
                conditions: [{
                    name: "",
                    typeId: "wb:book_cache",
                    count: 7,
                    type: "item"
                }],
                rewards: [{
                    name: "",
                    count: 600,
                    unit: "",
                    type: "integral"
                }]
            }, {
                name: "",
                conditions: [{
                    name: "",
                    typeId: "dec:sea_urchin",
                    count: 4,
                    type: "item"
                }, {
                    name: "",
                    typeId: "dec:ender_fish",
                    count: 4,
                    type: "item"
                }, {
                    name: "",
                    typeId: "dec:a_piece_of_salmon",
                    count: 64,
                    type: "item"
                }, {
                    name: "",
                    typeId: "dec:gold_fish",
                    count: 4,
                    type: "item"
                }, {
                    name: "",
                    typeId: "dec:coal_fish",
                    count: 4,
                    type: "item"
                }, {
                    name: "",
                    typeId: "dec:diamond_fish",
                    count: 2,
                    type: "item"
                }],
                rewards: [{
                    name: "",
                    count: 600,
                    unit: "",
                    type: "integral"
                }]
            }]
        }
    }

    function It(e) {
        return {
            name: "-",
            tasks: [{
                name: "",
                conditions: [{
                    name: "",
                    typeId: t.MinecraftItemTypes.wheat.id,
                    count: 512,
                    type: "item"
                }, {
                    name: "",
                    typeId: t.MinecraftItemTypes.potato.id,
                    count: 512,
                    type: "item"
                }, {
                    name: "",
                    typeId: t.MinecraftItemTypes.carrot.id,
                    count: 512,
                    type: "item"
                }],
                rewards: [{
                    name: "",
                    count: 1250,
                    unit: "",
                    type: "integral"
                }]
            }, {
                name: "!!!",
                conditions: [{
                    name: "",
                    typeId: t.MinecraftItemTypes.cookedChicken.id,
                    count: 256,
                    type: "item"
                }, {
                    name: "",
                    typeId: t.MinecraftItemTypes.cookedMutton.id,
                    count: 256,
                    type: "item"
                }, {
                    name: "",
                    typeId: t.MinecraftItemTypes.cookedBeef.id,
                    count: 256,
                    type: "item"
                }, {
                    name: "",
                    typeId: t.MinecraftItemTypes.cookedRabbit.id,
                    count: 64,
                    type: "item"
                }],
                rewards: [{
                    name: "",
                    count: 1250,
                    unit: "",
                    type: "integral"
                }]
            }, {
                name: "",
                conditions: [{
                    name: "",
                    typeId: "dec:zombie_warrior",
                    count: 64,
                    type: "kill"
                }, {
                    name: "",
                    typeId: "dec:ender_witch",
                    count: 32,
                    type: "kill"
                }, {
                    name: "",
                    typeId: "dec:stone_golem",
                    count: 4,
                    type: "kill"
                }, {
                    name: "",
                    typeId: "dec:obsidian_golem",
                    count: 2,
                    type: "kill"
                }, {
                    name: "",
                    typeId: "dec:skeleton_warrior",
                    count: 64,
                    type: "kill"
                }],
                rewards: [{
                    name: "",
                    count: 1250,
                    unit: "",
                    type: "integral"
                }]
            }, {
                name: "",
                conditions: [{
                    name: "",
                    typeId: "wb:station_upgrade_x",
                    count: 1,
                    type: "kill"
                }],
                rewards: [{
                    name: "",
                    count: 800,
                    unit: "",
                    type: "integral"
                }]
            }, {
                name: "",
                conditions: [{
                    name: "",
                    typeId: t.MinecraftItemTypes.diamondOre.id,
                    count: 16,
                    type: "break"
                }, {
                    name: "",
                    typeId: t.MinecraftItemTypes.coalOre.id,
                    count: 64,
                    type: "break"
                }, {
                    name: "",
                    typeId: t.MinecraftItemTypes.goldOre.id,
                    count: 64,
                    type: "break"
                }, {
                    name: "",
                    typeId: t.MinecraftItemTypes.ironOre.id,
                    count: 64,
                    type: "break"
                }],
                rewards: [{
                    name: "",
                    count: 1500,
                    unit: "",
                    type: "integral"
                }]
            }, {
                name: "",
                conditions: [{
                    name: "",
                    typeId: "dec:sea_urchin",
                    count: 8,
                    type: "item"
                }, {
                    name: "",
                    typeId: "dec:ender_fish",
                    count: 12,
                    type: "item"
                }, {
                    name: "",
                    typeId: "dec:a_piece_of_salmon",
                    count: 64,
                    type: "item"
                }, {
                    name: "",
                    typeId: "dec:gold_fish",
                    count: 12,
                    type: "item"
                }, {
                    name: "",
                    typeId: "dec:coal_fish",
                    count: 16,
                    type: "item"
                }, {
                    name: "",
                    typeId: "dec:diamond_fish",
                    count: 6,
                    type: "item"
                }],
                rewards: [{
                    name: "",
                    count: 1050,
                    unit: "",
                    type: "integral"
                }]
            }, {
                name: "",
                conditions: [{
                    name: "",
                    typeId: t.MinecraftEntityTypes.enderDragon.id,
                    count: 1,
                    type: "kill"
                }],
                rewards: [{
                    name: "",
                    count: 3500,
                    unit: "",
                    type: "integral"
                }]
            }]
        }
    }
    class St {
        constructor(t, e, n, i) {
            this.id = t, n instanceof Array ? (this.commands = n, i && i instanceof Array ? this.commands = this.commands.concat(i) : this.commands.push('tellraw @s[tag=task_complete] { "rawtext" : [ { "translate" : "text.dec:task_' + t + '_complete.name" } ] }', 'tellraw @s[tag=!task_complete] { "rawtext" : [ { "translate" : "text.dec:task_fail.name" } ] }', 'loot give @s[tag=task_complete] loot "tasks/' + t + '"', "xp @s[tag=task_complete] " + e.toString(), "replaceitem entity @s[tag=task_complete] slot.weapon.mainhand 0 air", "tag @s remove task_complete")) : !i || i instanceof Array || (this.conditions = n, this.respond = i)
        }
        title() {
            return "text.dec:task_" + this.id + "_title.name"
        }
        body() {
            return "text.dec:task_" + this.id + "_body.name"
        }
        detect(t) {
            this.commands && t.command.run(this.commands), this.conditions && this.respond && this.conditions(t) && this.respond(t)
        }
    }
    let kt = [new St("000", 200, ["execute if entity @s[hasitem={location=slot.armor.head,item=dec:lava_helmet}] if entity @s[hasitem={location=slot.armor.chest,item=dec:lava_chestplate}] if entity @s[hasitem={location=slot.armor.legs,item=dec:lava_leggings}] if entity @s[hasitem={location=slot.armor.feet,item=dec:lava_boots}] run tag @s add task_complete"]), new St("001", 140, ["execute if entity @s[hasitem={location=slot.armor.head,item=dec:frozen_helmet}] if entity @s[hasitem={location=slot.armor.chest,item=dec:frozen_chestplate}] if entity @s[hasitem={location=slot.armor.legs,item=dec:frozen_leggings}] if entity @s[hasitem={location=slot.armor.feet,item=dec:frozen_boots}] run tag @s add task_complete"]), new St("002", 170, ["execute if entity @s[hasitem={location=slot.armor.head,item=dec:rupert_helmet}] if entity @s[hasitem={location=slot.armor.chest,item=dec:rupert_chestplate}] if entity @s[hasitem={location=slot.armor.legs,item=dec:rupert_leggings}] if entity @s[hasitem={location=slot.armor.feet,item=dec:rupert_boots}] run tag @s add task_complete"]), new St("003", 60, ["execute if entity @s[hasitem={location=slot.armor.head,item=dec:amethyst_helmet}] if entity @s[hasitem={location=slot.armor.chest,item=dec:amethyst_chestplate}] if entity @s[hasitem={location=slot.armor.legs,item=dec:amethyst_leggings}] if entity @s[hasitem={location=slot.armor.feet,item=dec:amethyst_boots}] run tag @s add task_complete"]), new St("004", 50, ["execute if entity @s[hasitem={location=slot.armor.head,item=dec:copper_helmet}] if entity @s[hasitem={location=slot.armor.chest,item=dec:copper_chestplate}] if entity @s[hasitem={location=slot.armor.legs,item=dec:copper_leggings}] if entity @s[hasitem={location=slot.armor.feet,item=dec:copper_boots}] run tag @s add task_complete"]), new St("005", 300, ["execute if entity @s[hasitem={location=slot.armor.head,item=dec:crying_helmet}] if entity @s[hasitem={location=slot.armor.chest,item=dec:crying_chestplate}] if entity @s[hasitem={location=slot.armor.legs,item=dec:crying_leggings}] if entity @s[hasitem={location=slot.armor.feet,item=dec:crying_boots}] run tag @s add task_complete"]), new St("006", 80, ["execute if entity @s[hasitem={location=slot.armor.head,item=dec:emerald_helmet}] if entity @s[hasitem={location=slot.armor.chest,item=dec:emerald_chestplate}] if entity @s[hasitem={location=slot.armor.legs,item=dec:emerald_leggings}] if entity @s[hasitem={location=slot.armor.feet,item=dec:emerald_boots}] run tag @s add task_complete"]), new St("007", 700, ["execute if entity @s[hasitem={location=slot.armor.head,item=dec:everlasting_winter_helmet}] if entity @s[hasitem={location=slot.armor.chest,item=dec:everlasting_winter_chestplate}] if entity @s[hasitem={location=slot.armor.legs,item=dec:everlasting_winter_leggings}] if entity @s[hasitem={location=slot.armor.feet,item=dec:everlasting_winter_boots}] run tag @s add task_complete"]), new St("008", 200, ["execute if entity @s[hasitem={location=slot.armor.head,item=dec:knight_helmet}] if entity @s[hasitem={location=slot.armor.chest,item=iron_chestplate}] if entity @s[hasitem={location=slot.armor.legs,item=iron_leggings}] if entity @s[hasitem={location=slot.armor.feet,item=iron_boots}] run tag @s add task_complete"]), new St("009", 100, ["execute if entity @s[hasitem={location=slot.armor.head,item=dec:witch_hat}] run tag @s add task_complete"])],
        Dt = kt.concat([]);
    const Lt = ["Ao", "Jf", "Sk", "Ch", "Om", "Bs", "Hd", "Oa", "Gx", "Xe"];

    function Ct(t) {
        return t.split(" ").map((t => Lt.indexOf(t))).join("")
    }

    function Mt(t, e, n) {
        t = F.clamp(t, 0, 1), t = Math.floor(4 * t * e);
        let i = Math.floor(t / 4),
            s = t % 4,
            r = e - i - 1,
            a = "";
        for (; i > 0;) a += n[0], i--;
        for (a.length < e && (a += n[4 - s]); r > 0;) a += n[4], r--;
        return a
    }
    let Ot = "";
    var Rt = function(t, e, n, i) {
            var s, r = arguments.length,
                a = r < 3 ? e : null === i ? i = Object.getOwnPropertyDescriptor(e, n) : i;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(t, e, n, i);
            else
                for (var o = t.length - 1; o >= 0; o--)(s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, n, a) : s(e, n)) || a);
            return r > 3 && a && Object.defineProperty(e, n, a), a
        },
        Nt = function(t, e) {
            if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(t, e)
        };
    class Pt {
        constructor(t, e) {
            this._isKilled = !1, this._entity = t, this.server = e, this._events = new f(this), this.init(e), this.onSpawn(), (0, x.B)(this.getEvents(), this), console.warn("track " + t.typeId)
        }
        get entity() {
            return this._entity
        }
        set entity(t) {
            this._entity = t
        }
        get exEntity() {
            return this._exEntity
        }
        set exEntity(t) {
            this._exEntity = t
        }
        setTimeout(t, e) {
            let n = 0,
                i = s => {
                    n += 1e3 * s.deltaTime, n > e && (this.getEvents().exEvents.tick.unsubscribe(i), t())
                };
            this.getEvents().exEvents.tick.subscribe(i)
        }
        init(t) {
            this.exEntity = I.Z.getInstance(this.entity)
        }
        onSpawn() {}
        onDestroy() {
            this.dispose()
        }
        dispose() {
            console.warn("dispose"), this.getEvents().cancelAll()
        }
        getEvents() {
            return this._events
        }
        onDespawn() {
            this.onDestroy()
        }
        onKilled(t) {
            this._isKilled = !0, this.onDestroy()
        }
    }
    Rt([(0, x.K)("tick", ((t, e) => {
        if (e.currentTick % 1 == 0) try {
            return void 0 === t.entity.dimension
        } catch (t) {
            return !0
        }
        return !1
    })), Nt("design:type", Function), Nt("design:paramtypes", []), Nt("design:returntype", void 0)], Pt.prototype, "onDestroy", null), Rt([(0, x.K)("onHurt", ((t, e) => t.exEntity.getHealth() <= 0 && !t._isKilled)), Nt("design:type", Function), Nt("design:paramtypes", [t.EntityHurtEvent]), Nt("design:returntype", void 0)], Pt.prototype, "onKilled", null);
    class $t extends Pt {
        constructor(t, e) {
            super(t, e), this.isFisrtCall = !1, this.startPos = this.exEntity.getPosition();
            let n = pt.find(this.startPos);
            n ? n.setBoss(this) : (this.isFisrtCall = !0, n = new pt(e, this.exEntity.getExDimension(), new E(this.startPos.clone().sub(32, 32, 32), this.startPos.clone().add(32, 32, 32), !0), this)), this.barrier = n, 0 === n.players.size ? (this.despawn(), this.stopBarrier(), this.destroyBossEntity()) : this.initBossEntity()
        }
        despawn() {
            this.entity.triggerEvent("minecraft:despawn")
        }
        onFail() {
            console.warn("onFail");
            for (let t of this.barrier.clientsByPlayer()) t.ruinsSystem.causeDamageShow = !1;
            this.stopBarrier(), this.destroyBossEntity(), this.server.say({
                rawtext: [{
                    translate: "text.dec:killed_by_boss.name"
                }]
            }), this.despawn()
        }
        onKilled(e) {
            this.destroyBossEntity(), e.cause === t.EntityDamageCause.suicide && this.stopBarrier(), super.onKilled(e)
        }
        onSpawn() {
            super.onSpawn()
        }
        stopBarrier() {
            this.barrier.stop()
        }
        destroyBossEntity() {}
        initBossEntity() {}
    }
    class Ut {
        constructor(t, e) {
            this.soundId = t;
            let n = e.split(":");
            this.long = 1e3 * (60 * parseInt(n[0]) + parseInt(n[1]))
        }
        loop(t, e, n) {
            this.stop(), this.play(e, n), this.looper = new L(t, (() => {
                this.play(e, n)
            })).delay(this.long), this.looper.start()
        }
        stop() {
            var e;
            null === (e = this.looper) || void 0 === e || e.stop(), t.world.getDimension(t.MinecraftDimensionTypes.overworld).runCommandAsync("stopsound @a " + this.soundId)
        }
        play(t, e) {
            console.warn(`play ${this.soundId} at ${e.x} ${e.y} ${e.z}`), (0, o.to)(t.command.run(`playsound ${this.soundId} @a[r=64,x=${e.x},y=${e.y},z=${e.z}] ${e.x} ${e.y} ${e.z} 0.5 1 0.5`))
        }
    }
    class Ft extends $t {
        constructor(t, e) {
            super(t, e), this.music = new Ut("music.wb.anger_of_ancient", "2:24")
        }
        initBossEntity() {
            this.setTimeout((() => {
                this.music.loop(this.server.getEvents(), this.exEntity.getExDimension(), this.entity.location)
            }), 500);
            for (let t of this.barrier.clientsByPlayer()) t.ruinsSystem.causeDamageShow = !0, t.ruinsSystem.causeDamageType.add(this.entity.typeId);
            !this.exEntity.hasIsBabyComponent() && this.isFisrtCall && this.server.say({
                rawtext: [{
                    translate: "text.wb:summon_ancient_stone.name"
                }]
            })
        }
        onSpawn() {
            super.onSpawn()
        }
        onKilled(t) {
            if (this.exEntity.hasIsBabyComponent()) {
                for (let t of this.barrier.clientsByPlayer()) t.progressTaskFinish(this.entity.typeId, t.ruinsSystem.causeDamage), t.ruinsSystem.causeDamageShow = !1;
                this.server.say({
                    rawtext: [{
                        translate: "text.wb:defeat_ancient_stone.name"
                    }]
                }), console.warn("onWin"), this.stopBarrier()
            }
            this.music.stop(), super.onKilled(t)
        }
        onFail() {
            this.music.stop(), super.onFail()
        }
    }
    Ft.typeId = "wb:ancient_stone";
    class Bt extends $t {
        constructor(t, e) {
            super(t, e), this.music = new Ut("music.wb.unknown_world", "2:16")
        }
        initBossEntity() {
            for (let t of this.barrier.clientsByPlayer()) t.ruinsSystem.causeDamageShow = !0, t.ruinsSystem.causeDamageType.add(this.entity.typeId);
            this.isFisrtCall && this.server.say({
                rawtext: [{
                    translate: "text.wb:summon_headless_guard.name"
                }]
            }), this.setTimeout((() => {
                this.music.loop(this.server.getEvents(), this.exEntity.getExDimension(), this.entity.location)
            }), 500)
        }
        onSpawn() {
            super.onSpawn()
        }
        onKilled(t) {
            for (let t of this.barrier.clientsByPlayer()) t.progressTaskFinish(this.entity.typeId, t.ruinsSystem.causeDamage), t.ruinsSystem.causeDamageShow = !1;
            this.server.say({
                rawtext: [{
                    translate: "text.wb:defeat_headless_guard.name"
                }]
            }), console.warn("onWin"), this.stopBarrier(), this.music.stop(), super.onKilled(t)
        }
        onFail() {
            this.music.stop(), super.onFail()
        }
    }
    Bt.typeId = "wb:headless_guard";
    var zt = function(t, e, n, i) {
            var s, r = arguments.length,
                a = r < 3 ? e : null === i ? i = Object.getOwnPropertyDescriptor(e, n) : i;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(t, e, n, i);
            else
                for (var o = t.length - 1; o >= 0; o--)(s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, n, a) : s(e, n)) || a);
            return r > 3 && a && Object.defineProperty(e, n, a), a
        },
        Vt = function(t, e) {
            if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(t, e)
        };
    class Kt extends $t {
        constructor(t, e) {
            super(t, e)
        }
        initBossEntity() {
            for (let t of this.barrier.clientsByPlayer()) t.ruinsSystem.causeDamageShow = !0, t.ruinsSystem.causeDamageType.add(this.entity.typeId);
            this.isFisrtCall && this.server.say({
                rawtext: [{
                    translate: "text.wb:summon_intentions.name"
                }]
            }), this.barrier.changeFog("wb:ruin_mind_1_boss")
        }
        onSpawn() {
            super.onSpawn()
        }
        onKilled(t) {
            super.onKilled(t)
        }
        onFail() {
            super.onFail()
        }
        onLongTick(t) {
            try {
                this.exEntity.hasIsChargedComponent() && this.barrier.particle("wb:ruin_mind_boss_resist_par")
            } catch (t) {
                o.Z.throwError(t)
            }
        }
    }
    Kt.typeId = "wb:intentions_first", zt([(0, x.K)("onLongTick"), Vt("design:type", Function), Vt("design:paramtypes", [t.TickEvent]), Vt("design:returntype", void 0)], Kt.prototype, "onLongTick", null);
    class Gt extends $t {
        constructor(t, e) {
            super(t, e)
        }
        initBossEntity() {
            for (let t of this.barrier.clientsByPlayer()) t.ruinsSystem.causeDamageShow = !0, t.ruinsSystem.causeDamageType.add(this.entity.typeId);
            this.barrier.changeFog("wb:ruin_mind_2_boss")
        }
        onSpawn() {
            super.onSpawn()
        }
        onKilled(t) {
            super.onKilled(t)
        }
        onFail() {
            super.onFail()
        }
        onLongTick(t) {
            try {
                this.exEntity.hasIsBabyComponent() ? (this.barrier.particle("wb:ruin_mind_boss_floor_par"), this.barrier.changeFog("wb:ruin_mind_3_boss")) : this.barrier.changeFog("wb:ruin_mind_2_boss")
            } catch (t) {
                o.Z.throwError(t)
            }
        }
    }
    Gt.typeId = "wb:intentions_second", zt([(0, x.K)("onLongTick"), Vt("design:type", Function), Vt("design:paramtypes", [t.TickEvent]), Vt("design:returntype", void 0)], Gt.prototype, "onLongTick", null);
    class jt extends $t {
        constructor(t, e) {
            super(t, e)
        }
        initBossEntity() {
            this.state = new ut((t => {
                switch (t) {
                    case 9:
                        this.exEntity.getExDimension().spawnParticle("wb:ruin_mind_boss_third_par", this.exEntity.getPosition());
                        break;
                    case 1:
                    case 2:
                    case 3:
                        this.exEntity.getExDimension().spawnParticle("wb:ruin_mind_boss_second_par", this.exEntity.getPosition())
                }
            }), 1), this.changeFog = new ut((t => {
                "wb:ruin_mind_5_boss" === t ? (this.barrier.changeFog("wb:ruin_mind_4_boss"), this.setTimeout((() => {
                    this.barrier.changeFog("wb:ruin_mind_5_boss")
                }), 5e3)) : this.barrier.changeFog(t)
            }), "");
            for (let t of this.barrier.clientsByPlayer()) t.ruinsSystem.causeDamageShow = !0, t.ruinsSystem.causeDamageType.add(this.entity.typeId);
            this.changeFog.upDate("wb:ruin_mind_5_boss")
        }
        onLongTick(t) {
            try {
                this.exEntity.hasIsBabyComponent() ? (this.barrier.particle("wb:ruin_mind_boss_floor_par"), this.changeFog.upDate("wb:ruin_mind_3_boss")) : this.changeFog.upDate("wb:ruin_mind_5_boss"), this.state.upDate(this.exEntity.getVariant())
            } catch (t) {
                o.Z.throwError(t)
            }
        }
        onSpawn() {
            super.onSpawn()
        }
        onKilled(t) {
            for (let t of this.barrier.clientsByPlayer()) t.progressTaskFinish(this.entity.typeId, t.ruinsSystem.causeDamage), t.ruinsSystem.causeDamageShow = !1;
            this.server.say({
                rawtext: [{
                    translate: "text.wb:defeat_intentions.name"
                }]
            }), console.warn("onWin"), this.stopBarrier(), super.onKilled(t)
        }
        onFail() {
            super.onFail()
        }
    }
    jt.typeId = "wb:intentions_third", zt([(0, x.K)("onLongTick"), Vt("design:type", Function), Vt("design:paramtypes", [t.TickEvent]), Vt("design:returntype", void 0)], jt.prototype, "onLongTick", null);
    class Wt extends $t {
        constructor(t, e) {
            super(t, e)
        }
        initBossEntity() {
            for (let t of this.barrier.clientsByPlayer()) t.ruinsSystem.causeDamageShow = !0, t.ruinsSystem.causeDamageType.add(this.entity.typeId);
            this.isFisrtCall && this.server.say({
                rawtext: [{
                    translate: "text.wb:summon_magic_stoneman.name"
                }]
            })
        }
        onSpawn() {
            super.onSpawn()
        }
        onKilled(t) {
            for (let t of this.barrier.clientsByPlayer()) t.progressTaskFinish(this.entity.typeId, t.ruinsSystem.causeDamage), t.ruinsSystem.causeDamageShow = !1;
            this.server.say({
                rawtext: [{
                    translate: "text.wb:defeat_magic_stoneman.name"
                }]
            }), console.warn("onWin"), this.stopBarrier(), super.onKilled(t)
        }
    }
    Wt.typeId = "wb:magic_stoneman";
    class Ht {
        constructor(t, e) {
            this.choose = [], this.pageNum = 0, this.maxPageNum = 4, this._uiJson = e, this._client = t
        }
        static getLabelViews(t) {
            let e = [];
            for (let n = 0; n < t.length; n++) e.push({
                type: "text",
                msg: t[n]
            });
            return e
        }
        getJSON() {
            return this._uiJson
        }
        showPage(t, e) {
            this.choose = [t, e];
            let n = this._uiJson[t].page;
            n instanceof Function && (n = n(this._client, this));
            let i = Object.keys(n).indexOf(e);
            if (-1 === i) throw new Error("Can't find page " + e);
            this.pageNum = Math.floor(i / this.maxPageNum), (0, o.to)(this.upDatePage())
        }
        upDatePage() {
            var t, e, n, i, s, r;
            return n = this, i = void 0, r = function*() {
                let n = this._uiJson[this.choose[0]].page;
                "function" == typeof n && (n = n(this._client, this));
                let i = n[this.choose[1]],
                    s = new ct.Z;
                s.body(this.choose.join(" -> ")), s.title("__pomAlertMenu");
                for (let t in this._uiJson)
                    if (t == this.choose[0]) s.button("top1_d", (() => {}), this._uiJson[t].img);
                    else {
                        const e = t;
                        s.button("top1", (() => {
                            this.choose[0] = e, this.choose[1] = this._uiJson[this.choose[0]].default, this.pageNum = 0, (0, o.to)(this.upDatePage())
                        }), this._uiJson[t].img)
                    } let r, a = Object.keys(n);
                if (a.length > this.maxPageNum) {
                    this.pageNum > 0 && s.button("top2", (() => {
                        this.pageNum -= 1, (0, o.to)(this.upDatePage())
                    }), "--  --"), r = a.slice(this.pageNum * this.maxPageNum, Math.min(a.length, (this.pageNum + 1) * this.maxPageNum));
                    let t = {};
                    for (let e of r) t[e] = n[e];
                    n = t
                }
                for (let t in n) {
                    let e = n[t].text;
                    if (t == this.choose[1]) s.button("top2_d", (() => {}), e);
                    else {
                        const n = t;
                        s.button("top2", (() => {
                            this.choose[1] = n, (0, o.to)(this.upDatePage())
                        }), e)
                    }
                }
                a.length > this.maxPageNum && this.maxPageNum * this.pageNum + 1 < a.length && s.button("top2", (() => {
                    this.pageNum += 1, (0, o.to)(this.upDatePage())
                }), "--  --");
                let u = i.page;
                if ("function" == typeof u) {
                    let t = u(this._client, this);
                    t instanceof Promise && (t = yield t), u = t
                }
                for (const n of u) switch (n.type) {
                    case "toggle":
                        n.state && s.button(n.type + "_" + (n.state(this._client, this, n) ? "on" : "off"), (() => {
                            n.function && n.function(this._client, this, n) && (0, o.to)(this.upDatePage())
                        }), n.msg);
                        break;
                    case "buttonList3":
                        3 === (null === (t = n.msgs) || void 0 === t ? void 0 : t.length) && 3 === (null === (e = n.buttons) || void 0 === e ? void 0 : e.length) && (s.button(n.type + "_1", (() => {
                            n.buttons && n.buttons[0](this._client, this, n) && (0, o.to)(this.upDatePage())
                        }), n.msgs[0]), s.button(n.type + "_2", (() => {
                            n.buttons && n.buttons[1](this._client, this, n) && (0, o.to)(this.upDatePage())
                        }), n.msgs[1]), s.button(n.type + "_3", (() => {
                            n.buttons && n.buttons[2](this._client, this, n) && (0, o.to)(this.upDatePage())
                        }), n.msgs[2]), s.button(n.type + "_4", (() => {}), " "));
                        break;
                    default:
                        s.button(n.type, (() => {
                            n.function && n.function(this._client, this, n) && (0, o.to)(this.upDatePage())
                        }), n.msg)
                }
                s.show(this._client.player)
            }, new((s = void 0) || (s = Promise))((function(t, e) {
                function a(t) {
                    try {
                        u(r.next(t))
                    } catch (t) {
                        e(t)
                    }
                }

                function o(t) {
                    try {
                        u(r.throw(t))
                    } catch (t) {
                        e(t)
                    }
                }

                function u(e) {
                    e.done ? t(e.value) : function(t) {
                        return t instanceof s ? t : new s((function(e) {
                            e(t)
                        }))
                    }(e.value).then(a, o)
                }
                u((r = r.apply(n, i || [])).next())
            }))
        }
    }
    class Xt extends q {
        constructor() {
            super(...arguments), this.recordDailyArray = new Set, this.recordProgressArray = new Set
        }
        progressTaskFinish(t, e) {
            this.data.tasks.progress.data[t] = e
        }
        show(t, e) {
            let n = new Ht(this.client, function(t) {
                t.getLang();
                let e = t.exPlayer.getBag().countAllItems();
                const n = vt(),
                    i = Et(),
                    s = At(),
                    r = It(),
                    a = {
                        main_dec_leavesgolem: {
                            name: "",
                            conditions: [{
                                name: "BOSS",
                                typeId: "dec:leaves_golem",
                                damage: 1,
                                type: "boss"
                            }],
                            rewards: [{
                                name: "",
                                count: 800,
                                unit: "",
                                type: "integral"
                            }]
                        },
                        main_dec_king_of_pillager: {
                            name: "",
                            conditions: [{
                                name: "BOSS",
                                typeId: "dec:king_of_pillager",
                                damage: 1,
                                type: "boss"
                            }],
                            rewards: [{
                                name: "",
                                count: 1300,
                                unit: "",
                                type: "integral"
                            }]
                        },
                        main_dec_abyssal_controller: {
                            name: "",
                            conditions: [{
                                name: "BOSS",
                                typeId: "dec:abyssal_controller",
                                damage: 1,
                                type: "boss"
                            }],
                            rewards: [{
                                name: "",
                                count: 2e3,
                                unit: "",
                                type: "integral"
                            }]
                        },
                        main_dec_predators: {
                            name: "",
                            conditions: [{
                                name: "BOSS",
                                typeId: "dec:predators",
                                damage: 1,
                                type: "boss"
                            }],
                            rewards: [{
                                name: "",
                                count: 2200,
                                unit: "",
                                type: "integral"
                            }]
                        },
                        main_dec_enchant_illager: {
                            name: "",
                            conditions: [{
                                name: "BOSS",
                                typeId: "dec:enchant_illager_2",
                                damage: 1,
                                type: "boss"
                            }],
                            rewards: [{
                                name: "",
                                count: 2200,
                                unit: "",
                                type: "integral"
                            }]
                        },
                        main_dec_evlghost: {
                            name: "",
                            conditions: [{
                                name: "BOSS",
                                typeId: "dec:everlasting_winter_ghast_1",
                                damage: 1,
                                type: "boss"
                            }],
                            rewards: [{
                                name: "",
                                count: 4e3,
                                unit: "",
                                type: "integral"
                            }]
                        },
                        main_dec_escaped_soul: {
                            name: "",
                            conditions: [{
                                name: "BOSS",
                                typeId: "dec:escaped_soul_entity",
                                damage: 1,
                                type: "boss"
                            }],
                            rewards: [{
                                name: "",
                                count: 4500,
                                unit: "",
                                type: "integral"
                            }]
                        },
                        main_dec_host_of_deep: {
                            name: "",
                            conditions: [{
                                name: "BOSS",
                                typeId: "dec:host_of_deep_2",
                                damage: 1,
                                type: "boss"
                            }],
                            rewards: [{
                                name: "",
                                count: 4500,
                                unit: "",
                                type: "integral"
                            }]
                        },
                        main_dec_ash_knight: {
                            name: "",
                            conditions: [{
                                name: "BOSS",
                                typeId: "dec:ash_knight",
                                damage: 1,
                                type: "boss"
                            }],
                            rewards: [{
                                name: "",
                                count: 3e3,
                                unit: "",
                                type: "integral"
                            }]
                        },
                        dragon: {
                            name: "",
                            conditions: [{
                                name: "",
                                typeId: "wb:magic_stoneman",
                                type: "boss_tag",
                                tagName: "wbstartkeyok"
                            }],
                            rewards: [{
                                name: "",
                                count: 8e3,
                                unit: "",
                                type: "integral"
                            }]
                        },
                        main_pom_1: {
                            name: "",
                            conditions: [{
                                name: "BOSS",
                                typeId: Wt.typeId,
                                damage: 100,
                                type: "boss"
                            }],
                            rewards: [{
                                name: "",
                                count: 6e3,
                                unit: "",
                                type: "integral"
                            }]
                        },
                        main_pom_2: {
                            name: "",
                            conditions: [{
                                name: "BOSS",
                                typeId: Bt.typeId,
                                damage: 300,
                                type: "boss"
                            }],
                            rewards: [{
                                name: "",
                                count: 8e3,
                                unit: "",
                                type: "integral"
                            }]
                        },
                        main_pom_3: {
                            name: "",
                            conditions: [{
                                name: "BOSS",
                                typeId: Ft.typeId,
                                damage: 400,
                                type: "boss"
                            }],
                            rewards: [{
                                name: "",
                                count: 1e4,
                                unit: "",
                                type: "integral"
                            }]
                        },
                        main_pom_4: {
                            name: "",
                            conditions: [{
                                name: "BOSS",
                                typeId: jt.typeId,
                                damage: 500,
                                type: "boss"
                            }],
                            rewards: [{
                                name: "",
                                count: 2e4,
                                unit: "",
                                type: "integral"
                            }]
                        }
                    };
                return {
                    dailyTask: {
                        text: "dailyTask",
                        default: "0/" + t.data.tasks.daily.all[0][0].toString(),
                        img: "textures/items/leaves_knife.png",
                        page: (t, a) => {
                            let o = {};
                            const u = t.data.tasks.daily;
                            let h = (t, n) => {
                                var i, s, r;
                                for (const a of u.all[t]) {
                                    let h = u.complete[t].includes(a),
                                        l = !0,
                                        c = 0,
                                        p = [{
                                            type: "text_title",
                                            msg: n.name + " " + n.tasks[a].name
                                        }, {
                                            type: "padding"
                                        }, {
                                            type: "text",
                                            msg: ""
                                        }];
                                    for (let t of n.tasks[a].rewards) p.push({
                                        type: "text",
                                        msg: "    " + t.name + " " + t.count + " " + t.unit
                                    });
                                    p.push({
                                        type: "padding"
                                    });
                                    for (let t of n.tasks[a].conditions) {
                                        let o = "",
                                            d = 0,
                                            m = "";
                                        "break" === t.type ? (d = null !== (i = u.cache[t.typeId]) && void 0 !== i ? i : 0, o = "") : "kill" === t.type ? (d = null !== (s = u.cache[t.typeId]) && void 0 !== s ? s : 0, o = "") : "item" === t.type && (o = "", d = null !== (r = e.get(t.typeId)) && void 0 !== r ? r : 0), d < t.count && (l = !1);
                                        let g = h ? 1 : Math.min(1, d / t.count);
                                        c += g / n.tasks[a].conditions.length, m = (d >= t.count || h ? "a" : "c") + ": " + o + " " + t.name + " " + (h ? t.count : d) + "/" + t.count + "\n", m += Mt(g, 10, Ot), p.push({
                                            type: "textWithBg",
                                            msg: m
                                        })
                                    }
                                    l && !h && p.push({
                                        type: "padding"
                                    }, {
                                        type: "button",
                                        msg: "",
                                        function: (i, s) => {
                                            var r;
                                            for (let t of n.tasks[a].rewards) "integral" === t.type && i.exPlayer.getScoresManager().addScoreAsync("wbdjjf", t.count);
                                            for (let t of n.tasks[a].conditions) "item" === t.type && i.exPlayer.getBag().clearItem(t.typeId, t.count);
                                            return e = i.exPlayer.getBag().countAllItems(), null === (r = i.data.tasks) || void 0 === r || r.daily.complete[t].push(a), !0
                                        }
                                    }), o[t + "/" + a] = {
                                        text: (h ? "a" : l ? "e" : "c") + n.tasks[a].name + ": " + (h ? "" : Math.round(100 * c) + ""),
                                        page: p
                                    }
                                }
                            };
                            return h(0, n), h(1, i), h(2, s), h(3, r), o
                        }
                    },
                    paperTask: {
                        text: "paperTask",
                        default: "1",
                        img: "textures/items/magic_scroll_blue.png",
                        page: (e, n) => {
                            let i = {},
                                s = t.exPlayer.getBag().getItemOnHand();
                            if (!s || 0 === s.getLore().length) return {
                                1: {
                                    text: "",
                                    page: [{
                                        type: "text",
                                        msg: ""
                                    }]
                                }
                            };
                            let r = s.getLore(),
                                a = 0;
                            for (let t of r) {
                                a++;
                                let e = [];
                                i[a] = {
                                    page: e,
                                    text: t
                                };
                                let n = Ct(t);
                                const s = Dt.findIndex((t => t.id === n));
                                if (-1 === s) throw new Error("Can't find task " + Ct(t));
                                let r = Dt[s];
                                e.push({
                                    type: "text_title",
                                    msg: r.title()
                                }, {
                                    type: "padding"
                                }, {
                                    type: "text",
                                    msg: r.body()
                                }, {
                                    type: "button",
                                    msg: "text.dec:task_complete_button.name",
                                    function: (t, e) => (r.detect(t.exPlayer), !1)
                                })
                            }
                            return i
                        }
                    },
                    progressTask: {
                        text: "progressTask",
                        default: "main_pom_1",
                        img: "textures/items/experience_book.png",
                        page: (t, n) => {
                            var i, s, r;
                            let o = {};
                            const u = t.data.tasks.progress;
                            for (const n in a) {
                                let h = a[n],
                                    l = u.complete.includes(n),
                                    c = !0,
                                    p = 0,
                                    d = [{
                                        type: "text_title",
                                        msg: h.name
                                    }, {
                                        type: "padding"
                                    }, {
                                        type: "text",
                                        msg: ""
                                    }];
                                for (let t of h.rewards) d.push({
                                    type: "text",
                                    msg: "    " + t.name + " " + t.count + " " + t.unit
                                });
                                d.push({
                                    type: "padding"
                                });
                                for (let e of h.conditions) {
                                    let n = "",
                                        a = 0,
                                        o = "";
                                    if ("boss" === e.type) {
                                        e.damage = null !== (i = e.damage) && void 0 !== i ? i : 1, a = null !== (s = u.data[e.typeId]) && void 0 !== s ? s : 0, n = "", a < e.damage && (c = !1);
                                        let t = l ? 1 : Math.min(1, a / e.damage);
                                        p += t / h.conditions.length, o = (a >= e.damage || l ? "a" : "c") + ": " + n + " " + e.name + " " + (l ? e.damage : a) + "/" + e.damage + "\n", o += Mt(t, 10, Ot)
                                    } else if ("boss_tag" === e.type) {
                                        e.tagName = null !== (r = e.tagName) && void 0 !== r ? r : "undefined", a = t.player.hasTag(e.tagName) ? 1 : 0, n = "", a < 1 && (c = !1);
                                        let i = l ? 1 : Math.min(1, a / 1);
                                        p += i / h.conditions.length, o = (a >= 1 || l ? "a" : "c") + ": " + n + " " + e.name + " " + (l ? 1 : a) + "/1\n", o += Mt(i, 10, Ot)
                                    }
                                    d.push({
                                        type: "textWithBg",
                                        msg: o
                                    })
                                }
                                c && !l && d.push({
                                    type: "padding"
                                }, {
                                    type: "button",
                                    msg: "",
                                    function: (t, i) => {
                                        for (let e of h.rewards) "integral" === e.type && t.exPlayer.getScoresManager().addScoreAsync("wbdjjf", e.count);
                                        return e = t.exPlayer.getBag().countAllItems(), u.complete.push(n), !0
                                    }
                                }), o[n] = {
                                    text: (l ? "a" : c ? "e" : "c") + h.name + ": " + (l ? "" : Math.round(100 * p) + ""),
                                    page: d
                                }
                            }
                            return o
                        }
                    }
                }
            }(this));
            t && e || (t = "dailyTask", e = n.getJSON()[t].default), n.showPage(t, e)
        }
        onJoin() {
            this.data.tasks || (this.data.tasks = {
                daily: {
                    complete: [
                        [],
                        [],
                        [],
                        []
                    ],
                    all: [
                        [],
                        [],
                        [],
                        []
                    ],
                    date: "1970-2-31",
                    cache: {}
                },
                progress: {
                    complete: [],
                    data: {}
                }
            });
            let t = new Date,
                e = `${t.getFullYear()}-${t.getMonth()}-${t.getDay()}`,
                n = t => Math.floor(t.length * Math.random()),
                i = vt(this.getLang()).tasks,
                s = Et(this.getLang()).tasks,
                r = At(this.getLang()).tasks,
                a = It(this.getLang()).tasks;
            this.data.tasks.daily.date !== e && (this.data.tasks.daily.all = [
                [n(i), n(i), n(i)],
                [n(s), n(s)],
                [n(r)],
                [n(a)]
            ], this.data.tasks.daily.complete = [
                [],
                [],
                [],
                []
            ], this.data.tasks.daily.cache = {}, this.data.tasks.daily.date = e);
            for (let t of i)
                for (let e of t.conditions) "break" !== e.type && "kill" !== e.type || this.recordDailyArray.add(e.typeId);
            for (let t of s)
                for (let e of t.conditions) "break" !== e.type && "kill" !== e.type || this.recordDailyArray.add(e.typeId);
            for (let t of r)
                for (let e of t.conditions) "break" !== e.type && "kill" !== e.type || this.recordDailyArray.add(e.typeId);
            for (let t of a)
                for (let e of t.conditions) "break" !== e.type && "kill" !== e.type || this.recordDailyArray.add(e.typeId);
            this.getEvents().exEvents.blockBreak.subscribe((t => {
                var e;
                this.data.tasks && this.recordDailyArray.has(t.brokenBlockPermutation.type.id) && (this.data.tasks.daily.cache[t.brokenBlockPermutation.type.id] = 1 + (null !== (e = this.data.tasks.daily.cache[t.brokenBlockPermutation.type.id]) && void 0 !== e ? e : 0))
            })), this.getEvents().exEvents.playerHitEntity.subscribe((t => {
                var e;
                this.data.tasks && this.recordDailyArray.has(t.hurtEntity.typeId) && I.Z.getInstance(t.hurtEntity).getHealth() < 0 && (this.data.tasks.daily.cache[t.hurtEntity.typeId] = 1 + (null !== (e = this.data.tasks.daily.cache[t.hurtEntity.typeId]) && void 0 !== e ? e : 0))
            }))
        }
        onLoaded() {}
        onLeave() {}
    }
    class Zt extends q {
        onJoin() {
            this.getEvents().exEvents.blockBreak.subscribe((n => {
                var i;
                n.brokenBlockPermutation.type.id !== t.MinecraftBlockTypes.log.id && n.brokenBlockPermutation.type.id !== t.MinecraftBlockTypes.log2.id || "wb:axex_equipment_a" !== (null === (i = this.exPlayer.getBag().getItemOnHand()) || void 0 === i ? void 0 : i.typeId) || this.chainDiggingLogs(new e.Z(n.block), !0)
            })), this.getEvents().exEvents.onceItemUseOn.subscribe((t => {
                "wb:technology_world_explorer" === t.item.typeId && this.sayTo(this.getExDimension().getBlock(t.blockLocation).typeId)
            })), this.getEvents().exEvents.itemUse.subscribe((n => {
                const {
                    item: i
                } = n;
                "wb:power" == i.typeId ? this.data.lang ? new Ht(this.client, function(t) {
                    return {
                        main: {
                            img: "textures/items/wet_paper",
                            text: t.menuUIMsgBailan1,
                            default: "notice",
                            page: {
                                notice: {
                                    text: t.menuUISubtitleGonggao,
                                    page: [{
                                        type: "img_adjustToScreen",
                                        msg: "textures/ui/title.png"
                                    }, {
                                        type: "padding"
                                    }, {
                                        type: "text",
                                        msg: t.menuUIMsgGonggao1
                                    }]
                                },
                                version: {
                                    text: t.menuUIMsgBailan5,
                                    page: (e, n) => [{
                                        type: "text_title",
                                        msg: t.menuUIMsgBanben1
                                    }, {
                                        type: "text",
                                        msg: t.menuUIMsgBanben2
                                    }, {
                                        type: "text",
                                        msg: s.Z.config.addonVersion
                                    }, {
                                        type: "text",
                                        msg: t.menuUIMsgBanben3
                                    }, {
                                        type: "text",
                                        msg: "https://aaswordman.github.io/ThePoetryOfWinter/"
                                    }, {
                                        type: "padding"
                                    }, {
                                        type: "text_title",
                                        msg: t.menuUIMsgBanben4
                                    }, {
                                        type: "padding"
                                    }, {
                                        type: "text",
                                        msg: t.menuUIMsgBanben5
                                    }, {
                                        type: "padding"
                                    }, {
                                        type: "text_title",
                                        msg: t.menuUIMsgBanben6
                                    }, {
                                        type: "padding"
                                    }].concat(Ht.getLabelViews("\n\n\nMain creator:   - LiLeyi   AAswordsman\nAssistants:  -  \nEnderghostScale  - \nhaveyouwantto - \nhuo - \nAR_UnryAllenCN - \n - \n - \n - \nQ - \nSpiffyTerror - \n - \n - \n - \n - \n - \n - \nDADA - \nFulankNorth cat - \n - \nKirisamePPSH - \nMiku4962 - \nMr. - \nHanyi - \n - \nKucerLuo - \nRepforce - \n - \n - \n - \nHim1025(kALE) - logoicon\nWINDes - \nALiFang ZHE - \n - \n - \n\nOur Team\n     (BlueMark Studio)\n\nSpecial Thanks\nBunBun    \n".split("\n")))
                                },
                                imp: {
                                    text: t.menuUIMsgBailan6,
                                    page: (t, e) => Ht.getLabelViews(X.split("\n"))
                                },
                                QA: {
                                    text: "Q & A",
                                    page: [{
                                        type: "padding"
                                    }, {
                                        type: "text_title",
                                        msg: t.menuUIMsgBailan103
                                    }, {
                                        type: "padding"
                                    }, {
                                        type: "text",
                                        msg: t.menuUIMsgBailan104
                                    }, {
                                        type: "padding"
                                    }, {
                                        type: "text_title",
                                        msg: t.menuUIMsgBailan7
                                    }, {
                                        type: "padding"
                                    }, {
                                        type: "text",
                                        msg: t.menuUIMsgBailan8
                                    }, {
                                        type: "padding"
                                    }, {
                                        type: "text_title",
                                        msg: t.menuUIMsgBailan9
                                    }, {
                                        type: "padding"
                                    }, {
                                        type: "text",
                                        msg: t.menuUIMsgBailan10
                                    }, {
                                        type: "padding"
                                    }, {
                                        type: "text_title",
                                        msg: t.menuUIMsgBailan11
                                    }, {
                                        type: "padding"
                                    }, {
                                        type: "text",
                                        msg: t.menuUIMsgBailan12
                                    }]
                                }
                            }
                        },
                        person: {
                            img: "textures/items/amethyst_chestplate.png",
                            text: t.menuUIMsgBailan13,
                            default: "info",
                            page: {
                                info: {
                                    text: t.menuUIMsgBailan14,
                                    page: (e, n) => {
                                        let i = e.player,
                                            s = d.Z.getInstance(i).getScoresManager(),
                                            r = [`   ${t.menuUIMsgBailan94}: ${e.gameId}`, `   ${t.menuUIMsgBailan96}: ${s.getScore("wbfl")}`, `   ${t.menuUIMsgBailan97}: ${s.getScore("wbwqlq")}`, `   ${t.menuUIMsgBailan98}: ${s.getScore("wbkjlqcg")}`, `   ${t.menuUIMsgBailan99}: ${i.hasTag("wbmsyh")?t.menuUIMsgBailan15:t.menuUIMsgBailan16}`, `   ${t.menuUIMsgBailan100}: ${i.hasTag("wbdjeff")?t.menuUIMsgBailan15:t.menuUIMsgBailan16}`],
                                            a = Ht.getLabelViews(r);
                                        a.unshift({
                                            type: "text_title",
                                            msg: ""
                                        });
                                        let o = s.getScore("wbdjcg"),
                                            u = s.getScore("wbdjjf");
                                        return a.push({
                                            type: "textWithBg",
                                            msg: `${t.menuUIMsgBailan95}: ${o} : ${u}/${150*Math.pow(o,2)+1050*o+900}\n${Mt((u-(150*Math.pow(o-1,2)+1050*(o-1)+900))/(300*o+900),10,Ot)}`
                                        }), a
                                    }
                                },
                                add: {
                                    text: t.menuUIMsgBailan19,
                                    page: [{
                                        type: "text_title",
                                        msg: t.menuUIMsgBailan20
                                    }, {
                                        type: "padding"
                                    }, {
                                        type: "text",
                                        msg: t.menuUIMsgBailan21
                                    }, {
                                        type: "padding"
                                    }, {
                                        type: "toggle",
                                        msg: t.menuUIMsgBailan22,
                                        state: (t, e) => t.player.hasTag("wbdjeff"),
                                        function: (t, e) => (t.player.hasTag("wbdjeff") ? t.player.removeTag("wbdjeff") : t.player.addTag("wbdjeff"), !0)
                                    }, {
                                        type: "padding"
                                    }, {
                                        type: "text_title",
                                        msg: t.menuUIMsgBailan23
                                    }, {
                                        type: "padding"
                                    }, {
                                        type: "text",
                                        msg: t.menuUIMsgBailan24
                                    }, {
                                        type: "padding"
                                    }, {
                                        type: "button",
                                        msg: t.menuUIMsgBailan25,
                                        function: (t, e) => (t.player.removeTag("pflame"), !0)
                                    }, {
                                        type: "button",
                                        msg: t.menuUIMsgBailan26,
                                        function: (t, e) => (t.player.removeTag("phalo"), !0)
                                    }, {
                                        type: "button",
                                        msg: t.menuUIMsgBailan27,
                                        function: (t, e) => (t.player.removeTag("prune"), !0)
                                    }, {
                                        type: "button",
                                        msg: t.menuUIMsgBailan28,
                                        function: (t, e) => (t.player.removeTag("plove"), !0)
                                    }]
                                },
                                talent: {
                                    text: t.menuUIMsgBailan29,
                                    page: (e, n) => {
                                        var i;
                                        let s;
                                        if (G.hasOccupation(e.data.talent)) {
                                            const n = 2 * e.exPlayer.getScoresManager().getScore("wbdjcg") - (null !== (i = e.data.talent.pointUsed) && void 0 !== i ? i : 0);
                                            s = [{
                                                type: "text",
                                                msg: t.menuUIMsgBailan30 + n
                                            }];
                                            for (let t of e.data.talent.talents) {
                                                s.push({
                                                    type: "text",
                                                    msg: G.getDescription(e.getLang(), e.data.talent.occupation, t.id, t.level)
                                                }, {
                                                    type: "textWithBg",
                                                    msg: j.getCharacter(e.getLang(), t.id) + ": " + t.level + "\n" + Mt(t.level / 40, 10, "")
                                                });
                                                let i = i => () => {
                                                    var s;
                                                    return n > 0 && t.level < 40 && (i = Math.min(Math.min(i, 40 - t.level), n), t.level += i, e.data.talent.pointUsed = i + (null !== (s = e.data.talent.pointUsed) && void 0 !== s ? s : 0), e.data.talent.talents.splice(e.data.talent.talents.findIndex((e => e.id === t.id)), 1), e.data.talent.talents.unshift(t), e.talentSystem.updateTalentRes()), !0
                                                };
                                                s.push({
                                                    type: "buttonList3",
                                                    msgs: ["+1", "+2", "+5"],
                                                    buttons: [i(1), i(2), i(5)]
                                                }, {
                                                    type: "padding"
                                                })
                                            }(!e.data.occupationChooseDate || (new Date).getTime() - e.data.occupationChooseDate >= 12096e5) && s.push({
                                                type: "button",
                                                msg: "",
                                                function: (t, e) => (t.data.occupationChooseDate = (new Date).getTime(), t.data.talent.occupation = W.EMPTY, t.data.talent.talents = [], t.data.talent.pointUsed = 0, t.talentSystem.updateTalentRes(), !0)
                                            })
                                        } else {
                                            s = [{
                                                type: "text_title",
                                                msg: t.menuUIMsgBailan31
                                            }, {
                                                type: "padding"
                                            }];
                                            for (const t of W.keys) s.push({
                                                type: "button",
                                                msg: t.getCharacter(e.getLang()),
                                                function: (e, n) => (G.chooseOccupation(e.data.talent, t), e.talentSystem.updateTalentRes(), !0)
                                            })
                                        }
                                        return s
                                    }
                                },
                                deathback: {
                                    text: t.menuUIMsgBailan32,
                                    page: (n, i) => {
                                        null == n.data.pointRecord && (n.data.pointRecord = {
                                            deathPoint: [],
                                            point: []
                                        });
                                        let s = [{
                                            type: "text_title",
                                            msg: t.menuUIMsgBailan33
                                        }, {
                                            type: "padding"
                                        }];
                                        if (n.globalSettings.tpPointRecord && !n.ruinsSystem.isInRuinJudge) {
                                            for (let i = 0; i < n.data.pointRecord.point.length; i++) {
                                                const r = n.data.pointRecord.point[i],
                                                    a = new e.Z(r[2]);
                                                s.push({
                                                    type: "textWithBg",
                                                    msg: t.menuUIMsgBailan34 + (r[0] + a.toString()) + "\n" + r[1]
                                                }, {
                                                    type: "buttonList3",
                                                    msgs: [t.menuUIMsgBailan35, t.menuUIMsgBailan38, t.menuUIMsgBailan40],
                                                    buttons: [(e, n) => {
                                                        let i = e.exPlayer.getBag();
                                                        if (!i.hasItem("wb:conveyor_issue") && e.globalSettings.tpNeedItem) return e.sayTo(t.menuUIMsgBailan36), !1;
                                                        if (e.globalSettings.tpNeedItem) {
                                                            let t = i.searchItem("wb:conveyor_issue"),
                                                                e = i.getItem(t);
                                                            e.amount--, i.setItem(t, e)
                                                        }
                                                        return e.exPlayer.setPosition(a, e.getDimension(r[0])), e.sayTo(t.menuUIMsgBailan37), !1
                                                    }, (e, n) => ((new st.ModalFormData).textField(t.menuUIMsgBailan39, r[0] + a.toString()).show(e.player).then((t => {
                                                        var e;
                                                        t.canceled || (r[1] = (null === (e = null == t ? void 0 : t.formValues) || void 0 === e ? void 0 : e[0]) || "")
                                                    })).catch((t => {
                                                        o.Z.throwError(t)
                                                    })), !1), (t, e) => {
                                                        var n;
                                                        return null === (n = t.data.pointRecord) || void 0 === n || n.point.splice(i, 1), !0
                                                    }]
                                                }, {
                                                    type: "padding"
                                                })
                                            }
                                            s.push({
                                                msg: t.menuUIMsgBailan41 + n.exPlayer.getPosition().floor().toString(),
                                                type: "button",
                                                function: (t, e) => {
                                                    var n;
                                                    return null === (n = t.data.pointRecord) || void 0 === n || n.point.push([t.exPlayer.getDimension().id, "", t.exPlayer.getPosition().floor()]), !0
                                                }
                                            })
                                        } else s.push({
                                            type: "text",
                                            msg: t.menuUIMsgBailan42
                                        });
                                        return s
                                    }
                                },
                                other: {
                                    text: "",
                                    page: [{
                                        type: "button",
                                        msg: "",
                                        function: (t, e) => (t.taskUI(), !1)
                                    }, {
                                        type: "button",
                                        msg: "",
                                        function: (t, e) => (t.taskUI(), !1)
                                    }]
                                }
                            }
                        },
                        social: {
                            img: "textures/items/gingerbread_totem.png",
                            text: t.menuUIMsgBailan46,
                            default: "setting",
                            page: {
                                setting: {
                                    text: t.menuUIMsgBailan47,
                                    page: [{
                                        type: "text_title",
                                        msg: t.menuUIMsgBailan48
                                    }, {
                                        type: "padding"
                                    }, {
                                        type: "text",
                                        msg: t.menuUIMsgBailan49
                                    }, {
                                        type: "text",
                                        msg: t.menuUIMsgBailan50
                                    }, {
                                        type: "padding"
                                    }, {
                                        type: "button",
                                        msg: t.menuUIMsgBailan51,
                                        function: (t, e) => (t.player.addTag("wbmsyh"), t.player.nameTag.startsWith("") && (t.player.nameTag = t.player.nameTag.substring(2)), t.player.nameTag = "a" + t.player.nameTag, !0)
                                    }, {
                                        type: "button",
                                        msg: t.menuUIMsgBailan48,
                                        function: (t, e) => (t.player.removeTag("wbmsyh"), t.player.nameTag.startsWith("") && (t.player.nameTag = t.player.nameTag.substring(2)), t.player.nameTag = "c" + t.player.nameTag, !0)
                                    }]
                                },
                                tp: {
                                    text: t.menuUIMsgBailan53,
                                    page: (e, n) => {
                                        return i = this, s = void 0, a = function*() {
                                            var n;
                                            if (!e.globalSettings.playerCanTp || e.ruinsSystem.isInRuinJudge) return [{
                                                type: "text",
                                                msg: t.menuUIMsgBailan54
                                            }];
                                            let i = [];
                                            i.push({
                                                msg: t.menuUIMsgBailan55,
                                                type: "text_title"
                                            }), i.push({
                                                type: "padding"
                                            });
                                            let s = null !== (n = yield e.getPlayersAndIds()) && void 0 !== n ? n : [];
                                            for (const e of s) {
                                                const n = d.Z.getInstance(e[0]);
                                                i.push({
                                                    type: "button",
                                                    msg: `${n.nameTag} pos:${n.getPosition().floor()}`,
                                                    function: (i, s) => {
                                                        let r = i.exPlayer.getBag();
                                                        if (!r.hasItem("wb:conveyor_issue") && i.globalSettings.tpNeedItem) return i.sayTo(t.menuUIMsgBailan36), !1;
                                                        if (i.globalSettings.tpNeedItem) {
                                                            let t = r.searchItem("wb:conveyor_issue"),
                                                                e = r.getItem(t);
                                                            e.amount--, r.setItem(t, e)
                                                        }
                                                        return i.sayTo(t.menuUIMsgBailan57), (new lt).title(t.menuUIMsgBailan58).body(` ${i.player.nameTag} r`).button1(t.menuUIMsgBailan15, (() => {
                                                            i.sayTo(t.menuUIMsgBailan37), i.sayTo(t.menuUIMsgBailan37, e[0]), i.exPlayer.setPosition(n.getPosition(), n.getDimension())
                                                        })).button2(t.menuUIMsgBailan16, (() => {
                                                            i.sayTo(t.menuUIMsgBailan63), i.sayTo(t.menuUIMsgBailan64, e[0])
                                                        })).show(e[0]), !1
                                                    }
                                                })
                                            }
                                            i.push({
                                                msg: t.menuUIMsgBailan65,
                                                type: "text_title"
                                            }), i.push({
                                                type: "padding"
                                            });
                                            for (const e of s) {
                                                const n = d.Z.getInstance(e[0]);
                                                i.push({
                                                    type: "button",
                                                    msg: `${n.nameTag} (pos:${n.getPosition().floor()})`,
                                                    function: (i, s) => {
                                                        let r = i.exPlayer.getBag();
                                                        if (!r.hasItem("wb:conveyor_issue") && i.globalSettings.tpNeedItem) return i.sayTo(t.menuUIMsgBailan36), !1;
                                                        if (i.getServer().findClientByPlayer(e[0]).ruinsSystem.isInRuinJudge) return i.sayTo("b"), !1;
                                                        if (i.globalSettings.tpNeedItem) {
                                                            let t = r.searchItem("wb:conveyor_issue"),
                                                                e = r.getItem(t);
                                                            e.amount--, r.setItem(t, e)
                                                        }
                                                        return i.sayTo(t.menuUIMsgBailan67), (new lt).title(t.menuUIMsgBailan58).body(` ${i.player.nameTag} r pos:${i.exPlayer.getPosition().floor()} `).button1(t.menuUIMsgBailan15, (() => {
                                                            i.sayTo(t.menuUIMsgBailan37), i.sayTo(t.menuUIMsgBailan37, e[0]), n.setPosition(i.exPlayer.getPosition(), i.exPlayer.getDimension())
                                                        })).button2(t.menuUIMsgBailan16, (() => {
                                                            i.sayTo(t.menuUIMsgBailan73), i.sayTo(t.menuUIMsgBailan74, e[0])
                                                        })).show(e[0]), !1
                                                    }
                                                })
                                            }
                                            return i
                                        }, new((r = void 0) || (r = Promise))((function(t, e) {
                                            function n(t) {
                                                try {
                                                    u(a.next(t))
                                                } catch (t) {
                                                    e(t)
                                                }
                                            }

                                            function o(t) {
                                                try {
                                                    u(a.throw(t))
                                                } catch (t) {
                                                    e(t)
                                                }
                                            }

                                            function u(e) {
                                                e.done ? t(e.value) : function(t) {
                                                    return t instanceof r ? t : new r((function(e) {
                                                        e(t)
                                                    }))
                                                }(e.value).then(n, o)
                                            }
                                            u((a = a.apply(i, s || [])).next())
                                        }));
                                        var i, s, r, a
                                    }
                                }
                            }
                        },
                        setting: {
                            img: "textures/items/artificial_meat_creator_on.png",
                            text: t.menuUIMsgBailan75,
                            default: "op",
                            page: {
                                personal: {
                                    text: t.menuUIMsgBailan101,
                                    page: [{
                                        type: "button",
                                        msg: t.menuUIMsgBailan102,
                                        function: (t, e) => ((new st.ModalFormData).title("Choose a language").dropdown("Language List", ["English", ""], 0).show(t.player).then((e => {
                                            e.canceled || (t.data.lang = e.formValues && 0 == e.formValues[0] ? "en" : "zh")
                                        })).catch((t => {
                                            o.Z.throwError(t)
                                        })), !1)
                                    }]
                                },
                                op: {
                                    text: t.menuUIMsgBailan76,
                                    page: (e, n) => e.player.hasTag("owner") ? [{
                                        type: "text_title",
                                        msg: t.menuUIMsgBailan77
                                    }, {
                                        type: "toggle",
                                        msg: t.menuUIMsgBailan78,
                                        state: (t, e) => t.globalSettings.playerCanTp,
                                        function: (t, e) => (t.globalSettings.playerCanTp = !t.globalSettings.playerCanTp, !0)
                                    }, {
                                        type: "toggle",
                                        msg: t.menuUIMsgBailan79,
                                        state: (t, e) => t.globalSettings.tpNeedItem,
                                        function: (t, e) => (t.globalSettings.tpNeedItem = !t.globalSettings.tpNeedItem, !0)
                                    }, {
                                        type: "toggle",
                                        msg: t.menuUIMsgBailan80,
                                        state: (t, e) => t.globalSettings.entityCleaner,
                                        function: (t, e) => (t.globalSettings.entityCleaner = !t.globalSettings.entityCleaner, t.getServer().upDateEntityCleaner(), !0)
                                    }, {
                                        type: "toggle",
                                        msg: t.menuUIMsgBailan82,
                                        state: (t, e) => t.globalSettings.tpPointRecord,
                                        function: (t, e) => (t.globalSettings.tpPointRecord = !t.globalSettings.tpPointRecord, !0)
                                    }, {
                                        type: "toggle",
                                        msg: "",
                                        state: (t, e) => t.globalSettings.damageShow,
                                        function: (t, e) => (t.globalSettings.damageShow = !t.globalSettings.damageShow, !0)
                                    }] : [{
                                        type: "text",
                                        msg: t.menuUIMsgBailan83
                                    }]
                                },
                                set: {
                                    text: t.menuUIMsgBailan84,
                                    page: (e, n) => e.player.hasTag("owner") ? [{
                                        type: "button",
                                        msg: t.menuUIMsgBailan85,
                                        function: (e, n) => ((new st.ModalFormData).toggle(t.menuUIMsgBailan80, e.globalSettings.entityCleaner).slider(t.menuUIMsgBailan91, 40, 1e3, 20, e.globalSettings.entityCleanerLeastNum).slider(t.menuUIMsgBailan92, 2, 10, 1, e.globalSettings.entityCleanerStrength).slider(t.menuUIMsgBailan93, 1, 60, 1, e.globalSettings.entityCleanerDelay).show(e.player).then((t => {
                                            var n, i, s, r, a, o, u, h;
                                            t.canceled || (e.globalSettings.entityCleaner = null !== (i = null === (n = t.formValues) || void 0 === n ? void 0 : n[0]) && void 0 !== i && i, e.globalSettings.entityCleanerLeastNum = null !== (r = null === (s = t.formValues) || void 0 === s ? void 0 : s[1]) && void 0 !== r ? r : 200, e.globalSettings.entityCleanerStrength = null !== (o = null === (a = t.formValues) || void 0 === a ? void 0 : a[2]) && void 0 !== o ? o : 5, e.globalSettings.entityCleanerDelay = null !== (h = null === (u = t.formValues) || void 0 === u ? void 0 : u[3]) && void 0 !== h ? h : 30)
                                        })).catch((t => {
                                            o.Z.throwError(t)
                                        })), !1)
                                    }] : [{
                                        type: "text",
                                        msg: t.menuUIMsgBailan83
                                    }]
                                }
                            }
                        }
                    }
                }(this.getLang())).showPage("main", "notice") : (new st.ModalFormData).title("Choose a language").dropdown("Language List", ["English", ""], 0).show(this.player).then((t => {
                    t.canceled || (this.data.lang = t.formValues && 0 == t.formValues[0] ? "en" : "zh")
                })).catch((t => {
                    o.Z.throwError(t)
                })) : "wb:jet_pack" === i.typeId ? (this.player.addEffect(t.MinecraftEffectTypes.levitation, 7, 15, !1), this.player.addEffect(t.MinecraftEffectTypes.slowFalling, 150, 3, !1), this.exPlayer.getDimension().spawnEntity("wb:ball_jet_pack", k.Z.getBlockLocation(this.exPlayer.getPosition().sub(this.exPlayer.getViewDirection().scl(2))))) : "wb:start_key" === i.typeId || i.typeId
            }))
        }
        chainDiggingLogs(e, i) {
            const s = n.Z.getInstance(this.getDimension()),
                r = n.Z.getInstance(this.getDimension()).getBlock(e).typeId;
            (r === t.MinecraftBlockTypes.log.id || r === t.MinecraftBlockTypes.log2.id || i) && (s.digBlock(e), this.chainDiggingLogs(e.add(0, 1, 0), !1))
        }
        onLoaded() {}
        onLeave() {}
    }
    class qt {
        constructor(t, e, n) {
            this._uiBody = e, this._client = t, this._button = n
        }
        getMessage() {
            return this._uiBody
        }
        showPage() {
            let t = (new ct.Z).title("__pomAlertWarning").body(this._uiBody);
            for (let [e, n] of this._button) t.button(e, (() => {
                n(this._client, this)
            }));
            t.show(this._client.player)
        }
    }
    var Yt = function(t, e, n, i) {
            var s, r = arguments.length,
                a = r < 3 ? e : null === i ? i = Object.getOwnPropertyDescriptor(e, n) : i;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(t, e, n, i);
            else
                for (var o = t.length - 1; o >= 0; o--)(s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, n, a) : s(e, n)) || a);
            return r > 3 && a && Object.defineProperty(e, n, a), a
        },
        Jt = function(t, e) {
            if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(t, e)
        };
    class Qt extends i.Z {
        constructor(t, e, n) {
            super(t, e, n), this.gameControllers = [], this.enchantSystem = new ft(this), this.talentSystem = new Tt(this), this.magicSystem = new xt(this), this.itemUseFunc = new Zt(this), this.ruinsSystem = new dt(this), this.taskSystem = new Xt(this), this.interactSystem = new yt(this), this.globalSettings = new U(new S.C("wpsetting")), this.cache = new N(this.exPlayer), this.looper = new L(this.getEvents(), (() => {
                this.cache.save()
            })), this.looper.delay(1e4), this.looper.start(), this.data = this.cache.get(new H), this.globalSettings.ownerExists || (n.addTag("owner"), this.globalSettings.ownerExists = !0), this.addCtrller(this.enchantSystem), this.addCtrller(this.magicSystem), this.addCtrller(this.talentSystem), this.addCtrller(this.itemUseFunc), this.addCtrller(this.ruinsSystem), this.addCtrller(this.taskSystem), this.addCtrller(this.interactSystem), this.gameControllers.forEach((t => {
                (0, x.B)(this.getEvents(), t), t.onJoin()
            }))
        }
        onJoin() {
            this.setInterworkingPool({
                setSkyBox: () => {
                    return t = this, e = void 0, i = function*() {}, new((n = void 0) || (n = Promise))((function(s, r) {
                        function a(t) {
                            try {
                                u(i.next(t))
                            } catch (t) {
                                r(t)
                            }
                        }

                        function o(t) {
                            try {
                                u(i.throw(t))
                            } catch (t) {
                                r(t)
                            }
                        }

                        function u(t) {
                            t.done ? s(t.value) : function(t) {
                                return t instanceof n ? t : new n((function(e) {
                                    e(t)
                                }))
                            }(t.value).then(a, o)
                        }
                        u((i = i.apply(t, e || [])).next())
                    }));
                    var t, e, n, i
                }
            })
        }
        addCtrller(t) {
            this.gameControllers.push(t)
        }
        getLang() {
            var t;
            return Z[null !== (t = this.data.lang) && void 0 !== t ? t : "en"]
        }
        onLoaded() {
            let t = d.Z.getInstance(this.player).getScoresManager();
            if (this.gameId = t.getScore("wbldid"), 0 === this.gameId && (this.gameId = Math.floor(Math.random() * D.Z.MAX_VALUE), t.setScoreAsync("wbldid", this.gameId)), this.gameControllers.forEach((t => t.onLoaded())), this.data.lang || this.exPlayer.runCommandAsync("mojang nmsl").catch((t => {
                    C.Z.hasChineseCharacter(JSON.stringify(t)) ? this.data.lang = "zh" : this.data.lang = "en"
                })), !this.data.licenseRead) {
                const t = new L(this.getEvents(), (() => {
                    new qt(this, X, [
                        ["", (e, n) => {
                            this.data.licenseRead = !0, t.stop()
                        }]
                    ]).showPage(), this.data.licenseRead || t.startOnce()
                })).delay(1e3);
                t.startOnce()
            }
            this.player.hasTag("wbmsyh") ? this.player.nameTag = "a" + this.player.nameTag : this.player.nameTag = "c" + this.player.nameTag, this.exPlayer.command.run(["execute as @s[tag=!wbyzc] at @s run scoreboard players set @s wbef 0", "execute as @s[tag=!wbyzc] at @s run scoreboard players set @s wbdj 0", "execute as @s[tag=!wbyzc] at @s run scoreboard players set @s wbdjcg 0", "execute as @s[tag=!wbyzc] at @s run scoreboard players set @s wbdjjf 0", 'execute as @s[tag=!wbyzc] at @s run give @s wb:power 1 0 {"minecraft:keep_on_death":{}}', "execute as @s[tag=!wbyzc] at @s run scoreboard players set @s wbcsjs -1", "execute as @s[tag=!wbyzc] at @s run scoreboard players set @s wbnldx 0", "execute as @s[tag=!wbyzc] at @s run scoreboard players set @s wbldpd 0", "execute as @s[tag=!wbyzc] at @s run scoreboard players set @s wbldcg 0", "execute as @s[tag=!wbyzc] at @s run scoreboard players set @s wbfl 200", "execute as @s[tag=!wbyzc] at @s run scoreboard players set @s wbwqlq 0", "execute as @s[tag=!wbyzc] at @s run scoreboard players set @s wbkjlqcg 0", "execute as @s[tag=!wbyzc] at @s run scoreboard players set @s wbkjlqjs 0", "execute as @s[tag=!wbyzc] at @s run scoreboard players set @s wbwqlqjs 0", "tag @s[scores={wbdj=-100..}] add wbyzc"])
        }
        onLeave() {
            this.gameControllers.forEach((t => t.onLeave())), this.looper.stop(), super.onLeave()
        }
        getPlayersAndIds() {
            let t = [];
            for (let e of this.getServer().getClients()) t.push([e.player, e.gameId]);
            return t
        }
        sayTo(t, e = this.player) {
            e.runCommandAsync(`tellraw @s {"rawtext": [{"text": "${t}"}]}`)
        }
        getServer() {
            return super.getServer()
        }
        taskUI(t, e) {
            this.taskSystem.show(t, e)
        }
        progressTaskFinish(t, e) {
            this.taskSystem.progressTaskFinish(t, e)
        }
    }
    Yt([O("taskUi"), Jt("design:type", Function), Jt("design:paramtypes", [String, String]), Jt("design:returntype", void 0)], Qt.prototype, "taskUI", null), Yt([O("progressTaskFinish"), Jt("design:type", Function), Jt("design:paramtypes", [String, Number]), Jt("design:returntype", void 0)], Qt.prototype, "progressTaskFinish", null);
    class te {
        constructor(t, e, n = 0) {
            this.mirror = "none", this.structureId = t, this.position = e, this.rotation = n
        }
        generate(t) {
            let e = this.rotation,
                i = n.Z.getInstance(t);
            (0, o.to)(i.command.run(`structure load ${this.structureId} ${this.position.x} ${this.position.y} ${this.position.z} ${Math.round(e)}_degrees ${this.mirror}`))
        }
    }
    class ee {
        constructor(t, e, n = 1) {
            this.width = e, this.height = n, this.size = t, this.jigsawData = Array.from(new Array(this.height), (() => Array.from(new Array(this.width), (() => new Array(this.width)))))
        }
        isEmpty(t, e, n = 0) {
            return void 0 === this.jigsawData[n][e][t]
        }
        setStructurePlane(t, e, n, i, s, r, a = 0, o = "none", u = 1, h = 1) {
            this.setStructure(t, e, 0, n, i, s, r, a, o, u, h, 1)
        }
        setStructure(t, e, n, i, s, r, a, o = 0, u = "none", h = 1, l = 1, c = 1) {
            this.clearStructure(t, e, n);
            for (let i = t; i < h + t; i++)
                for (let t = e; t < l + e; t++)
                    for (let e = n; e < c + n; e++)
                        if (!this.isEmpty(i, t, e)) throw new Error("Structure already contains " + i + " , " + e + " , " + t);
            for (let i = t; i < h + t; i++)
                for (let t = e; t < l + e; t++)
                    for (let e = n; e < c + n; e++) this.jigsawData[e][t][i] = ee.ContinueStructure;
            this.jigsawData[n][e][t] = [i, s, r, a, o, u, h, l, c]
        }
        fillStructure(t, e, n, i, s = 0, r = "none", a = 1, o = 1, u = 1) {
            const h = [t, e, n, i, s, r, a, o, u];
            for (let t = 0; t < this.width; t++)
                for (let e = 0; e < this.width; e++)
                    for (let n = 0; n < this.height; n++) this.jigsawData[n][e][t] = h
        }
        getStructure(t, e, n) {
            const i = this.findBaseStructure(t, e, n);
            if (void 0 === i) return;
            const s = this.jigsawData[i[0]][i[1]][i[2]];
            return s instanceof Array ? new ne(...s) : void 0
        }
        clearStructure(t, e, n = 0) {
            const i = this.findBaseStructure(t, e, n);
            if (void 0 !== i) {
                const [s, r, a] = i, o = this.jigsawData[a][r][s];
                if (void 0 !== o) {
                    if ("number" == typeof o) throw new Error("Error clearing");
                    for (let i = 0; i < o[6]; i++)
                        for (let s = 0; s < o[7]; s++)
                            for (let r = 0; r < o[8]; r++) this.jigsawData[r + n][s + e][i + t] = void 0
                }
            }
        }
        findBaseStructure(t, e, n = 0) {
            let i = this.jigsawData[n][e][t];
            if (void 0 !== i) {
                if (i === ee.ContinueStructure) {
                    for (; i === ee.ContinueStructure && n > 0;) i = this.jigsawData[n--][e][t];
                    for (; i === ee.ContinueStructure && e > 0;) i = this.jigsawData[n][e--][t];
                    for (; i === ee.ContinueStructure && t > 0;) i = this.jigsawData[n][e][t--];
                    return [t, e, n]
                }
                return [t, e, n]
            }
        }
        getWidth() {
            return this.size * this.width
        }
        getHeight() {
            return this.size * this.height
        }
        generate(t, n, i, s) {
            let r = new te("", new e.Z, 0);
            this.jigsawData.forEach(((e, a) => {
                e.forEach(((e, o) => {
                    e.forEach(((e, u) => {
                        "number" != typeof e && void 0 !== e && (r.position.set(t + u * this.size + e[0], n + a * this.size + e[1], i + o * this.size + e[2]), r.structureId = e[3], r.rotation = e[4], r.mirror = e[5], r.generate(s))
                    }))
                }))
            }))
        } [Symbol.toStringTag]() {
            return "symbol"
        }
        foreach(t) {
            const e = new ne(0, 0, 0, "", 0, "none", 1, 1, 1);
            for (let n = 0; n < this.height; n++)
                for (let i = 0; i < this.width; i++)
                    for (let s = 0; s < this.width; s++) {
                        let r = this.jigsawData[n][i][s];
                        r instanceof Array && (e.set(...r), t(e, s, i, n))
                    }
        }
    }
    ee.ContinueStructure = 1;
    class ne {
        constructor(t, e, n, i, s, r, a, o, u) {
            this.set(t, e, n, i, s, r, u, o, a)
        }
        set(t, e, n, i, s, r, a, o, u) {
            this.offsetX = t, this.offsetY = e, this.offsetZ = n, this.structureName = i, this.structureRot = s, this.mirror = r, this.coverGridHeight = a, this.coverGridWidth = o, this.coverGridLength = u
        }
    }
    class ie {
        constructor(t) {
            this.structure_area1 = "mystructure:boss_cave_area_b1", this.structure_area2 = "mystructure:boss_cave_area_b2", this.structure_area3 = "mystructure:boss_cave_area_b3", this.structure_area4 = "mystructure:boss_cave_area_b4", this._pathArea = [], this._monsterArea = [], this._playerArea = [], this.seed = t
        }
        init(t, n, i, s) {
            this._monsterArea = [], this._pathArea = [], this._playerArea = [], this.x = t, this.y = n, this.z = i, this.dim = s, this.jigsaw = new ee(32, 4), this.jigsaw.setStructurePlane(0, 0, 0, 0, 0, this.structure_area1, 0), this.jigsaw.setStructurePlane(1, 0, 0, 0, 0, this.structure_area2, 0), this.jigsaw.setStructurePlane(0, 1, 0, 0, 0, this.structure_area3, 0), this.jigsaw.setStructurePlane(1, 1, 0, 0, 0, this.structure_area4, 0), this.jigsaw.setStructurePlane(3, 0, 0, 0, 0, this.structure_area1, 90), this.jigsaw.setStructurePlane(3, 1, 0, 0, 0, this.structure_area2, 90), this.jigsaw.setStructurePlane(2, 0, 0, 0, 0, this.structure_area3, 90), this.jigsaw.setStructurePlane(2, 1, 0, 0, 0, this.structure_area4, 90), this.jigsaw.setStructurePlane(0, 3, 0, 0, 0, this.structure_area1, 270), this.jigsaw.setStructurePlane(0, 2, 0, 0, 0, this.structure_area2, 270), this.jigsaw.setStructurePlane(1, 3, 0, 0, 0, this.structure_area3, 270), this.jigsaw.setStructurePlane(1, 2, 0, 0, 0, this.structure_area4, 270), this.jigsaw.setStructurePlane(3, 3, 0, 0, 0, this.structure_area1, 180), this.jigsaw.setStructurePlane(2, 3, 0, 0, 0, this.structure_area2, 180), this.jigsaw.setStructurePlane(3, 2, 0, 0, 0, this.structure_area3, 180), this.jigsaw.setStructurePlane(2, 2, 0, 0, 0, this.structure_area4, 180), this._bossArea = new E(new e.Z(62, 13, 62).add(t, n, i), new e.Z(4, 6, 4)), this._playerArea.push(new E(new e.Z(15, 6, 39).add(t, n, i), new e.Z(1, 1, 1)), new E(new e.Z(89, 6, 15).add(t, n, i), new e.Z(1, 1, 1)), new E(new e.Z(39, 6, 113).add(t, n, i), new e.Z(1, 1, 1)), new E(new e.Z(113, 6, 89).add(t, n, i), new e.Z(1, 1, 1))), this._playerArea.push(new E(new e.Z(7, 50, 39).add(t, n, i), new e.Z(1, 1, 1)), new E(new e.Z(89, 50, 7).add(t, n, i), new e.Z(1, 1, 1)), new E(new e.Z(39, 50, 121).add(t, n, i), new e.Z(1, 1, 1)), new E(new e.Z(121, 50, 89).add(t, n, i), new e.Z(1, 1, 1)))
        }
        generate() {
            this.init(this.x, this.y, this.z, this.dim), this.jigsaw.generate(this.x, this.y, this.z, this.dim), this.dispose()
        }
        getPathArea() {
            return this._pathArea
        }
        getMonsterSpawnArea() {
            return this._monsterArea
        }
        getPlayerSpawnArea() {
            return this._playerArea
        }
        getBossSpawnArea() {
            return this._bossArea
        }
        dispose() {
            this.jigsaw = new ee(1, 1, 1)
        }
    }
    class se {
        constructor(t, e) {
            "number" == typeof t && "number" == typeof e ? (this.x = t, this.y = e) : void 0 === t && void 0 === e ? (this.x = 0, this.y = 0) : (this.x = t.x, this.y = t.y)
        }
        set(t, e) {
            return "number" == typeof t ? "number" == typeof e && (this.x = t, this.y = e) : this.set(t.x, t.y), this
        }
        add(t, e) {
            return "number" == typeof t ? "number" == typeof e && (this.x += t, this.y += e) : this.add(t.x, t.y), this
        }
        sub(t, e) {
            return "number" == typeof t ? "number" == typeof e && (this.x -= t, this.y -= e) : this.sub(t.x, t.y), this
        }
        scl(t, e, n) {
            return "number" == typeof t ? "number" == typeof e && "number" == typeof n ? (this.x *= t, this.y *= e) : void 0 === e && void 0 === n && (this.x *= t, this.y *= t) : this.sub(t.x, t.y), this
        }
        div(t) {
            return this.x /= t, this.y /= t, this
        }
        len() {
            return Math.sqrt(Math.pow(this.x, 2) + Math.pow(this.y, 2))
        }
        len2() {
            return Math.pow(this.x, 2) + Math.pow(this.y, 2)
        }
        equals(t) {
            return this.x === t.x && this.y === t.y
        }
        distance(t) {
            return this.clone().sub(t).len()
        }
        toString() {
            return `(${this.x}, ${this.y})`
        } [Symbol.toStringTag]() {
            return this.toString()
        }
        floor() {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
        }
        round() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this
        }
        ceil() {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
        }
        abs() {
            return this.x = Math.abs(this.x), this.y = Math.abs(this.y), this
        }
        mul(t) {
            return t.x * this.x + t.y * this.y
        }
        normalize() {
            return this.div(this.len()), this
        }
        clone() {
            return new se(this.x, this.y)
        }
    }
    se.back = new se(0, -1), se.forward = new se(0, 1), se.left = new se(-1, 0), se.one = new se(1, 1), se.right = new se(1, 0), se.zero = new se(0, 0);
    class re {
        constructor(t) {
            this.structure_bossArea = "mystructure:boss_desert_1", this.structure_straightLine = "mystructure:boss_desert_2", this.structure_curve = "mystructure:boss_desert_3", this.structure_triple = "mystructure:boss_desert_4", this.structure_crossing = "mystructure:boss_desert_5", this.structure_straightLineTower = "mystructure:boss_desert_6", this.structure_towerBlock1 = "mystructure:boss_desert_7", this.structure_towerBlock2 = "mystructure:boss_desert_8", this.structure_towerBlock3 = "mystructure:boss_desert_10", this.structure_towerBlock4 = "mystructure:boss_desert_12", this.structure_upplain = "mystructure:boss_desert_13", this.structure_upstairs = "mystructure:boss_desert_14", this.structure_towerPiece = "mystructure:boss_desert_15", this.structure_boss = "mystructure:boss_desert_16", this.structure_block1 = "mystructure:boss_desert_9", this.structure_block2 = "mystructure:boss_desert_11", this.completed = !1, this.rooms = new Set, this.paths = new Set, this._pathArea = [], this._airPathArea = [], this._monsterArea = [], this._airMonsterArea = [], this._playerArea = [], this.seed = t
        }
        isCompleted() {
            return this.completed
        }
        isInRoom(t) {
            return this.rooms.has(t)
        }
        isOnPath(t) {
            return this.paths.has(t)
        }
        getPathArea() {
            return this._pathArea
        }
        getAirPathArea() {
            return this._airPathArea
        }
        getMonsterSpawnArea() {
            return this._monsterArea
        }
        getAirMonsterSpawnArea() {
            return this._airMonsterArea
        }
        getPlayerSpawnArea() {
            return this._playerArea
        }
        getBossSpawnArea() {
            return this._bossArea
        }
        dispose() {
            this.jigsaw = new ee(1, 1, 1)
        }
        generate() {
            this.init(this.x, this.y, this.z, this.dim), this.jigsaw.generate(this.x, this.y, this.z, this.dim), this.dispose()
        }
        init(t, n, i, s) {
            this.x = t, this.y = n, this.z = i, this.dim = s, this._bossArea = new E(new e.Z(254, 2, 254).add(t, n, i), new e.Z(4, 4, 4));
            const r = Array.from(new Array(32), (() => new Array(32).fill(0)));
            let a = 64,
                o = this.seed;
            const u = new D.Z(o),
                h = (t, e) => {
                    try {
                        return r[e][t]
                    } catch (t) {
                        return 3
                    }
                };
            for (let t = 14; t < 18; t++)
                for (let e = 14; e < 18; e++) r[t][e] = 4;
            for (; a > 0;) {
                let t = u.nextInt(32),
                    e = u.nextInt(32);
                4 !== r[t][e] && (r[t][e] = 1, a--)
            }
            let l = [
                [new se, se.forward]
            ];
            r[1][0] = 0;
            const c = new se;
            for (; l.length > 0;) {
                let t = [];
                t = [];
                for (let e of l)
                    if (c.set(e[0]).add(e[1]), !(0 !== h(c.x, c.y) || (e[1] !== se.right && e[1] !== se.left || 2 === h(c.x, c.y + 1) && 2 === h(c.x - 1, c.y + 1) || 2 === h(c.x, c.y + 1) && 2 === h(c.x + 1, c.y + 1) || 2 === h(c.x, c.y - 1) && 2 === h(c.x - 1, c.y - 1) || 2 === h(c.x, c.y - 1) && 2 === h(c.x + 1, c.y - 1)) && (e[1] !== se.forward && e[1] !== se.back || 2 === h(c.x + 1, c.y + 1) && 2 === h(c.x + 1, c.y) || 2 === h(c.x + 1, c.y - 1) && 2 === h(c.x + 1, c.y) || 2 === h(c.x - 1, c.y + 1) && 2 === h(c.x - 1, c.y) || 2 === h(c.x - 1, c.y - 1) && 2 === h(c.x - 1, c.y)))) {
                        r[c.y][c.x] = 2;
                        let e = l.length < 30 ? 4 : Math.min(4, u.nextInt(6)),
                            n = [se.forward, se.back, se.left, se.right];
                        for (; e > 0;) {
                            let i = u.nextInt(n.length);
                            t.push([c.clone(), n[i]]), n.splice(i, 1), e--
                        }
                    } l = t
            }
            class p {
                constructor(t, e, n) {
                    this.height = n, this.connections = [], this.x = t, this.y = e
                }*[Symbol.iterator]() {
                    for (let t of this.connections) yield t
                }
                connect(t) {
                    this.connections.push(t)
                } [Symbol.toStringTag]() {
                    return this.toString()
                }
                toString() {
                    return `(${this.x},${this.y},${this.height})`
                }
            }
            const d = Array.from(new Array(16), (() => new Array(16).fill(0))),
                m = (t, e) => {
                    try {
                        return d[e][t]
                    } catch (t) {
                        return 3
                    }
                };
            for (let t = 6; t < 10; t++)
                for (let e = 6; e < 10; e++) d[t][e] = 4;
            const g = [];
            for (a = 24; a > 0;) {
                let t = u.nextInt(16),
                    e = u.nextInt(16);
                const [n, i] = [16 - d.length / 2 + e, 16 - d.length / 2 + t], s = h(n, i);
                if (4 !== m(e, t) && 1 == s || 0 == s) {
                    const s = new p(t, e, 3 + Math.floor(a / 4));
                    g.push(s), d[t][e] = s, r[i][n] = 5, a--
                }
            }
            g.forEach((t => {
                for (let e = -4; e <= 4; e++)
                    for (let n = -4; n <= 4; n++)
                        if (0 != e || 0 != n) {
                            let i = m(t.x + e, t.y + n);
                            i instanceof p && t.connect(i)
                        }
            })), this.jigsaw = new ee(16, 32, 10), r.forEach(((t, e) => {
                t.forEach(((t, n) => {
                    if (1 === t) this.jigsaw.setStructurePlane(n, e, 0, 0, 0, [this.structure_block1, this.structure_block2][u.nextInt(2)], 90 * u.nextInt(4));
                    else if (0 === t) this.jigsaw.setStructurePlane(n, e, 0, 0, 0, [this.structure_towerBlock1, this.structure_towerBlock2, this.structure_towerBlock3, this.structure_towerBlock4][u.nextInt(4)], 90 * u.nextInt(4));
                    else if (5 === t) {
                        let t = m(n - 16 + d.length / 2, e - 16 + d.length / 2);
                        if (t instanceof p) {
                            let i = t.height;
                            for (; i >= 0;) this.jigsaw.setStructure(n, e, i, 0, 0, 0, this.structure_towerPiece, 0), i--
                        }
                    } else if (2 === t) {
                        let t = 2 === h(n, e + 1) ? 1 : 0,
                            i = 2 === h(n, e - 1) ? 1 : 0,
                            s = 2 === h(n + 1, e) ? 1 : 0,
                            r = 2 === h(n - 1, e) ? 1 : 0;
                        switch (t + r + s + i) {
                            case 1:
                                t + i === 1 ? this.jigsaw.setStructurePlane(n, e, 0, 0, 0, this.structure_straightLine, 0) : r + s === 1 && this.jigsaw.setStructurePlane(n, e, 0, 0, 0, this.structure_straightLine, 90);
                                break;
                            case 2:
                                if (t + i === 2) this.jigsaw.setStructurePlane(n, e, 0, 0, 0, this.structure_straightLine, 0);
                                else if (r + s === 2) this.jigsaw.setStructurePlane(n, e, 0, 0, 0, this.structure_straightLine, 90);
                                else if (1 === r)
                                    if (1 === t) this.jigsaw.setStructurePlane(n, e, 0, 0, 0, this.structure_curve, 90);
                                    else {
                                        if (1 !== i) throw new Error("num error");
                                        this.jigsaw.setStructurePlane(n, e, 0, 0, 0, this.structure_curve, 180)
                                    }
                                else if (1 === s)
                                    if (1 === t) this.jigsaw.setStructurePlane(n, e, 0, 0, 0, this.structure_curve, 0);
                                    else {
                                        if (1 !== i) throw new Error("num error");
                                        this.jigsaw.setStructurePlane(n, e, 0, 0, 0, this.structure_curve, 270)
                                    } break;
                            case 3:
                                0 === r ? this.jigsaw.setStructurePlane(n, e, 0, 0, 0, this.structure_triple, 0) : 0 === i ? this.jigsaw.setStructurePlane(n, e, 0, 0, 0, this.structure_triple, 90) : 0 === s ? this.jigsaw.setStructurePlane(n, e, 0, 0, 0, this.structure_triple, 180) : 0 === t && this.jigsaw.setStructurePlane(n, e, 0, 0, 0, this.structure_triple, 270);
                                break;
                            case 4:
                                this.jigsaw.setStructurePlane(n, e, 0, 0, 0, this.structure_crossing, 0)
                        }
                    }
                }))
            }));
            const f = new e.Z,
                y = new e.Z;
            g.forEach((t => {
                for (const e of t)
                    if (e.height > t.height) {
                        f.set(t.x, t.height, t.y), y.set(e.x, t.height, e.y).sub(f), y.set(y.x > 0 ? 1 : -1, t.height, y.z > 0 ? 1 : -1);
                        let n = 16 - d.length / 2;
                        if (u.nextBoolean()) {
                            for (; f.x != e.x; f.x += y.x) this.jigsaw.isEmpty(f.x + n, f.z + n, f.y) && this.jigsaw.setStructure(f.x + n, f.z + n, f.y, 0, 0, 0, this.structure_upplain);
                            for (; f.z != e.y; f.z += y.z) this.jigsaw.isEmpty(f.x + n, f.z + n, f.y) && this.jigsaw.setStructure(f.x + n, f.z + n, f.y, 0, 0, 0, this.structure_upplain)
                        } else {
                            for (; f.z != e.y; f.z += y.z) this.jigsaw.isEmpty(f.x + n, f.z + n, f.y) && this.jigsaw.setStructure(f.x + n, f.z + n, f.y, 0, 0, 0, this.structure_upplain);
                            for (; f.x != e.x; f.x += y.x) this.jigsaw.isEmpty(f.x + n, f.z + n, f.y) && this.jigsaw.setStructure(f.x + n, f.z + n, f.y, 0, 0, 0, this.structure_upplain)
                        }
                    }
            })), this.jigsaw.setStructurePlane(14, 14, 0, -1, 0, this.structure_boss, 0, "none", 2, 2), this.jigsaw.setStructurePlane(14, 16, 0, -1, 0, this.structure_boss, 270, "none", 2, 2), this.jigsaw.setStructurePlane(16, 14, 0, -1, 0, this.structure_boss, 90, "none", 2, 2), this.jigsaw.setStructurePlane(16, 16, 0, -1, 0, this.structure_boss, 180, "none", 2, 2), this._airMonsterArea = [], this._airPathArea = [], this._monsterArea = [], this._pathArea = [], this._playerArea = [], this.rooms = new Set, this.paths = new Set, this.jigsaw.foreach(((t, n, i, s) => {
                if (t.structureName === this.structure_straightLine || t.structureName === this.structure_triple || t.structureName === this.structure_curve || t.structureName === this.structure_crossing) this._pathArea.push(new E(new e.Z(n, s, i).scl(this.jigsaw.size).add(this.x, this.y, this.z), new e.Z(1, 1, 1).scl(this.jigsaw.size))), this.paths.add(`${n},${s},${i}`), t.structureName === this.structure_crossing && (this._playerArea.push(new E(new e.Z(n, s, i).scl(this.jigsaw.size).add(this.x, this.y, this.z), new e.Z(1, 1, 1).scl(this.jigsaw.size))), this.paths.add(`${n},${s},${i}`));
                else if (t.structureName === this.structure_towerBlock3 || t.structureName === this.structure_towerBlock4 || t.structureName === this.structure_towerBlock2 || t.structureName === this.structure_towerBlock1) this._monsterArea.push(new E(new e.Z(n, s, i).scl(this.jigsaw.size).add(this.x, this.y, this.z), new e.Z(1, 1, 1).scl(this.jigsaw.size))), this.rooms.add(`${n},${s},${i}`);
                else if (t.structureName === this.structure_boss);
                else if (t.structureName === this.structure_upplain) this._airPathArea.push(new E(new e.Z(n, s, i).scl(this.jigsaw.size).add(this.x, this.y, this.z), new e.Z(1, 1, 1).scl(this.jigsaw.size))), this.paths.add(`${n},${s},${i}`);
                else if (t.structureName === this.structure_towerPiece) {
                    let t = new e.Z(n, s, i).scl(this.jigsaw.size).add(this.x, this.y, this.z);
                    this._airMonsterArea.push(new E(t, new e.Z(1, 1, 1).scl(this.jigsaw.size))), this.rooms.add(`${n},${s},${i}`)
                }
            })), this.completed = !0
        }
    }
    class ae {
        constructor(t) {
            this.structure_area1 = "mystructure:boss_stone_area_b1", this.structure_area2 = "mystructure:boss_stone_area_b2", this.structure_area3 = "mystructure:boss_stone_area_b3", this.structure_area4 = "mystructure:boss_stone_area_b4", this._pathArea = [], this._monsterArea = [], this._playerArea = [], this.seed = t
        }
        init(t, n, i, s) {
            this._monsterArea = [], this._pathArea = [], this._playerArea = [], this.x = t, this.y = n, this.z = i, this.dim = s, this.jigsaw = new ee(32, 4), this.jigsaw.setStructurePlane(0, 0, 0, 0, 0, this.structure_area1, 0), this.jigsaw.setStructurePlane(1, 0, 0, 0, 0, this.structure_area2, 0), this.jigsaw.setStructurePlane(0, 1, 0, 0, 0, this.structure_area3, 0), this.jigsaw.setStructurePlane(1, 1, 0, 0, 0, this.structure_area4, 0), this.jigsaw.setStructurePlane(3, 0, 0, 0, 0, this.structure_area1, 90), this.jigsaw.setStructurePlane(3, 1, 0, 0, 0, this.structure_area2, 90), this.jigsaw.setStructurePlane(2, 0, 0, 0, 0, this.structure_area3, 90), this.jigsaw.setStructurePlane(2, 1, 0, 0, 0, this.structure_area4, 90), this.jigsaw.setStructurePlane(0, 3, 0, 0, 0, this.structure_area1, 270), this.jigsaw.setStructurePlane(0, 2, 0, 0, 0, this.structure_area2, 270), this.jigsaw.setStructurePlane(1, 3, 0, 0, 0, this.structure_area3, 270), this.jigsaw.setStructurePlane(1, 2, 0, 0, 0, this.structure_area4, 270), this.jigsaw.setStructurePlane(3, 3, 0, 0, 0, this.structure_area1, 180), this.jigsaw.setStructurePlane(2, 3, 0, 0, 0, this.structure_area2, 180), this.jigsaw.setStructurePlane(3, 2, 0, 0, 0, this.structure_area3, 180), this.jigsaw.setStructurePlane(2, 2, 0, 0, 0, this.structure_area4, 180), this._bossArea = new E(new e.Z(62, 2, 62).add(t, n, i), new e.Z(4, 6, 4)), this._playerArea.push(new E(new e.Z(6, 5, 6).add(t, n, i), new e.Z(2, 4, 2)), new E(new e.Z(120, 5, 6).add(t, n, i), new e.Z(2, 4, 2)), new E(new e.Z(6, 5, 120).add(t, n, i), new e.Z(2, 4, 2)), new E(new e.Z(120, 5, 120).add(t, n, i), new e.Z(2, 4, 2)))
        }
        generate() {
            this.init(this.x, this.y, this.z, this.dim), this.jigsaw.generate(this.x, this.y, this.z, this.dim), this.dispose()
        }
        getPathArea() {
            return this._pathArea
        }
        getMonsterSpawnArea() {
            return this._monsterArea
        }
        getPlayerSpawnArea() {
            return this._playerArea
        }
        getBossSpawnArea() {
            return this._bossArea
        }
        dispose() {
            this.jigsaw = new ee(1, 1, 1)
        }
    }
    class oe {
        constructor(t) {
            this.structure_area1 = "mystructure:boss_ancient_area1", this.structure_area2 = "mystructure:boss_ancient_area2", this.structure_area3 = "mystructure:boss_ancient_area3", this.structure_area4 = "mystructure:boss_ancient_area4", this._pathArea = [], this._monsterArea = [], this._playerArea = [], this.seed = t
        }
        init(t, n, i, s) {
            this._monsterArea = [], this._pathArea = [], this._playerArea = [], this.x = t, this.y = n, this.z = i, this.dim = s, this.jigsaw = new ee(32, 4), this.jigsaw.setStructurePlane(0, 0, 0, 0, 0, this.structure_area1, 0, "none"), this.jigsaw.setStructurePlane(3, 0, 0, 0, 0, this.structure_area1, 0, "z"), this.jigsaw.setStructurePlane(0, 3, 0, 0, 0, this.structure_area1, 0, "x"), this.jigsaw.setStructurePlane(3, 3, 0, 0, 0, this.structure_area1, 0, "xz"), this.jigsaw.setStructurePlane(1, 0, 0, 0, 0, this.structure_area2, 0, "none"), this.jigsaw.setStructurePlane(2, 0, 0, 0, 0, this.structure_area2, 0, "z"), this.jigsaw.setStructurePlane(1, 3, 0, 0, 0, this.structure_area2, 0, "x"), this.jigsaw.setStructurePlane(2, 3, 0, 0, 0, this.structure_area2, 0, "xz"), this.jigsaw.setStructurePlane(0, 1, 0, 0, 0, this.structure_area3, 0, "none"), this.jigsaw.setStructurePlane(3, 1, 0, 0, 0, this.structure_area3, 0, "z"), this.jigsaw.setStructurePlane(0, 2, 0, 0, 0, this.structure_area3, 0, "x"), this.jigsaw.setStructurePlane(3, 2, 0, 0, 0, this.structure_area3, 0, "xz"), this.jigsaw.setStructurePlane(1, 1, 0, 0, 0, this.structure_area4, 0, "none"), this.jigsaw.setStructurePlane(2, 1, 0, 0, 0, this.structure_area4, 0, "z"), this.jigsaw.setStructurePlane(1, 2, 0, 0, 0, this.structure_area4, 0, "x"), this.jigsaw.setStructurePlane(2, 2, 0, 0, 0, this.structure_area4, 0, "xz"), this._bossArea = new E(new e.Z(62, 2, 62).add(t, n, i), new e.Z(4, 6, 4)), this._playerArea.push(new E(new e.Z(10, 17, 40).add(t, n, i), new e.Z(2, 1, 2)), new E(new e.Z(118, 17, 40).add(t, n, i), new e.Z(2, 1, 2)), new E(new e.Z(118, 17, 88).add(t, n, i), new e.Z(2, 1, 2)), new E(new e.Z(10, 17, 88).add(t, n, i), new e.Z(2, 1, 2)))
        }
        generate() {
            this.init(this.x, this.y, this.z, this.dim), this.jigsaw.generate(this.x, this.y, this.z, this.dim), this.dispose()
        }
        getPathArea() {
            return this._pathArea
        }
        getMonsterSpawnArea() {
            return this._monsterArea
        }
        getPlayerSpawnArea() {
            return this._playerArea
        }
        getBossSpawnArea() {
            return this._bossArea
        }
        dispose() {
            this.jigsaw = new ee(1, 1, 1)
        }
    }
    class ue {
        constructor(t) {
            this.structure_area1 = "mystructure:boss_mind_area_b1", this.structure_area2 = "mystructure:boss_mind_area_b2", this.structure_area3 = "mystructure:boss_mind_area_b3", this.structure_area4 = "mystructure:boss_mind_area_b4", this._pathArea = [], this._monsterArea = [], this._playerArea = [], this.seed = t
        }
        init(t, n, i, s) {
            this._monsterArea = [], this._pathArea = [], this._playerArea = [], this.x = t, this.y = n, this.z = i, this.dim = s, this.jigsaw = new ee(32, 4), this.jigsaw.setStructurePlane(0, 0, 0, 0, 0, this.structure_area1, 0), this.jigsaw.setStructurePlane(1, 0, 0, 0, 0, this.structure_area2, 0), this.jigsaw.setStructurePlane(0, 1, 0, 0, 0, this.structure_area3, 0), this.jigsaw.setStructurePlane(1, 1, 0, 0, 0, this.structure_area4, 0), this.jigsaw.setStructurePlane(3, 0, 0, 0, 0, this.structure_area1, 90), this.jigsaw.setStructurePlane(3, 1, 0, 0, 0, this.structure_area2, 90), this.jigsaw.setStructurePlane(2, 0, 0, 0, 0, this.structure_area3, 90), this.jigsaw.setStructurePlane(2, 1, 0, 0, 0, this.structure_area4, 90), this.jigsaw.setStructurePlane(0, 3, 0, 0, 0, this.structure_area1, 270), this.jigsaw.setStructurePlane(0, 2, 0, 0, 0, this.structure_area2, 270), this.jigsaw.setStructurePlane(1, 3, 0, 0, 0, this.structure_area3, 270), this.jigsaw.setStructurePlane(1, 2, 0, 0, 0, this.structure_area4, 270), this.jigsaw.setStructurePlane(3, 3, 0, 0, 0, this.structure_area1, 180), this.jigsaw.setStructurePlane(2, 3, 0, 0, 0, this.structure_area2, 180), this.jigsaw.setStructurePlane(3, 2, 0, 0, 0, this.structure_area3, 180), this.jigsaw.setStructurePlane(2, 2, 0, 0, 0, this.structure_area4, 180), this._bossArea = new E(new e.Z(62, 36, 62).add(t, n, i), new e.Z(4, 6, 4)), this._playerArea.push(new E(new e.Z(36, 37, 36).add(t, n, i), new e.Z(50, 4, 50)))
        }
        generate() {
            this.init(this.x, this.y, this.z, this.dim), this.jigsaw.generate(this.x, this.y, this.z, this.dim), this.dispose()
        }
        getPathArea() {
            return this._pathArea
        }
        getMonsterSpawnArea() {
            return this._monsterArea
        }
        getPlayerSpawnArea() {
            return this._playerArea
        }
        getBossSpawnArea() {
            return this._bossArea
        }
        dispose() {
            this.jigsaw = new ee(1, 1, 1)
        }
    }
    const he = ["dec:god_of_destroy", "dec:destroy_staff"];
    class le {
        constructor(e) {
            this.time = null != e ? e : t.world.getAbsoluteTime()
        }
        print() {
            t.world.say("time is " + this.time)
        }
        isDay() {
            return this.days() < 12e3
        }
        isNight() {
            return this.days() > 12e3
        }
        days() {
            return this.time - 24e3 * Math.floor(this.time / 24e3)
        }
    }
    var ce = __webpack_require__(462),
        pe = function(t, e, n, i) {
            var s, r = arguments.length,
                a = r < 3 ? e : null === i ? i = Object.getOwnPropertyDescriptor(e, n) : i;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) a = Reflect.decorate(t, e, n, i);
            else
                for (var o = t.length - 1; o >= 0; o--)(s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, n, a) : s(e, n)) || a);
            return r > 3 && a && Object.defineProperty(e, n, a), a
        },
        de = function(t, e) {
            if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(t, e)
        };
    class me extends T {
        constructor(i) {
            super(i), this.tps = 20, this._mtps = 20, this.fakeplayers = [], this.setting = new U(new S.C("wpsetting")), (this.clearEntityNumUpdate = new L(this.getEvents(), (() => {
                this.updateClearEntityNum()
            })).delay(1e4)).start(), this.updateClearEntityNum(), this.entityCleaner = new L(this.getEvents(), (() => {
                let e = Array.from(n.Z.getInstance(this.getDimension(t.MinecraftDimensionTypes.overworld)).getEntities()).concat(Array.from(n.Z.getInstance(this.getDimension(t.MinecraftDimensionTypes.theEnd)).getEntities())).concat(Array.from(n.Z.getInstance(this.getDimension(t.MinecraftDimensionTypes.nether)).getEntities())),
                    i = new Map;
                e.forEach((t => {
                    var e;
                    null != (null == t ? void 0 : t.typeId) && i.set(t.typeId, (null !== (e = i.get(t.typeId)) && void 0 !== e ? e : 0) + 1)
                }));
                let s = [0, ""];
                i.forEach(((e, n) => {
                    e > s[0] && -1 === [t.MinecraftEntityTypes.player.id, t.MinecraftEntityTypes.villager.id, t.MinecraftEntityTypes.villagerV2.id].indexOf(n) && (s[0] = e, s[1] = n)
                })), e.length > this.entityCleanerLeastNum && (this.say("Clear Entity Type" + s[1]), this.say("Clear Entity Num" + s[0]), e.forEach((t => {
                    t && t.typeId && t.typeId === s[1] && ("minecraft:item" === t.typeId && 0 !== t.viewDirection.y || t.kill())
                })))
            })).delay(8e3), this.upDateEntityCleaner();
            let s = 0;
            this.tpsListener = new L(this.getEvents(), (() => {
                this.tps = s;
                let t = this.tps - this._mtps > 0 ? this.entityCleanerStrength : 11 - this.entityCleanerStrength;
                this._mtps = this._mtps * (t - 1) / t + this.tps / t, this.entityCleaner.delay(Math.pow(this.entityCleanerDelay, this._mtps)), s = 0
            })).delay(1e3), this.getEvents().events.tick.subscribe((t => {
                s++
            })), this.tpsListener.start(), this.portal_desertBoss = new A, this.portal_desertBoss.setDirection(A.DIRECTION_LAY).setStructure([
                ["XXXXX", "XWWWX", "XWYWX", "XWWWX", "XXXXX"],
                ["XSXSX", "SAAAS", "XAAAX", "SAAAS", "XSXSX"],
                ["CAAAC", "AAAAA", "AAAAA", "AAAAA", "CAAAC"]
            ]).analysis({
                X: t.MinecraftBlockTypes.sandstone.id,
                W: t.MinecraftBlockTypes.water.id,
                Y: "wb:block_magic_equipment",
                A: t.MinecraftBlockTypes.air.id,
                S: t.MinecraftBlockTypes.stoneBlockSlab2.id,
                C: t.MinecraftBlockTypes.cobblestoneWall.id
            }), this.portal_stoneBoss = new A, this.portal_stoneBoss.setDirection(A.DIRECTION_LAY).setStructure([
                ["BXXXB", "XWWWX", "XWYWX", "XWWWX", "BXXXB"],
                ["BASAB", "AAAAA", "SAAAS", "AAAAA", "BASAB"]
            ]).analysis({
                X: t.MinecraftBlockTypes.sandstone.id,
                W: t.MinecraftBlockTypes.water.id,
                Y: "wb:block_energy_seal",
                S: t.MinecraftBlockTypes.cobblestoneWall.id,
                A: t.MinecraftBlockTypes.air.id,
                B: t.MinecraftBlockTypes.stonebrick.id
            }), this.portal_caveBoss = new A, this.portal_caveBoss.setDirection(A.DIRECTION_LAY).setStructure([
                ["XXXXX", "XWWWX", "XWYWX", "XWWWX", "XXXXX"],
                ["XASAX", "AAAAA", "SAAAS", "AAAAA", "XASAX"]
            ]).analysis({
                X: t.MinecraftBlockTypes.deepslateTiles.id,
                W: t.MinecraftBlockTypes.water.id,
                Y: "wb:block_energy_boundary",
                S: t.MinecraftBlockTypes.lantern.id,
                A: t.MinecraftBlockTypes.air.id
            }), this.portal_ancientBoss = new A, this.portal_ancientBoss.setDirection(A.DIRECTION_LAY).setStructure([
                ["BXXXB", "XWWWX", "XWYWX", "XWWWX", "BXXXB"],
                ["BASAB", "AAAAA", "SAAAS", "AAAAA", "BASAB"]
            ]).analysis({
                X: t.MinecraftBlockTypes.chiseledDeepslate.id,
                W: t.MinecraftBlockTypes.water.id,
                Y: "wb:block_magic_ink",
                S: t.MinecraftBlockTypes.verdantFroglight.id,
                A: t.MinecraftBlockTypes.air.id,
                B: t.MinecraftBlockTypes.mossyCobblestone.id
            }), this.portal_mindBoss = new A, this.portal_mindBoss.setDirection(A.DIRECTION_LAY).setStructure([
                ["XSSSX", "SWWWS", "SWYWS", "SWWWS", "XSSSX"],
                ["XAAAX", "AAAAA", "AAAAA", "AAAAA", "XAAAX"]
            ]).analysis({
                X: "wb:block_magic_equipment",
                W: t.MinecraftBlockTypes.water.id,
                Y: "wb:block_senior_equipment",
                S: "wb:block_magic_barrier",
                A: t.MinecraftBlockTypes.air.id
            });
            let r = new D.Z(this.setting.worldSeed);
            this.ruin_desertBoss = new re(r.nextInt()), this.ruin_stoneBoss = new ae(r.nextInt()), this.ruin_caveBoss = new ie(r.nextInt()), this.ruin_ancientBoss = new oe(r.nextInt()), this.ruin_mindBoss = new ue(r.nextInt()), h.push((() => {
                this.ruin_desertBoss.init(J.DESERT_RUIN_LOCATION_START.x, J.DESERT_RUIN_LOCATION_START.y, J.DESERT_RUIN_LOCATION_START.z, this.getDimension(t.MinecraftDimensionTypes.theEnd)), this.ruin_desertBoss.dispose(), this.ruin_stoneBoss.init(J.STONE_RUIN_LOCATION_START.x, J.STONE_RUIN_LOCATION_START.y, J.STONE_RUIN_LOCATION_START.z, this.getDimension(t.MinecraftDimensionTypes.theEnd)), this.ruin_stoneBoss.dispose(), this.ruin_caveBoss.init(J.CAVE_RUIN_LOCATION_START.x, J.CAVE_RUIN_LOCATION_START.y, J.CAVE_RUIN_LOCATION_START.z, this.getDimension(t.MinecraftDimensionTypes.theEnd)), this.ruin_caveBoss.dispose(), this.ruin_ancientBoss.init(J.ANCIENT_RUIN_LOCATION_START.x, J.ANCIENT_RUIN_LOCATION_START.y, J.ANCIENT_RUIN_LOCATION_START.z, this.getDimension(t.MinecraftDimensionTypes.theEnd)), this.ruin_ancientBoss.dispose(), this.ruin_mindBoss.init(J.MIND_RUIN_LOCATION_START.x, J.MIND_RUIN_LOCATION_START.y, J.MIND_RUIN_LOCATION_START.z, this.getDimension(t.MinecraftDimensionTypes.theEnd)), this.ruin_ancientBoss.dispose()
            }));
            const a = () => {
                let e = this.getExDimension(t.MinecraftDimensionTypes.theEnd).getEntities({
                    location: k.Z.getLocation(J.DESERT_RUIN_LOCATION_CENTER),
                    maxDistance: 400
                });
                for (let t of e) "minecraft:item" === t.typeId && 0 === t.viewDirection.y && t.kill()
            };
            this.ruinCleaner = new L(this.getEvents(), (() => {
                a()
            })).delay(6e4), a(), this.ruinCleaner.start();
            const o = t => J.DESERT_RUIN_PROTECT_AREA.contains(t) || J.STONE_RUIN_PROTECT_AREA.contains(t) || J.CAVE_RUIN_PROTECT_AREA.contains(t) || J.ANCIENT_RUIN_PROTECT_AREA.contains(t) || J.MIND_RUIN_PROTECT_AREA.contains(t);
            this.getEvents().events.blockBreak.subscribe((e => {
                if (e.dimension === this.getDimension(t.MinecraftDimensionTypes.theEnd) && o(e.block)) {
                    let n = d.Z.getInstance(e.player);
                    e.dimension.getBlock(e.block.location).setType(e.brokenBlockPermutation.type), n.getExDimension().command.run("kill @e[type=item,r=2,x=" + e.block.x + ",y=" + e.block.y + ",z=" + e.block.z + "]"), e.player.addEffect(t.MinecraftEffectTypes.nausea, 200, 0, !0), e.player.addEffect(t.MinecraftEffectTypes.blindness, 200, 0, !0), e.player.addEffect(t.MinecraftEffectTypes.darkness, 400, 0, !0), e.player.addEffect(t.MinecraftEffectTypes.wither, 100, 0, !0), e.player.addEffect(t.MinecraftEffectTypes.miningFatigue, 600, 2, !0), e.player.addEffect(t.MinecraftEffectTypes.hunger, 600, 1, !0), n.command.run('tellraw @s { "rawtext" : [ { "translate" : "text.dec:i_inviolable.name" } ] }')
                }
            })), this.getEvents().events.beforeItemUseOn.subscribe((e => {
                e.source.dimension === this.getDimension(t.MinecraftDimensionTypes.theEnd) && o(e.blockLocation) && (e.cancel = !0)
            })), this.getEvents().events.beforeExplosion.subscribe((e => {
                e.source && e.dimension === this.getDimension(t.MinecraftDimensionTypes.theEnd) && o(e.source.location) && 0 !== e.impactedBlocks.length && (this.getExDimension(t.MinecraftDimensionTypes.theEnd).spawnParticle("dec:damp_explosion_particle", e.source.location), e.cancel = !0)
            })), this.getEvents().events.beforeItemUse.subscribe((e => {
                var n;
                e.source.dimension === this.getDimension(t.MinecraftDimensionTypes.theEnd) && o(e.source.location) && (n = e.item.typeId, he.includes(n) && (e.cancel = !0))
            }));
            const l = this.getExDimension(t.MinecraftDimensionTypes.theEnd);
            let c = 0;
            const p = new e.Z,
                m = new e.Z;
            this.ruinDesertGuardPos = new e.Z(J.DESERT_RUIN_LOCATION_CENTER), this.ruinDesertGuardRule = new u.Z(this.getEvents(), (() => {
                if (l.spawnParticle("wb:ruin_desert_guardpar", this.ruinDesertGuardPos), c > 400 && (c = 0), c > 200) {
                    let e = l.getPlayers({
                        location: k.Z.getLocation(J.DESERT_RUIN_LOCATION_CENTER),
                        maxDistance: 400,
                        closest: 1,
                        gameMode: t.GameMode.adventure
                    });
                    if (e.length > 0) {
                        const t = e[0].location;
                        t.x && t.y && t.z && (m.set(t), p.set(this.ruinDesertGuardPos), m.sub(p), m.len() < 2 && I.Z.getInstance(e[0]).damage(4), m.normalize(), p.set(t).sub(J.DESERT_RUIN_LOCATION_START).div(16).floor(), this.ruin_desertBoss.isInRoom(`${p.x},${p.y},${p.z}`) ? this.ruinDesertGuardPos.add(m.scl(.2)) : this.ruinDesertGuardPos.add(m.scl(.38)))
                    }
                }
                c += 1
            })).delay(1), this.ruinFuncLooper = new u.Z(this.getEvents(), (() => {
                var e;
                let n = !1,
                    i = !1;
                for (let t of this.getClients()) p.set(t.player.location), this.ruin_desertBoss.isCompleted() && p.x >= J.DESERT_RUIN_LOCATION_START.x && p.x <= J.DESERT_RUIN_LOCATION_END.x && p.z >= J.DESERT_RUIN_LOCATION_START.z && p.z <= J.DESERT_RUIN_LOCATION_END.z && (n = !0), p.x >= J.MIND_RUIN_LOCATION_START.x && p.x <= J.MIND_RUIN_LOCATION_END.x && p.z >= J.MIND_RUIN_LOCATION_START.z && p.z <= J.MIND_RUIN_LOCATION_END.z && (i = !0);
                if (n ? (this.ruinDesertGuardRule.start(), this.ruinCleaner.start()) : (this.ruinDesertGuardRule.stop(), this.ruinCleaner.stop()), i) {
                    let n = null === (e = this.ruin_mindBoss.getBossSpawnArea()) || void 0 === e ? void 0 : e.center();
                    n && !pt.find(n) && this.getExDimension(t.MinecraftDimensionTypes.theEnd).spawnParticle("wb:ruin_mind_boss_center_par", n)
                }
            })).delay(240), this.ruinFuncLooper.start(), this.getEvents().events.entitySpawn.subscribe((e => {
                e.entity.typeId === t.MinecraftEntityTypes.enderman.id && e.entity.dimension === this.getDimension(t.MinecraftDimensionTypes.theEnd) && o(e.entity.location) && e.entity.triggerEvent("minecraft:despawn")
            })), this.addEntityController(Wt.typeId, Wt), this.addEntityController(Bt.typeId, Bt), this.addEntityController(Ft.typeId, Ft), this.addEntityController(Kt.typeId, Kt), this.addEntityController(Gt.typeId, Gt), this.addEntityController(jt.typeId, jt), new ce.NeuralNetwork
        }
        sayTo(e) {
            this.getExDimension(t.MinecraftDimensionTypes.theEnd).command.run(`tellraw @a {"rawtext": [{"text": "${e}"}]}`)
        }
        updateClearEntityNum() {
            this.entityCleanerStrength = this.setting.entityCleanerStrength, this.entityCleanerLeastNum = this.setting.entityCleanerLeastNum, this.entityCleanerDelay = (60 - this.setting.entityCleanerDelay) / 100 + 1.8
        }
        upDateEntityCleaner() {
            this.setting.entityCleaner ? this.entityCleaner.start() : this.entityCleaner.stop()
        }
        time(t) {
            (new le).print()
        }
        damageShow(t) {
            bt(n.Z.getInstance(t.hurtEntity.dimension), t.damage, t.hurtEntity.location)
        }
        newClient(t, e) {
            return new Qt(this, t, e)
        }
    }
    pe([(0, x.K)("chat", ((t, e) => "time" === e.message)), de("design:type", Function), de("design:paramtypes", [t.ChatEvent]), de("design:returntype", void 0)], me.prototype, "time", null), pe([(0, x.K)("entityHurt", ((e, n) => e.setting.damageShow && n.cause !== t.EntityDamageCause.suicide)), de("design:type", Function), de("design:paramtypes", [t.EntityHurtEvent]), de("design:returntype", void 0)], me.prototype, "damageShow", null);
    class ge {
        constructor(t, e, n, i) {
            this.head = t, this.chest = e, this.legs = n, this.boots = i
        }
        detect(t) {
            return t.detectArmor(this.head, this.chest, this.legs, this.boots)
        }
        find(t) {
            return e = this, n = void 0, s = function*() {
                try {
                    return yield t.run("execute as @a if entity @s[hasitem={location=slot.armor.head,item=" + this.head + "}] if entity @s[hasitem={location=slot.armor.chest,item=" + this.chest + "}] if entity @s[hasitem={location=slot.armor.legs,item=" + this.legs + "}] if entity @s[hasitem={location=slot.armor.feet,item=" + this.boots + "}] run tag @s add armorTest:" + this.name)
                } catch (t) {
                    return t
                }
            }, new((i = void 0) || (i = Promise))((function(t, r) {
                function a(t) {
                    try {
                        u(s.next(t))
                    } catch (t) {
                        r(t)
                    }
                }

                function o(t) {
                    try {
                        u(s.throw(t))
                    } catch (t) {
                        r(t)
                    }
                }

                function u(e) {
                    e.done ? t(e.value) : function(t) {
                        return t instanceof i ? t : new i((function(e) {
                            e(t)
                        }))
                    }(e.value).then(a, o)
                }
                u((s = s.apply(e, n || [])).next())
            }));
            var e, n, i, s
        }
    }
    let fe = {
            rupert: new ge("dec:rupert_helmet", "dec:rupert_chestplate", "dec:rupert_leggings", "dec:rupert_boots"),
            lava: new ge("dec:lava_helmet", "dec:lava_chestplate", "dec:lava_leggings", "dec:lava_boots"),
            crying: new ge("dec:crying_helmet", "dec:crying_chestplate", "dec:crying_leggings", "dec:crying_boots"),
            everlasting_winter: new ge("dec:everlasting_winter_helmet", "dec:everlasting_winter_chestplate", "dec:everlasting_winter_leggings", "dec:everlasting_winter_boots"),
            amethyst: new ge("dec:amethyst_helmet", "dec:amethyst_chestplate", "dec:amethyst_leggings", "dec:amethyst_boots"),
            turtle: new ge("minecraft:turtle_helmet", "dec:turtle_chestplate", "dec:turtle_leggings", "dec:turtle_boots"),
            wood: new ge("dec:wood_helmet", "dec:wood_chestplate", "dec:wood_leggings", "dec:wood_boots")
        },
        ye = function(t, e) {
            for (let n in e) n in t || (t[n] = e[n]);
            return t
        }({
            bloodsucking: new ge("wb:armor_bloodsucking_helmet", "wb:armor_bloodsucking_chestplate", "wb:armor_bloodsucking_leggings", "wb:armor_bloodsucking_boots"),
            ink: new ge("wb:armor_ink_helmet", "wb:armor_ink_chestplate", "wb:armor_ink_leggings", "wb:armor_ink_boots"),
            forget: new ge("wb:armor_forget_helmet", "wb:armor_forget_chestplate", "wb:armor_forget_leggings", "wb:armor_forget_boots"),
            seal: new ge("wb:armor_seal_helmet", "wb:armor_seal_chestplate", "wb:armor_seal_leggings", "wb:armor_seal_boots"),
            equipment: new ge("wb:armor_equipment_helmet", "wb:armor_equipment_chestplate", "wb:armor_equipment_leggings", "wb:armor_equipment_boots"),
            water: new ge("wb:armor_water_helmet", "wb:armor_water_chestplate", "wb:armor_water_leggings", "wb:armor_water_boots"),
            senior_bloodsucking: new ge("wb:armor_senior_bloodsucking_helmet", "wb:armor_senior_bloodsucking_chestplate", "wb:armor_senior_bloodsucking_leggings", "wb:armor_senior_bloodsucking_boots"),
            senior_ink: new ge("wb:armor_senior_ink_helmet", "wb:armor_senior_ink_chestplate", "wb:armor_senior_ink_leggings", "wb:armor_senior_ink_boots"),
            senior_forget: new ge("wb:armor_senior_forget_helmet", "wb:armor_senior_forget_chestplate", "wb:armor_senior_forget_leggings", "wb:armor_senior_forget_boots"),
            senior_seal: new ge("wb:armor_senior_seal_helmet", "wb:armor_senior_seal_chestplate", "wb:armor_senior_seal_leggings", "wb:armor_senior_seal_boots"),
            senior_equipment: new ge("wb:armor_senior_equipment_helmet", "wb:armor_senior_equipment_chestplate", "wb:armor_senior_equipment_leggings", "wb:armor_senior_equipment_boots"),
            senior_water: new ge("wb:armor_senior_water_helmet", "wb:armor_senior_water_chestplate", "wb:armor_senior_water_leggings", "wb:armor_senior_water_boots")
        }, fe),
        xe = new Map;
    for (let t in ye) ye[t].name = t, xe.set(ye[t], t);
    class _e {
        static isDec() {
            return "DEC" === s.Z.config.addonName
        }
    }
    class be extends i.Z {
        constructor(t, n, i) {
            super(t, n, i), this.useArmor = void 0, this.tmpV = new e.Z(0, 0, 0), this.globalscores = new $(new S.C("global"))
        }
        onJoin() {
            super.onJoin(), this.getEvents().exEvents.playerHurt.subscribe((e => {
                this.exPlayer.getHealth() <= 0 && (this.exPlayer.command.run("function die/normal"), 1 === this.globalscores.getNumber("DieMode") ? this.exPlayer.command.run("function die/die_mode") : 1 == F.randomInteger(1, 3) && this.exPlayer.command.run("function die/ghost"));
                let n = F.randomInteger(1, 100);
                if (1 <= n && n <= 20 && this.useArmor === fe.rupert && (this.player.addEffect(t.MinecraftEffectTypes.regeneration, 200), this.player.addEffect(t.MinecraftEffectTypes.speed, 100), this.tmpV.set(this.player.location).add(0, 1, 0), this.getExDimension().spawnParticle("dec:tear_from_rupert", this.tmpV), this.getExDimension().spawnParticle("dec:tear_from_rupert", this.tmpV), this.getExDimension().spawnParticle("dec:tear_from_rupert", this.tmpV), this.getExDimension().spawnParticle("dec:tear_from_rupert", this.tmpV), this.getExDimension().spawnParticle("dec:tear_from_rupert", this.tmpV)), this.useArmor === fe.lava && (this.tmpV.set(this.player.location).add(0, 1, 0), this.getExDimension().spawnParticle("dec:fire_spurt_particle", this.tmpV), this.player.addEffect(t.MinecraftEffectTypes.fireResistance, 80)), this.useArmor === fe.crying && (n < 1 || (1 <= n && n <= 10 ? this.player.addEffect(t.MinecraftEffectTypes.weakness, 100) : n <= 20 ? this.player.addEffect(t.MinecraftEffectTypes.slowness, 80) : n <= 30 ? this.player.addEffect(t.MinecraftEffectTypes.blindness, 100) : n <= 40 && this.player.addEffect(t.MinecraftEffectTypes.nausea, 140))), 1 <= n && n <= 12 && this.useArmor === fe.everlasting_winter) {
                    for (let e of this.getDimension().getEntities({
                            maxDistance: 5,
                            location: k.Z.getLocation(this.player.location)
                        })) e != this.player && e.addEffect(t.MinecraftEffectTypes.slowness, 60, 1);
                    this.player.addEffect(t.MinecraftEffectTypes.healthBoost, 600, 0), this.tmpV.set(this.player.location), this.getExDimension().spawnParticle("dec:everlasting_winter_spurt_particle", this.tmpV)
                }
                if (!_e.isDec() && !this.player.hasTag("wbkjlq")) switch (this.useArmor) {
                    case ye.bloodsucking:
                        this.exPlayer.command.run("function armor/bloodsucking");
                        break;
                    case ye.senior_bloodsucking:
                        this.exPlayer.command.run("function armor/bloodsucking2");
                        break;
                    case ye.ink:
                    case ye.senior_ink:
                        break;
                    case ye.senior_seal:
                        this.exPlayer.command.run("function armor/seal2");
                        break;
                    case ye.seal:
                        this.exPlayer.command.run("function armor/seal");
                        break;
                    case ye.senior_water:
                        this.exPlayer.command.run("function armor/water2");
                        break;
                    case ye.water:
                        this.exPlayer.command.run("function armor/water");
                        break;
                    case ye.senior_equipment:
                        this.exPlayer.command.run("function armor/equipment2");
                        break;
                    case ye.equipment:
                        this.exPlayer.command.run("function armor/equipment");
                        break;
                    case ye.senior_forget:
                        this.exPlayer.command.run("function armor/forget2");
                        break;
                    case ye.forget:
                        this.exPlayer.command.run("function armor/forget")
                }
            })), this.getEvents().exEvents.itemOnHandChange.subscribe((t => {
                let e = this.exPlayer.getBag();
                const n = t.afterItem;
                if (n && "dec:magic_scroll_blue" == n.typeId && 1 == n.amount && 0 == n.getLore().length) {
                    let t = F.randomInteger(1, 3),
                        i = n,
                        s = [],
                        r = _e.isDec() ? kt : Dt;
                    for (let e = 0; e < t; e++) s.push(D.Z.choice(r).id.split("").map((t => Lt[parseInt(t)])).join(" "));
                    i.setLore(s), e.setItemOnHand(i)
                }
            })), this.getEvents().exEvents.tick.subscribe((e => {
                var n;
                const i = this.player,
                    s = this.exPlayer,
                    r = this.exPlayer.getScoresManager();
                if (i.isSneaking ? i.addTag("is_sneaking") : i.removeTag("is_sneaking"), i.dimension.id === t.MinecraftDimensionTypes.overworld ? (i.addTag("dOverworld"), i.removeTag("dNether"), i.removeTag("dTheEnd")) : i.dimension.id === t.MinecraftDimensionTypes.nether ? (i.addTag("dNether"), i.removeTag("dOverworld"), i.removeTag("dTheEnd"), e.currentTick % 80 == 0 && s.command.run('fog @s remove "night_event"')) : i.dimension.id === t.MinecraftDimensionTypes.theEnd && (i.addTag("dTheEnd"), i.removeTag("dNether"), i.removeTag("dOverworld"), e.currentTick % 80 == 0 && s.command.run('fog @s remove "night_event"')), e.currentTick % 20 == 0 && this.useArmor === fe.amethyst)
                    if (_e.isDec()) {
                        let t = r.getScore("magicpoint");
                        11 <= t && t <= 29 && (this.getExDimension().spawnParticle("dec:amethyst_armor_magic_increase_particle", i.location), r.addScoreAsync("magicpoint", 1))
                    } else {
                        let t = r.getScore("wbfl");
                        20 <= t && t <= 100 && (this.getExDimension().spawnParticle("dec:amethyst_armor_magic_increase_particle", i.location), r.addScoreAsync("wbfl", 1))
                    } e.currentTick % 40 == 0 && (this.useArmor === fe.rupert && this.getExDimension().spawnParticle("dec:tear_from_rupert", this.tmpV.set(i.location).add(0, 1, 0)), i.isSneaking && this.useArmor === fe.turtle && "dec:turtle_sword" === (null === (n = s.getBag().getItemOnHand()) || void 0 === n ? void 0 : n.typeId) && (i.addEffect(t.MinecraftEffectTypes.slowness, 100, 5), i.addEffect(t.MinecraftEffectTypes.slowness, 40, 3), i.addEffect(t.MinecraftEffectTypes.slowness, 40, 50))), e.currentTick % 100 == 0 && this.useArmor === fe.wood && (_e.isDec() ? r.getScore("magicpoint") <= 15 && (this.getExDimension().spawnParticle("dec:wood_armor_magic_increase_particle", i.location), r.addScoreAsync("magicpoint", 1)) : r.getScore("wbfl") <= 70 && (this.getExDimension().spawnParticle("dec:wood_armor_magic_increase_particle", i.location), r.addScoreAsync("wbfl", 1)))
            })), this.getEvents().exEvents.itemUse.subscribe((t => {
                "dec:magic_scroll_blue" == t.item.typeId && (_e.isDec() ? function(t, e) {
                    let n = new st.ActionFormData;
                    n = n.title("text.dec:task_choose_title.name"), n = n.body("text.dec:task_choose_body.name");
                    let i = e.getLore();
                    i.forEach((t => {
                        n = n.button(t)
                    })), n.show(t.player).then((e => {
                        if (null != e.selection) {
                            let n = Ct(i[e.selection]);
                            ! function(t, e) {
                                let n = (new st.ActionFormData).button("text.dec:task_complete_button.name");
                                const i = kt.findIndex((t => t.id === e)); - 1 !== i && n.title(kt[i].title()).body(kt[i].body()).show(t.player).then((e => {
                                    0 == e.selection && kt[i].detect(t.exPlayer)
                                }))
                            }(t, n)
                        }
                    }))
                }(this, t.item) : M.postMessageBetweenClient(this, me, "taskUi", ["paperTask", "1"]))
            }))
        }
        checkArmor() {
            return t = this, e = void 0, i = function*() {
                return _e.isDec() || (this.useArmor === ye.ink ? this.player.triggerEvent("armor_ink") : this.useArmor === ye.senior_ink ? this.player.triggerEvent("armor_senior_ink") : this.player.triggerEvent("hostile_mode")), !!this.useArmor && (yield this.useArmor.detect(this.exPlayer))
            }, new((n = void 0) || (n = Promise))((function(s, r) {
                function a(t) {
                    try {
                        u(i.next(t))
                    } catch (t) {
                        r(t)
                    }
                }

                function o(t) {
                    try {
                        u(i.throw(t))
                    } catch (t) {
                        r(t)
                    }
                }

                function u(t) {
                    t.done ? s(t.value) : function(t) {
                        return t instanceof n ? t : new n((function(e) {
                            e(t)
                        }))
                    }(t.value).then(a, o)
                }
                u((i = i.apply(t, e || [])).next())
            }));
            var t, e, n, i
        }
        chooseArmor(t) {
            this.useArmor = t
        }
        onLoaded() {
            super.onLoaded()
        }
        onLeave() {
            super.onLeave()
        }
    }
    class we extends Pt {
        constructor(t, e) {
            super(t, e)
        }
        despawn() {
            this.entity.triggerEvent("minecraft:despawn")
        }
        onFail() {
            this.server.say({
                rawtext: [{
                    translate: "text.dec:killed_by_boss.name"
                }]
            }), this.despawn()
        }
        onWin() {
            if (!_e.isDec())
                for (let t of this.entity.dimension.getPlayers({
                        location: k.Z.getLocation(this.entity.location),
                        maxDistance: 32
                    })) {
                    let e = this.server.findClientByPlayer(t);
                    e && M.postMessageBetweenClient(e, me, "progressTaskFinish", [this.entity.typeId, 1e3])
                }
        }
    }
    class Te extends we {
        constructor(t, e) {
            super(t, e)
        }
        onDestroy() {
            super.onDestroy()
        }
        onSpawn() {
            super.onSpawn()
        }
        onKilled(t) {
            this.onWin(), super.onKilled(t)
        }
    }
    class ve extends we {
        constructor(t, e) {
            super(t, e), this.music = new Ut("music.wb.ghost_tears", "2:16"), this.setTimeout((() => {
                this.music.loop(this.getEvents(), this.exEntity.getExDimension(), this.entity.location)
            }), 500)
        }
        onDestroy() {
            this.music.stop(), super.onDestroy()
        }
        onSpawn() {
            super.onSpawn()
        }
    }
    class Ee extends Te {
        constructor(t, e) {
            super(t, e), this.music = new Ut("music.wb.the_peotry_of_ghost", "3:12"), this.setTimeout((() => {
                this.music.loop(this.getEvents(), this.exEntity.getExDimension(), this.entity.location)
            }), 500)
        }
        onDestroy() {
            this.music.stop(), super.onDestroy()
        }
        onSpawn() {
            super.onSpawn()
        }
    }
    let Ae = new class {
        constructor() {
            this.addonName = "", this.gameVersion = "1.9.20", this.addonVersion = "1.7.4B1", this.debug = !1, this.watchDog = !1
        }
    };
    Ae.addonName = "POM", Ae.addonVersion = "1.7.4B1", Ae.gameVersion = "1.9.50", Ae.watchDog = !1, Ae.debug = !0, M.createServer(me, Ae), M.createServer(class extends T {
        constructor(n) {
            super(n), this.tmpV = new e.Z, this.i_inviolable = new S.C("i_inviolable").create("i_inviolable"), this.i_damp = new S.C("i_damp").create("i_damp"), this.i_soft = new S.C("i_soft").create("i_soft"), this.nightEventListener = new ut((e => {
                e ? this.getExDimension(t.MinecraftDimensionTypes.overworld).command.run(["scoreboard players random NightRandom global 1 100", "scoreboard players set IsDay global 0", "scoreboard players set IsNight global 1"]) : this.getExDimension(t.MinecraftDimensionTypes.overworld).command.run(["scoreboard players set IsDay global 1", "scoreboard players set IsNight global 0", "scoreboard players set NightRandom global 0", "scoreboard players set @a night_event 0", 'fog @a remove "night_event"'])
            }), !1), this.getEvents().events.beforeChat.subscribe((e => {
                let n = this.getExDimension(t.MinecraftDimensionTypes.overworld),
                    i = d.Z.getInstance(e.sender);
                if (e.message.startsWith(">/")) {
                    let t = function(t) {
                            (t.startsWith("/") || t.startsWith("$")) && (t = t.substring(1, t.length));
                            let e = t.split(" "),
                                n = [];
                            for (let t of e) n.push(t);
                            return n
                        }(e.message.substring(2)),
                        s = "";
                    switch (t[0]) {
                        case "help":
                            i.command.run("function help");
                            break;
                        case "creators":
                            _e.isDec() && i.command.run("function test/creator_list");
                            break;
                        case "diemode":
                            "open" === t[1] ? i.command.run("function diemode/open") : "test" === t[1] ? i.command.run("function diemode/test") : s = "Invalid command " + t[1];
                            break;
                        case "magic":
                            _e.isDec() && ("display" === t[1] ? e.sender.isOp() ? "true" === t[2] ? n.command.run("function magic/display_on") : "false" === t[2] ? n.command.run("function magic/display_off") : s = "Invalid command " + t[2] : i.command.run('tellraw @s { "rawtext" : [ { "translate" : "text.dec:command_fail.name" } ] }') : s = "Invalid command " + t[1])
                    }
                    0 !== s.length && i.command.run(`tellraw @s { "rawtext" : [ { "text" : "Command Error: ${s}" } ] }`), e.cancel = !0
                }
            })), this.getEvents().events.blockBreak.subscribe((e => {
                const n = d.Z.getInstance(e.player);
                n.getScoresManager().getScore(this.i_inviolable) > 1 && (e.dimension.getBlock(e.block.location).setType(e.brokenBlockPermutation.type), n.getExDimension().command.run("kill @e[type=item,r=2,x=" + e.block.x + ",y=" + e.block.y + ",z=" + e.block.z + "]"), e.player.addEffect(t.MinecraftEffectTypes.nausea, 200, 0, !0), e.player.addEffect(t.MinecraftEffectTypes.blindness, 200, 0, !0), e.player.addEffect(t.MinecraftEffectTypes.darkness, 400, 0, !0), e.player.addEffect(t.MinecraftEffectTypes.wither, 100, 0, !0), e.player.addEffect(t.MinecraftEffectTypes.miningFatigue, 600, 2, !0), e.player.addEffect(t.MinecraftEffectTypes.hunger, 600, 1, !0), n.command.run('tellraw @s { "rawtext" : [ { "translate" : "text.dec:i_inviolable.name" } ] }'))
            })), this.getEvents().events.beforeExplosion.subscribe((t => {
                if (t.source) {
                    const e = I.Z.getInstance(t.source);
                    e.getScoresManager().getScore(this.i_damp) > 0 && (e.getExDimension().spawnParticle("dec:damp_explosion_particle", t.source.location), t.cancel = !0)
                }
            })), this.getEvents().events.beforeItemUseOn.subscribe((t => {
                I.Z.getInstance(t.source).getScoresManager().getScore(this.i_soft) > 0 && "dec:iron_key" != t.item.typeId && "dec:frozen_power" != t.item.typeId && (t.cancel = !0)
            })), this.getEvents().events.tick.subscribe((e => {
                if (this.getExDimension(t.MinecraftDimensionTypes.overworld).command.run(["scoreboard players remove @e[scores={i_inviolable=1..}] i_inviolable 1", "scoreboard players remove @e[scores={i_damp=1..}] i_damp 1", "scoreboard players remove @e[scores={i_soft=1..}] i_soft 1", "scoreboard players remove @e[scores={harmless=1..}] harmless 1"]), e.currentTick % 100 == 0) {
                    this.nightEventListener.upDate((new le).isNight());
                    let e = [];
                    for (const t of this.getClients()) e.push(t.checkArmor());
                    (0, o.to)(Promise.all(e).then((e => {
                        if (!e.every((t => t))) {
                            let e = [];
                            if (_e.isDec())
                                for (let n in fe) e.push(fe[n].find(this.getExDimension(t.MinecraftDimensionTypes.overworld).command));
                            else
                                for (let n in ye) e.push(ye[n].find(this.getExDimension(t.MinecraftDimensionTypes.overworld).command));
                            (0, o.to)(Promise.all(e).then((t => {
                                for (const t of this.getClients()) {
                                    let e = !1;
                                    for (let n of t.player.getTags()) n.startsWith("armorTest:") && (t.player.removeTag(n), t.chooseArmor(ye[n.split(":")[1]]), e = !0);
                                    e || t.chooseArmor(void 0)
                                }
                            })))
                        }
                    })))
                }
            })), this.addEntityController("dec:leaves_golem", Te), this.addEntityController("dec:king_of_pillager", Te), this.addEntityController("dec:abyssal_controller", Te), this.addEntityController("dec:predators", Te), this.addEntityController("dec:enchant_illager_2", Te), this.addEntityController("dec:escaped_soul_entity", Te), this.addEntityController("dec:host_of_deep_2", Te), this.addEntityController("dec:ash_knight", Te), this.addEntityController("dec:everlasting_winter_ghast", ve), this.addEntityController("dec:everlasting_winter_ghast_1", Ee)
        }
        newClient(t, e) {
            return new be(this, t, e)
        }
    }, Ae)
})();